{
  "version": 3,
  "sources": ["../../../node_modules/denque/index.js", "../src/index.ts", "../src/constants.ts", "../../interface/src/errors.ts", "../../interface/src/peer-id.ts", "../../../node_modules/main-event/src/index.ts", "../../interface/src/index.ts", "../../../node_modules/multiformats/src/bases/base58.ts", "../../../node_modules/multiformats/src/bytes.ts", "../../../node_modules/multiformats/src/vendor/base-x.js", "../../../node_modules/multiformats/src/bases/base.ts", "../../../node_modules/multiformats/src/bases/base32.ts", "../../../node_modules/multiformats/src/bases/base36.ts", "../../../node_modules/multiformats/src/vendor/varint.js", "../../../node_modules/multiformats/src/varint.ts", "../../../node_modules/multiformats/src/hashes/digest.ts", "../../../node_modules/multiformats/src/cid.ts", "../../../node_modules/multiformats/src/hashes/identity.ts", "../../../node_modules/uint8arrays/src/equals.ts", "../../../node_modules/uint8arrays/src/alloc.ts", "../../../node_modules/uint8arrays/src/concat.ts", "../../../node_modules/uint8arraylist/src/index.ts", "../../../node_modules/multiformats/src/bases/base10.ts", "../../../node_modules/multiformats/src/bases/base16.ts", "../../../node_modules/multiformats/src/bases/base2.ts", "../../../node_modules/multiformats/src/bases/base256emoji.ts", "../../../node_modules/multiformats/src/bases/base64.ts", "../../../node_modules/multiformats/src/bases/base8.ts", "../../../node_modules/multiformats/src/bases/identity.ts", "../../../node_modules/multiformats/src/codecs/json.ts", "../../../node_modules/multiformats/src/hashes/sha2-browser.ts", "../../../node_modules/multiformats/src/hashes/hasher.ts", "../../../node_modules/multiformats/src/basics.ts", "../../../node_modules/uint8arrays/src/util/bases.ts", "../../../node_modules/uint8arrays/src/from-string.ts", "../../../node_modules/uint8arrays/src/to-string.ts", "../../crypto/src/keys/rsa/der.ts", "../../crypto/src/keys/ecdsa/index.ts", "../../crypto/src/keys/ecdsa/utils.ts", "../../crypto/src/keys/ecdsa/ecdsa.ts", "../../../node_modules/@noble/hashes/src/utils.ts", "../../../node_modules/@noble/hashes/src/_md.ts", "../../../node_modules/@noble/hashes/src/_u64.ts", "../../../node_modules/@noble/hashes/src/sha2.ts", "../../../node_modules/@noble/curves/src/utils.ts", "../../../node_modules/@noble/curves/src/abstract/modular.ts", "../../../node_modules/@noble/curves/src/abstract/curve.ts", "../../../node_modules/@noble/curves/src/abstract/edwards.ts", "../../../node_modules/@noble/curves/src/ed25519.ts", "../../crypto/src/errors.ts", "../../crypto/src/webcrypto/webcrypto.browser.ts", "../../crypto/src/webcrypto/index.ts", "../../crypto/src/keys/ed25519/index.browser.ts", "../../crypto/src/util.ts", "../../crypto/src/keys/ed25519/ed25519.ts", "../../crypto/src/keys/ed25519/utils.ts", "../../../node_modules/uint8-varint/src/index.ts", "../../../node_modules/protons-runtime/src/utils/float.ts", "../../../node_modules/protons-runtime/src/utils/longbits.ts", "../../../node_modules/protons-runtime/src/utils/utf8.ts", "../../../node_modules/protons-runtime/src/utils/reader.ts", "../../../node_modules/protons-runtime/src/decode.ts", "../../../node_modules/protons-runtime/src/utils/pool.ts", "../../../node_modules/protons-runtime/src/utils/writer.ts", "../../../node_modules/protons-runtime/src/encode.ts", "../../../node_modules/protons-runtime/src/codec.ts", "../../../node_modules/protons-runtime/src/codecs/enum.ts", "../../../node_modules/protons-runtime/src/codecs/message.ts", "../../../node_modules/protons-runtime/src/index.ts", "../../crypto/src/keys/keys.ts", "../../crypto/src/random-bytes.ts", "../../crypto/src/keys/rsa/utils.ts", "../../crypto/src/keys/rsa/rsa.ts", "../../crypto/src/keys/rsa/index.browser.ts", "../../../node_modules/@noble/hashes/src/hmac.ts", "../../../node_modules/@noble/curves/src/abstract/weierstrass.ts", "../../../node_modules/@noble/curves/src/secp256k1.ts", "../../crypto/src/keys/secp256k1/index.browser.ts", "../../crypto/src/keys/secp256k1/secp256k1.ts", "../../crypto/src/keys/secp256k1/utils.ts", "../../crypto/src/keys/index.ts", "../../peer-id/src/peer-id.ts", "../../peer-id/src/index.ts", "../../../node_modules/it-length-prefixed/src/errors.ts", "../../../node_modules/it-length-prefixed/src/utils.ts", "../../../node_modules/it-length-prefixed/src/encode.ts", "../../../node_modules/it-length-prefixed/src/decode.ts", "../../../node_modules/p-defer/index.js", "../../../node_modules/it-pushable/src/fifo.ts", "../../../node_modules/it-pushable/src/index.ts", "../../../node_modules/it-queueless-pushable/node_modules/race-signal/src/index.ts", "../../../node_modules/it-queueless-pushable/src/index.ts", "../../../node_modules/it-merge/src/index.ts", "../../../node_modules/it-pipe/src/index.ts", "../src/message/decodeRpc.ts", "../src/message/rpc.ts", "../src/message-cache.ts", "../src/types.ts", "../src/metrics.ts", "../src/errors.ts", "../src/score/peer-score-params.ts", "../src/score/peer-score-thresholds.ts", "../src/utils/set.ts", "../src/score/compute-score.ts", "../src/score/message-deliveries.ts", "../src/score/peer-score.ts", "../src/score/scoreMetrics.ts", "../../utils/src/multiaddr/get-net-config.ts", "../../utils/src/multiaddr/is-network-address.ts", "../../../node_modules/p-timeout/index.js", "../../../node_modules/p-event/index.js", "../../utils/src/stream-utils.ts", "../src/stream.ts", "../src/tracer.ts", "../src/utils/buildRawMessage.ts", "../src/utils/create-gossip-rpc.ts", "../src/utils/shuffle.ts", "../src/utils/messageIdToString.ts", "../src/utils/publishConfig.ts", "../../../node_modules/@libp2p/pubsub/src/utils.ts", "../src/utils/msgIdFn.ts", "../src/utils/multiaddr.ts", "../src/utils/time-cache.ts", "../src/gossipsub.ts"],
  "sourcesContent": ["'use strict';\n\n/**\n * Custom implementation of a double ended queue.\n */\nfunction Denque(array, options) {\n  var options = options || {};\n  this._capacity = options.capacity;\n\n  this._head = 0;\n  this._tail = 0;\n\n  if (Array.isArray(array)) {\n    this._fromArray(array);\n  } else {\n    this._capacityMask = 0x3;\n    this._list = new Array(4);\n  }\n}\n\n/**\n * --------------\n *  PUBLIC API\n * -------------\n */\n\n/**\n * Returns the item at the specified index from the list.\n * 0 is the first element, 1 is the second, and so on...\n * Elements at negative values are that many from the end: -1 is one before the end\n * (the last element), -2 is two before the end (one before last), etc.\n * @param index\n * @returns {*}\n */\nDenque.prototype.peekAt = function peekAt(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var len = this.size();\n  if (i >= len || i < -len) return undefined;\n  if (i < 0) i += len;\n  i = (this._head + i) & this._capacityMask;\n  return this._list[i];\n};\n\n/**\n * Alias for peekAt()\n * @param i\n * @returns {*}\n */\nDenque.prototype.get = function get(i) {\n  return this.peekAt(i);\n};\n\n/**\n * Returns the first item in the list without removing it.\n * @returns {*}\n */\nDenque.prototype.peek = function peek() {\n  if (this._head === this._tail) return undefined;\n  return this._list[this._head];\n};\n\n/**\n * Alias for peek()\n * @returns {*}\n */\nDenque.prototype.peekFront = function peekFront() {\n  return this.peek();\n};\n\n/**\n * Returns the item that is at the back of the queue without removing it.\n * Uses peekAt(-1)\n */\nDenque.prototype.peekBack = function peekBack() {\n  return this.peekAt(-1);\n};\n\n/**\n * Returns the current length of the queue\n * @return {Number}\n */\nObject.defineProperty(Denque.prototype, 'length', {\n  get: function length() {\n    return this.size();\n  }\n});\n\n/**\n * Return the number of items on the list, or 0 if empty.\n * @returns {number}\n */\nDenque.prototype.size = function size() {\n  if (this._head === this._tail) return 0;\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Add an item at the beginning of the list.\n * @param item\n */\nDenque.prototype.unshift = function unshift(item) {\n  if (arguments.length === 0) return this.size();\n  var len = this._list.length;\n  this._head = (this._head - 1 + len) & this._capacityMask;\n  this._list[this._head] = item;\n  if (this._tail === this._head) this._growArray();\n  if (this._capacity && this.size() > this._capacity) this.pop();\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the first item on the list,\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.shift = function shift() {\n  var head = this._head;\n  if (head === this._tail) return undefined;\n  var item = this._list[head];\n  this._list[head] = undefined;\n  this._head = (head + 1) & this._capacityMask;\n  if (head < 2 && this._tail > 10000 && this._tail <= this._list.length >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Add an item to the bottom of the list.\n * @param item\n */\nDenque.prototype.push = function push(item) {\n  if (arguments.length === 0) return this.size();\n  var tail = this._tail;\n  this._list[tail] = item;\n  this._tail = (tail + 1) & this._capacityMask;\n  if (this._tail === this._head) {\n    this._growArray();\n  }\n  if (this._capacity && this.size() > this._capacity) {\n    this.shift();\n  }\n  if (this._head < this._tail) return this._tail - this._head;\n  else return this._capacityMask + 1 - (this._head - this._tail);\n};\n\n/**\n * Remove and return the last item on the list.\n * Returns undefined if the list is empty.\n * @returns {*}\n */\nDenque.prototype.pop = function pop() {\n  var tail = this._tail;\n  if (tail === this._head) return undefined;\n  var len = this._list.length;\n  this._tail = (tail - 1 + len) & this._capacityMask;\n  var item = this._list[this._tail];\n  this._list[this._tail] = undefined;\n  if (this._head < 2 && tail > 10000 && tail <= len >>> 2) this._shrinkArray();\n  return item;\n};\n\n/**\n * Remove and return the item at the specified index from the list.\n * Returns undefined if the list is empty.\n * @param index\n * @returns {*}\n */\nDenque.prototype.removeOne = function removeOne(index) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size) return void 0;\n  if (i < 0) i += size;\n  i = (this._head + i) & this._capacityMask;\n  var item = this._list[i];\n  var k;\n  if (index < size / 2) {\n    for (k = index; k > 0; k--) {\n      this._list[i] = this._list[i = (i - 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._head = (this._head + 1 + len) & this._capacityMask;\n  } else {\n    for (k = size - 1 - index; k > 0; k--) {\n      this._list[i] = this._list[i = (i + 1 + len) & this._capacityMask];\n    }\n    this._list[i] = void 0;\n    this._tail = (this._tail - 1 + len) & this._capacityMask;\n  }\n  return item;\n};\n\n/**\n * Remove number of items from the specified index from the list.\n * Returns array of removed items.\n * Returns undefined if the list is empty.\n * @param index\n * @param count\n * @returns {array}\n */\nDenque.prototype.remove = function remove(index, count) {\n  var i = index;\n  var removed;\n  var del_count = count;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  if (this._head === this._tail) return void 0;\n  var size = this.size();\n  var len = this._list.length;\n  if (i >= size || i < -size || count < 1) return void 0;\n  if (i < 0) i += size;\n  if (count === 1 || !count) {\n    removed = new Array(1);\n    removed[0] = this.removeOne(i);\n    return removed;\n  }\n  if (i === 0 && i + count >= size) {\n    removed = this.toArray();\n    this.clear();\n    return removed;\n  }\n  if (i + count > size) count = size - i;\n  var k;\n  removed = new Array(count);\n  for (k = 0; k < count; k++) {\n    removed[k] = this._list[(this._head + i + k) & this._capacityMask];\n  }\n  i = (this._head + i) & this._capacityMask;\n  if (index + count === size) {\n    this._tail = (this._tail - count + len) & this._capacityMask;\n    for (k = count; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (index === 0) {\n    this._head = (this._head + count + len) & this._capacityMask;\n    for (k = count - 1; k > 0; k--) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n    }\n    return removed;\n  }\n  if (i < size / 2) {\n    this._head = (this._head + index + count + len) & this._capacityMask;\n    for (k = index; k > 0; k--) {\n      this.unshift(this._list[i = (i - 1 + len) & this._capacityMask]);\n    }\n    i = (this._head - 1 + len) & this._capacityMask;\n    while (del_count > 0) {\n      this._list[i = (i - 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n    if (index < 0) this._tail = i;\n  } else {\n    this._tail = i;\n    i = (i + count + len) & this._capacityMask;\n    for (k = size - (count + index); k > 0; k--) {\n      this.push(this._list[i++]);\n    }\n    i = this._tail;\n    while (del_count > 0) {\n      this._list[i = (i + 1 + len) & this._capacityMask] = void 0;\n      del_count--;\n    }\n  }\n  if (this._head < 2 && this._tail > 10000 && this._tail <= len >>> 2) this._shrinkArray();\n  return removed;\n};\n\n/**\n * Native splice implementation.\n * Remove number of items from the specified index from the list and/or add new elements.\n * Returns array of removed items or empty array if count == 0.\n * Returns undefined if the list is empty.\n *\n * @param index\n * @param count\n * @param {...*} [elements]\n * @returns {array}\n */\nDenque.prototype.splice = function splice(index, count) {\n  var i = index;\n  // expect a number or return undefined\n  if ((i !== (i | 0))) {\n    return void 0;\n  }\n  var size = this.size();\n  if (i < 0) i += size;\n  if (i > size) return void 0;\n  if (arguments.length > 2) {\n    var k;\n    var temp;\n    var removed;\n    var arg_len = arguments.length;\n    var len = this._list.length;\n    var arguments_index = 2;\n    if (!size || i < size / 2) {\n      temp = new Array(i);\n      for (k = 0; k < i; k++) {\n        temp[k] = this._list[(this._head + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i > 0) {\n          this._head = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._head = (this._head + i + len) & this._capacityMask;\n      }\n      while (arg_len > arguments_index) {\n        this.unshift(arguments[--arg_len]);\n      }\n      for (k = i; k > 0; k--) {\n        this.unshift(temp[k - 1]);\n      }\n    } else {\n      temp = new Array(size - (i + count));\n      var leng = temp.length;\n      for (k = 0; k < leng; k++) {\n        temp[k] = this._list[(this._head + i + count + k) & this._capacityMask];\n      }\n      if (count === 0) {\n        removed = [];\n        if (i != size) {\n          this._tail = (this._head + i + len) & this._capacityMask;\n        }\n      } else {\n        removed = this.remove(i, count);\n        this._tail = (this._tail - leng + len) & this._capacityMask;\n      }\n      while (arguments_index < arg_len) {\n        this.push(arguments[arguments_index++]);\n      }\n      for (k = 0; k < leng; k++) {\n        this.push(temp[k]);\n      }\n    }\n    return removed;\n  } else {\n    return this.remove(i, count);\n  }\n};\n\n/**\n * Soft clear - does not reset capacity.\n */\nDenque.prototype.clear = function clear() {\n  this._list = new Array(this._list.length);\n  this._head = 0;\n  this._tail = 0;\n};\n\n/**\n * Returns true or false whether the list is empty.\n * @returns {boolean}\n */\nDenque.prototype.isEmpty = function isEmpty() {\n  return this._head === this._tail;\n};\n\n/**\n * Returns an array of all queue items.\n * @returns {Array}\n */\nDenque.prototype.toArray = function toArray() {\n  return this._copyArray(false);\n};\n\n/**\n * -------------\n *   INTERNALS\n * -------------\n */\n\n/**\n * Fills the queue with items from an array\n * For use in the constructor\n * @param array\n * @private\n */\nDenque.prototype._fromArray = function _fromArray(array) {\n  var length = array.length;\n  var capacity = this._nextPowerOf2(length);\n\n  this._list = new Array(capacity);\n  this._capacityMask = capacity - 1;\n  this._tail = length;\n\n  for (var i = 0; i < length; i++) this._list[i] = array[i];\n};\n\n/**\n *\n * @param fullCopy\n * @param size Initialize the array with a specific size. Will default to the current list size\n * @returns {Array}\n * @private\n */\nDenque.prototype._copyArray = function _copyArray(fullCopy, size) {\n  var src = this._list;\n  var capacity = src.length;\n  var length = this.length;\n  size = size | length;\n\n  // No prealloc requested and the buffer is contiguous\n  if (size == length && this._head < this._tail) {\n    // Simply do a fast slice copy\n    return this._list.slice(this._head, this._tail);\n  }\n\n  var dest = new Array(size);\n\n  var k = 0;\n  var i;\n  if (fullCopy || this._head > this._tail) {\n    for (i = this._head; i < capacity; i++) dest[k++] = src[i];\n    for (i = 0; i < this._tail; i++) dest[k++] = src[i];\n  } else {\n    for (i = this._head; i < this._tail; i++) dest[k++] = src[i];\n  }\n\n  return dest;\n}\n\n/**\n * Grows the internal list array.\n * @private\n */\nDenque.prototype._growArray = function _growArray() {\n  if (this._head != 0) {\n    // double array size and copy existing data, head to end, then beginning to tail.\n    var newList = this._copyArray(true, this._list.length << 1);\n\n    this._tail = this._list.length;\n    this._head = 0;\n\n    this._list = newList;\n  } else {\n    this._tail = this._list.length;\n    this._list.length <<= 1;\n  }\n\n  this._capacityMask = (this._capacityMask << 1) | 1;\n};\n\n/**\n * Shrinks the internal list array.\n * @private\n */\nDenque.prototype._shrinkArray = function _shrinkArray() {\n  this._list.length >>>= 1;\n  this._capacityMask >>>= 1;\n};\n\n/**\n * Find the next power of 2, at least 4\n * @private\n * @param {number} num \n * @returns {number}\n */\nDenque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {\n  var log2 = Math.log(num) / Math.log(2);\n  var nextPow2 = 1 << (log2 + 1);\n\n  return Math.max(nextPow2, 4);\n}\n\nmodule.exports = Denque;\n", "import * as constants from './constants.js'\nimport { GossipSub as GossipSubClass } from './gossipsub.ts'\nimport { MessageCache } from './message-cache.js'\nimport type { GossipsubOptsSpec } from './config.js'\nimport type { DecodeRPCLimits } from './message/decodeRpc.js'\nimport type { MetricsRegister, TopicStrToLabel } from './metrics.js'\nimport type { PeerScoreParams, PeerScoreThresholds } from './score/index.js'\nimport type { MsgIdFn, MsgIdStr, FastMsgIdFn, AddrInfo, DataTransform, MsgIdToStrFn } from './types.js'\nimport type {\n  PeerId, PeerStore,\n  ComponentLogger,\n  PrivateKey,\n  PublicKey,\n  TypedEventTarget,\n  MessageStreamDirection\n} from '@libp2p/interface'\nimport type { ConnectionManager, Registrar } from '@libp2p/interface-internal'\n\n/**\n * On the producing side:\n * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n *\n * On the consuming side:\n * - Enforce the fields to be present, reject otherwise.\n * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n */\nexport const StrictSign = 'StrictSign'\n\n/**\n * On the producing side:\n * - Build messages without the signature, key, from and seqno fields.\n * - The corresponding protobuf key-value pairs are absent from the marshaled message, not just empty.\n *\n * On the consuming side:\n * - Enforce the fields to be absent, reject otherwise.\n * - Propagate only if the fields are absent, reject otherwise.\n * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n */\nexport const StrictNoSign = 'StrictNoSign'\n\nexport type SignaturePolicy = typeof StrictSign | typeof StrictNoSign\n\nexport enum TopicValidatorResult {\n  /**\n   * The message is considered valid, and it should be delivered and forwarded to the network\n   */\n  Accept = 'accept',\n  /**\n   * The message is neither delivered nor forwarded to the network\n   */\n  Ignore = 'ignore',\n  /**\n   * The message is considered invalid, and it should be rejected\n   */\n  Reject = 'reject'\n}\n\nexport interface SignedMessage {\n  type: 'signed'\n  from: PeerId\n  topic: string\n  data: Uint8Array\n  sequenceNumber: bigint\n  signature: Uint8Array\n  key: PublicKey\n}\n\nexport interface UnsignedMessage {\n  type: 'unsigned'\n  topic: string\n  data: Uint8Array\n}\n\nexport type Message = SignedMessage | UnsignedMessage\n\nexport interface PublishResult {\n  recipients: PeerId[]\n}\n\nexport interface Subscription {\n  topic: string\n  subscribe: boolean\n}\n\nexport interface SubscriptionChangeData {\n  peerId: PeerId\n  subscriptions: Subscription[]\n}\n\nexport interface TopicValidatorFn {\n  (peer: PeerId, message: Message): TopicValidatorResult | Promise<TopicValidatorResult>\n}\n\nexport const multicodec: string = constants.GossipsubIDv12\n\nexport interface GossipsubOpts extends GossipsubOptsSpec {\n  /** if dial should fallback to floodsub */\n  fallbackToFloodsub: boolean\n  /** if self-published messages should be sent to all peers */\n  floodPublish: boolean\n  /** serialize message once and send to all peers without control messages */\n  batchPublish: boolean\n  /** whether PX is enabled; this should be enabled in bootstrappers and other well connected/trusted nodes. */\n  doPX: boolean\n  /** peers with which we will maintain direct connections */\n  directPeers: AddrInfo[]\n  /**\n   * If true will not forward messages to mesh peers until reportMessageValidationResult() is called.\n   * Messages will be cached in mcache for some time after which they are evicted. Calling\n   * reportMessageValidationResult() after the message is dropped from mcache won't forward the message.\n   */\n  asyncValidation: boolean\n  /**\n   * Do not throw `PublishError.NoPeersSubscribedToTopic` error if there are no\n   * peers listening on the topic.\n   *\n   * N.B. if you sent this option to true, and you publish a message on a topic\n   * with no peers listening on that topic, no other network node will ever\n   * receive the message.\n   */\n  allowPublishToZeroTopicPeers: boolean\n  /** Do not throw `PublishError.Duplicate` if publishing duplicate messages */\n  ignoreDuplicatePublishError: boolean\n  /** For a single stream, await processing each RPC before processing the next */\n  awaitRpcHandler: boolean\n  /** For a single RPC, await processing each message before processing the next */\n  awaitRpcMessageHandler: boolean\n\n  /** message id function */\n  msgIdFn: MsgIdFn\n  /** fast message id function */\n  fastMsgIdFn: FastMsgIdFn\n  /** Uint8Array message id to string function */\n  msgIdToStrFn: MsgIdToStrFn\n  /** override the default MessageCache */\n  messageCache: MessageCache\n  /** peer score parameters */\n  scoreParams: Partial<PeerScoreParams>\n  /** peer score thresholds */\n  scoreThresholds: Partial<PeerScoreThresholds>\n  /** customize GossipsubIWantFollowupTime in order not to apply IWANT penalties */\n  gossipsubIWantFollowupMs: number\n\n  /** override constants for fine tuning */\n  prunePeers?: number\n  pruneBackoff?: number\n  unsubcribeBackoff?: number\n  graftFloodThreshold?: number\n  opportunisticGraftPeers?: number\n  opportunisticGraftTicks?: number\n  directConnectTicks?: number\n\n  dataTransform?: DataTransform\n  metricsRegister?: MetricsRegister | null\n  metricsTopicStrToLabel?: TopicStrToLabel\n\n  // Debug\n  /** Prefix tag for debug logs */\n  debugName?: string\n\n  /**\n   * Specify the maximum number of inbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxInboundStreams?: number\n\n  /**\n   * Specify the maximum number of outbound gossipsub protocol\n   * streams that are allowed to be open concurrently\n   */\n  maxOutboundStreams?: number\n\n  /**\n   * Pass true to run on limited connections - data or time-limited\n   * connections that may be closed at any time such as circuit relay\n   * connections.\n   *\n   * @default false\n   */\n  runOnLimitedConnection?: boolean\n\n  /**\n   * Specify max buffer size in bytes for OutboundStream.\n   * If full it will throw and reject sending any more data.\n   */\n  maxOutboundBufferSize?: number\n\n  /**\n   * Specify max size to skip decoding messages whose data\n   * section exceeds this size.\n   *\n   */\n  maxInboundDataLength?: number\n\n  /**\n   * If provided, only allow topics in this list\n   */\n  allowedTopics?: string[] | Set<string>\n\n  /**\n   * Limits to bound protobuf decoding\n   */\n  decodeRpcLimits?: DecodeRPCLimits\n\n  /**\n   * If true, will utilize the libp2p connection manager tagging system to prune/graft connections to peers, defaults to true\n   */\n  tagMeshPeers: boolean\n\n  /**\n   * Specify what percent of peers to send gossip to. If the percent results in\n   * a number smaller than `Dlazy`, `Dlazy` will be used instead.\n   *\n   * It should be a number between 0 and 1, with a reasonable default of 0.25\n   */\n  gossipFactor: number\n\n  /**\n   * The minimum message size in bytes to be considered for sending IDONTWANT messages\n   *\n   * @default 512\n   */\n  idontwantMinDataSize?: number\n\n  /**\n   * The maximum number of IDONTWANT messages per heartbeat per peer\n   *\n   * @default 512\n   */\n  idontwantMaxMessages?: number\n\n  /**\n   * Override the protocol registered with the registrar\n   *\n   * @default ['/floodsub/1.0.0']\n   */\n  protocols?: string[]\n\n  /**\n   * defines how signatures should be handled\n   */\n  globalSignaturePolicy?: SignaturePolicy\n\n  /**\n   * if can relay messages not subscribed\n   */\n  canRelayMessage?: boolean\n\n  /**\n   * if publish should emit to self, if subscribed\n   */\n  emitSelf?: boolean\n\n  /**\n   * handle this many incoming pubsub messages concurrently\n   */\n  messageProcessingConcurrency?: number\n}\n\nexport interface GossipsubMessage {\n  propagationSource: PeerId\n  msgId: MsgIdStr\n  msg: Message\n}\n\nexport interface MeshPeer {\n  peerId: string\n  topic: string\n  direction: MessageStreamDirection\n}\n\nexport interface GossipSubEvents {\n  'subscription-change': CustomEvent<SubscriptionChangeData>\n  message: CustomEvent<Message>\n  'gossipsub:heartbeat': CustomEvent\n  'gossipsub:message': CustomEvent<GossipsubMessage>\n  'gossipsub:graft': CustomEvent<MeshPeer>\n  'gossipsub:prune': CustomEvent<MeshPeer>\n}\n\nexport interface GossipSubComponents {\n  privateKey: PrivateKey\n  peerId: PeerId\n  peerStore: PeerStore\n  registrar: Registrar\n  connectionManager: ConnectionManager\n  logger: ComponentLogger\n}\n\nexport interface GossipSub extends TypedEventTarget<GossipSubEvents> {\n  /**\n   * The global signature policy controls whether or not we sill send and receive\n   * signed or unsigned messages.\n   *\n   * Signed messages prevent spoofing message senders and should be preferred to\n   * using unsigned messages.\n   */\n  globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n\n  /**\n   * A list of multicodecs that contain the pubsub protocol name.\n   */\n  protocols: string[]\n\n  /**\n   * Pubsub routers support message validators per topic, which will validate the message\n   * before its propagations. They are stored in a map where keys are the topic name and\n   * values are the validators.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const validateMessage = (msgTopic, msg) => {\n   *   const input = uint8ArrayToString(msg.data)\n   *   const validInputs = ['a', 'b', 'c']\n   *\n   *   if (!validInputs.includes(input)) {\n   *     throw new Error('no valid input received')\n   *   }\n   * }\n   * libp2p.pubsub.topicValidators.set(topic, validateMessage)\n   * ```\n   */\n  topicValidators: Map<string, TopicValidatorFn>\n\n  getPeers(): PeerId[]\n\n  /**\n   * Gets a list of topics the node is subscribed to.\n   *\n   * ```TypeScript\n   * const topics = libp2p.pubsub.getTopics()\n   * ```\n   */\n  getTopics(): string[]\n\n  /**\n   * Subscribes to a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   if (msg.topic === topic) {\n   *     // msg.data - pubsub data received\n   *   }\n   * }\n   *\n   * libp2p.pubsub.addEventListener('message', handler)\n   * libp2p.pubsub.subscribe(topic)\n   * ```\n   */\n  subscribe(topic: string): void\n\n  /**\n   * Unsubscribes from a pubsub topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const handler = (msg) => {\n   *   // msg.data - pubsub data received\n   * }\n   *\n   * libp2p.pubsub.removeEventListener(topic handler)\n   * libp2p.pubsub.unsubscribe(topic)\n   * ```\n   */\n  unsubscribe(topic: string): void\n\n  /**\n   * Gets a list of the PeerIds that are subscribed to one topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerIds = libp2p.pubsub.getSubscribers(topic)\n   * ```\n   */\n  getSubscribers(topic: string): PeerId[]\n\n  /**\n   * Publishes messages to the given topic.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const topic = 'topic'\n   * const data = uint8ArrayFromString('data')\n   *\n   * await libp2p.pubsub.publish(topic, data)\n   * ```\n   */\n  publish(topic: string, data?: Uint8Array): Promise<PublishResult>\n}\n\nexport function gossipsub (\n  init: Partial<GossipsubOpts> = {}\n): (components: GossipSubComponents) => GossipSub {\n  return (components: GossipSubComponents) => new GossipSubClass(components, init)\n}\n", "export const second = 1000\nexport const minute = 60 * second\n\n// Protocol identifiers\n\nexport const FloodsubID = '/floodsub/1.0.0'\n\n/**\n * The protocol ID for version 1.0.0 of the Gossipsub protocol\n * It is advertised along with GossipsubIDv11 for backwards compatability\n */\nexport const GossipsubIDv10 = '/meshsub/1.0.0'\n\n/**\n * The protocol ID for version 1.1.0 of the Gossipsub protocol\n * See the spec for details about how v1.1.0 compares to v1.0.0:\n * https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md\n */\nexport const GossipsubIDv11 = '/meshsub/1.1.0'\n\n/**\n * The protocol ID for version 1.2.0 of the Gossipsub protocol\n * See the spec for details about how v1.2.0 compares to v1.1.0:\n * https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.2.md\n */\nexport const GossipsubIDv12 = '/meshsub/1.2.0'\n\n// Overlay parameters\n\n/**\n * GossipsubD sets the optimal degree for a Gossipsub topic mesh. For example, if GossipsubD == 6,\n * each peer will want to have about six peers in their mesh for each topic they're subscribed to.\n * GossipsubD should be set somewhere between GossipsubDlo and GossipsubDhi.\n */\nexport const GossipsubD = 6\n\n/**\n * GossipsubDlo sets the lower bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have fewer than GossipsubDlo peers, we will attempt to graft some more into the mesh at\n * the next heartbeat.\n */\nexport const GossipsubDlo = 4\n\n/**\n * GossipsubDhi sets the upper bound on the number of peers we keep in a Gossipsub topic mesh.\n * If we have more than GossipsubDhi peers, we will select some to prune from the mesh at the next heartbeat.\n */\nexport const GossipsubDhi = 12\n\n/**\n * GossipsubDscore affects how peers are selected when pruning a mesh due to over subscription.\n * At least GossipsubDscore of the retained peers will be high-scoring, while the remainder are\n * chosen randomly.\n */\nexport const GossipsubDscore = 4\n\n/**\n * GossipsubDout sets the quota for the number of outbound connections to maintain in a topic mesh.\n * When the mesh is pruned due to over subscription, we make sure that we have outbound connections\n * to at least GossipsubDout of the survivor peers. This prevents sybil attackers from overwhelming\n * our mesh with incoming connections.\n *\n * GossipsubDout must be set below GossipsubDlo, and must not exceed GossipsubD / 2.\n */\nexport const GossipsubDout = 2\n\n// Gossip parameters\n\n/**\n * GossipsubHistoryLength controls the size of the message cache used for gossip.\n * The message cache will remember messages for GossipsubHistoryLength heartbeats.\n */\nexport const GossipsubHistoryLength = 5\n\n/**\n * GossipsubHistoryGossip controls how many cached message ids we will advertise in\n * IHAVE gossip messages. When asked for our seen message IDs, we will return\n * only those from the most recent GossipsubHistoryGossip heartbeats. The slack between\n * GossipsubHistoryGossip and GossipsubHistoryLength allows us to avoid advertising messages\n * that will be expired by the time they're requested.\n *\n * GossipsubHistoryGossip must be less than or equal to GossipsubHistoryLength to\n * avoid a runtime panic.\n */\nexport const GossipsubHistoryGossip = 3\n\n/**\n * GossipsubDlazy affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to at least GossipsubDlazy peers outside our mesh. The actual\n * number may be more, depending on GossipsubGossipFactor and how many peers we're\n * connected to.\n */\nexport const GossipsubDlazy = 6\n\n/**\n * GossipsubGossipFactor affects how many peers we will emit gossip to at each heartbeat.\n * We will send gossip to GossipsubGossipFactor * (total number of non-mesh peers), or\n * GossipsubDlazy, whichever is greater.\n */\nexport const GossipsubGossipFactor = 0.25\n\n/**\n * GossipsubGossipRetransmission controls how many times we will allow a peer to request\n * the same message id through IWANT gossip before we start ignoring them. This is designed\n * to prevent peers from spamming us with requests and wasting our resources.\n */\nexport const GossipsubGossipRetransmission = 3\n\n// Heartbeat interval\n\n/**\n * GossipsubHeartbeatInitialDelay is the short delay before the heartbeat timer begins\n * after the router is initialized.\n */\nexport const GossipsubHeartbeatInitialDelay = 100\n\n/**\n * GossipsubHeartbeatInterval controls the time between heartbeats.\n */\nexport const GossipsubHeartbeatInterval = second\n\n/**\n * GossipsubFanoutTTL controls how long we keep track of the fanout state. If it's been\n * GossipsubFanoutTTL since we've published to a topic that we're not subscribed to,\n * we'll delete the fanout map for that topic.\n */\nexport const GossipsubFanoutTTL = minute\n\n/**\n * GossipsubPrunePeers controls the number of peers to include in prune Peer eXchange.\n * When we prune a peer that's eligible for PX (has a good score, etc), we will try to\n * send them signed peer records for up to GossipsubPrunePeers other peers that we\n * know of.\n */\nexport const GossipsubPrunePeers = 16\n\n/**\n * GossipsubPruneBackoff controls the backoff time for pruned peers. This is how long\n * a peer must wait before attempting to graft into our mesh again after being pruned.\n * When pruning a peer, we send them our value of GossipsubPruneBackoff so they know\n * the minimum time to wait. Peers running older versions may not send a backoff time,\n * so if we receive a prune message without one, we will wait at least GossipsubPruneBackoff\n * before attempting to re-graft.\n */\nexport const GossipsubPruneBackoff = minute\n\n/**\n * Backoff to use when unsuscribing from a topic. Should not resubscribe to this topic before it expired.\n */\nexport const GossipsubUnsubscribeBackoff = 10 * second\n\n/**\n * GossipsubPruneBackoffTicks is the number of heartbeat ticks for attempting to prune expired\n * backoff timers.\n */\nexport const GossipsubPruneBackoffTicks = 15\n\n/**\n * GossipsubConnectors controls the number of active connection attempts for peers obtained through PX.\n */\nexport const GossipsubConnectors = 8\n\n/**\n * GossipsubMaxPendingConnections sets the maximum number of pending connections for peers attempted through px.\n */\nexport const GossipsubMaxPendingConnections = 128\n\n/**\n * GossipsubConnectionTimeout controls the timeout for connection attempts.\n */\nexport const GossipsubConnectionTimeout = 30 * second\n\n/**\n * GossipsubDirectConnectTicks is the number of heartbeat ticks for attempting to reconnect direct peers\n * that are not currently connected.\n */\nexport const GossipsubDirectConnectTicks = 300\n\n/**\n * GossipsubDirectConnectInitialDelay is the initial delay before opening connections to direct peers\n */\nexport const GossipsubDirectConnectInitialDelay = second\n\n/**\n * GossipsubOpportunisticGraftTicks is the number of heartbeat ticks for attempting to improve the mesh\n * with opportunistic grafting. Every GossipsubOpportunisticGraftTicks we will attempt to select some\n * high-scoring mesh peers to replace lower-scoring ones, if the median score of our mesh peers falls\n * below a threshold\n */\nexport const GossipsubOpportunisticGraftTicks = 60\n\n/**\n * GossipsubOpportunisticGraftPeers is the number of peers to opportunistically graft.\n */\nexport const GossipsubOpportunisticGraftPeers = 2\n\n/**\n * If a GRAFT comes before GossipsubGraftFloodThreshold has elapsed since the last PRUNE,\n * then there is an extra score penalty applied to the peer through P7.\n */\nexport const GossipsubGraftFloodThreshold = 10 * second\n\n/**\n * GossipsubMaxIHaveLength is the maximum number of messages to include in an IHAVE message.\n * Also controls the maximum number of IHAVE ids we will accept and request with IWANT from a\n * peer within a heartbeat, to protect from IHAVE floods. You should adjust this value from the\n * default if your system is pushing more than 5000 messages in GossipsubHistoryGossip heartbeats;\n * with the defaults this is 1666 messages/s.\n */\nexport const GossipsubMaxIHaveLength = 5000\n\n/**\n * GossipsubMaxIHaveMessages is the maximum number of IHAVE messages to accept from a peer within a heartbeat.\n */\nexport const GossipsubMaxIHaveMessages = 10\n\n/**\n * Time to wait for a message requested through IWANT following an IHAVE advertisement.\n * If the message is not received within this window, a broken promise is declared and\n * the router may apply bahavioural penalties.\n */\nexport const GossipsubIWantFollowupTime = 3 * second\n\n/**\n * Time in milliseconds to keep message ids in the seen cache\n */\nexport const GossipsubSeenTTL = 2 * minute\n\nexport const TimeCacheDuration = 120 * 1000\n\nexport const ERR_TOPIC_VALIDATOR_REJECT = 'ERR_TOPIC_VALIDATOR_REJECT'\nexport const ERR_TOPIC_VALIDATOR_IGNORE = 'ERR_TOPIC_VALIDATOR_IGNORE'\n\n/**\n * If peer score is better than this, we accept messages from this peer\n * within ACCEPT_FROM_WHITELIST_DURATION_MS from the last time computing score.\n */\nexport const ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE = 0\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept up to this\n * number of messages from that peer.\n */\nexport const ACCEPT_FROM_WHITELIST_MAX_MESSAGES = 128\n\n/**\n * If peer score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE, accept messages from\n * this peer up to this time duration.\n */\nexport const ACCEPT_FROM_WHITELIST_DURATION_MS = 1000\n\n/**\n * The default MeshMessageDeliveriesWindow to be used in metrics.\n */\nexport const DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS = 1000\n\n/** Wait for 1 more heartbeats before clearing a backoff */\nexport const BACKOFF_SLACK = 1\n\nexport const GossipsubIdontwantMinDataSize = 512\nexport const GossipsubIdontwantMaxMessages = 512\n", "/**\n * When this error is thrown it means an operation was aborted,\n * usually in response to the `abort` event being emitted by an\n * AbortSignal.\n */\nexport class AbortError extends Error {\n  static name = 'AbortError'\n\n  constructor (message: string = 'The operation was aborted') {\n    super(message)\n    this.name = 'AbortError'\n  }\n}\n\n/**\n * Thrown when a remote Peer ID does not match the expected one\n */\nexport class UnexpectedPeerError extends Error {\n  static name = 'UnexpectedPeerError'\n\n  constructor (message = 'Unexpected Peer') {\n    super(message)\n    this.name = 'UnexpectedPeerError'\n  }\n}\n\n/**\n * Thrown when a crypto exchange fails\n */\nexport class InvalidCryptoExchangeError extends Error {\n  static name = 'InvalidCryptoExchangeError'\n\n  constructor (message = 'Invalid crypto exchange') {\n    super(message)\n    this.name = 'InvalidCryptoExchangeError'\n  }\n}\n\n/**\n * Thrown when invalid parameters are passed to a function or method call\n */\nexport class InvalidParametersError extends Error {\n  static name = 'InvalidParametersError'\n\n  constructor (message = 'Invalid parameters') {\n    super(message)\n    this.name = 'InvalidParametersError'\n  }\n}\n\n/**\n * Thrown when a public key is invalid\n */\nexport class InvalidPublicKeyError extends Error {\n  static name = 'InvalidPublicKeyError'\n\n  constructor (message = 'Invalid public key') {\n    super(message)\n    this.name = 'InvalidPublicKeyError'\n  }\n}\n\n/**\n * Thrown when a private key is invalid\n */\nexport class InvalidPrivateKeyError extends Error {\n  static name = 'InvalidPrivateKeyError'\n\n  constructor (message = 'Invalid private key') {\n    super(message)\n    this.name = 'InvalidPrivateKeyError'\n  }\n}\n\n/**\n * Thrown when a operation is unsupported\n */\nexport class UnsupportedOperationError extends Error {\n  static name = 'UnsupportedOperationError'\n\n  constructor (message = 'Unsupported operation') {\n    super(message)\n    this.name = 'UnsupportedOperationError'\n  }\n}\n\n/**\n * Thrown when a connection is closing\n */\nexport class ConnectionClosingError extends Error {\n  static name = 'ConnectionClosingError'\n\n  constructor (message = 'The connection is closing') {\n    super(message)\n    this.name = 'ConnectionClosingError'\n  }\n}\n\n/**\n * Thrown when a connection is closed\n */\nexport class ConnectionClosedError extends Error {\n  static name = 'ConnectionClosedError'\n\n  constructor (message = 'The connection is closed') {\n    super(message)\n    this.name = 'ConnectionClosedError'\n  }\n}\n\n/**\n * Thrown when a connection fails\n */\nexport class ConnectionFailedError extends Error {\n  static name = 'ConnectionFailedError'\n\n  constructor (message = 'Connection failed') {\n    super(message)\n    this.name = 'ConnectionFailedError'\n  }\n}\n\n/**\n * Thrown when the muxer is closed and an attempt to open a stream occurs\n */\nexport class MuxerClosedError extends Error {\n  static name = 'MuxerClosedError'\n\n  constructor (message = 'The muxer is closed') {\n    super(message)\n    this.name = 'MuxerClosedError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is reset by the remote muxer\n */\nexport class StreamResetError extends Error {\n  static name = 'StreamResetError'\n\n  constructor (message = 'The stream has been reset') {\n    super(message)\n    this.name = 'StreamResetError'\n  }\n}\n\n/**\n * Thrown when a protocol stream is aborted locally\n */\nexport class StreamAbortedError extends Error {\n  static name = 'StreamAbortedError'\n\n  constructor (message = 'The stream has been aborted') {\n    super(message)\n    this.name = 'StreamAbortedError'\n  }\n}\n\n/**\n * Thrown when a stream is in an invalid state\n */\nexport class StreamStateError extends Error {\n  static name = 'StreamStateError'\n\n  constructor (message = 'The stream is in an invalid state') {\n    super(message)\n    this.name = 'StreamStateError'\n  }\n}\n\n/**\n * Thrown when a stream buffer is full\n */\nexport class StreamBufferError extends Error {\n  static name = 'StreamBufferError'\n\n  constructor (message = 'The stream buffer was full') {\n    super(message)\n    this.name = 'StreamBufferError'\n  }\n}\n\n/**\n * Thrown when a value could not be found\n */\nexport class NotFoundError extends Error {\n  static name = 'NotFoundError'\n\n  constructor (message = 'Not found') {\n    super(message)\n    this.name = 'NotFoundError'\n  }\n}\n\n/**\n * Thrown when an invalid peer ID is encountered\n */\nexport class InvalidPeerIdError extends Error {\n  static name = 'InvalidPeerIdError'\n\n  constructor (message = 'Invalid PeerID') {\n    super(message)\n    this.name = 'InvalidPeerIdError'\n  }\n}\n\n/**\n * Thrown when an invalid multiaddr is encountered\n */\nexport class InvalidMultiaddrError extends Error {\n  static name = 'InvalidMultiaddrError'\n\n  constructor (message = 'Invalid multiaddr') {\n    super(message)\n    this.name = 'InvalidMultiaddrError'\n  }\n}\n\n/**\n * Thrown when an invalid CID is encountered\n */\nexport class InvalidCIDError extends Error {\n  static name = 'InvalidCIDError'\n\n  constructor (message = 'Invalid CID') {\n    super(message)\n    this.name = 'InvalidCIDError'\n  }\n}\n\n/**\n * Thrown when an invalid multihash is encountered\n */\nexport class InvalidMultihashError extends Error {\n  static name = 'InvalidMultihashError'\n\n  constructor (message = 'Invalid Multihash') {\n    super(message)\n    this.name = 'InvalidMultihashError'\n  }\n}\n\n/**\n * Thrown when a protocol is not supported\n */\nexport class UnsupportedProtocolError extends Error {\n  static name = 'UnsupportedProtocolError'\n\n  constructor (message = 'Unsupported protocol error') {\n    super(message)\n    this.name = 'UnsupportedProtocolError'\n  }\n}\n\n/**\n * An invalid or malformed message was encountered during a protocol exchange\n */\nexport class InvalidMessageError extends Error {\n  static name = 'InvalidMessageError'\n\n  constructor (message = 'Invalid message') {\n    super(message)\n    this.name = 'InvalidMessageError'\n  }\n}\n\n/**\n * Thrown when a remote peer sends a structurally valid message that does not\n * comply with the protocol\n */\nexport class ProtocolError extends Error {\n  static name = 'ProtocolError'\n\n  constructor (message = 'Protocol error') {\n    super(message)\n    this.name = 'ProtocolError'\n  }\n}\n\n/**\n * Throw when an operation times out\n */\nexport class TimeoutError extends Error {\n  static name = 'TimeoutError'\n\n  constructor (message = 'Timed out') {\n    super(message)\n    this.name = 'TimeoutError'\n  }\n}\n\n/**\n * Thrown when a startable component is interacted with but it has not been\n * started yet\n */\nexport class NotStartedError extends Error {\n  static name = 'NotStartedError'\n\n  constructor (message = 'Not started') {\n    super(message)\n    this.name = 'NotStartedError'\n  }\n}\n\n/**\n * Thrown when a component is started that has already been started\n */\nexport class AlreadyStartedError extends Error {\n  static name = 'AlreadyStartedError'\n\n  constructor (message = 'Already started') {\n    super(message)\n    this.name = 'AlreadyStartedError'\n  }\n}\n\n/**\n * Thrown when dialing an address failed\n */\nexport class DialError extends Error {\n  static name = 'DialError'\n\n  constructor (message = 'Dial error') {\n    super(message)\n    this.name = 'DialError'\n  }\n}\n\n/**\n * Thrown when listening on an address failed\n */\nexport class ListenError extends Error {\n  static name = 'ListenError'\n\n  constructor (message = 'Listen error') {\n    super(message)\n    this.name = 'ListenError'\n  }\n}\n\n/**\n * This error is thrown when a limited connection is encountered, i.e. if the\n * user tried to open a stream on a connection for a protocol that is not\n * configured to run over limited connections.\n */\nexport class LimitedConnectionError extends Error {\n  static name = 'LimitedConnectionError'\n\n  constructor (message = 'Limited connection') {\n    super(message)\n    this.name = 'LimitedConnectionError'\n  }\n}\n\n/**\n * This error is thrown where there are too many inbound protocols streams open\n */\nexport class TooManyInboundProtocolStreamsError extends Error {\n  static name = 'TooManyInboundProtocolStreamsError'\n\n  constructor (message = 'Too many inbound protocol streams') {\n    super(message)\n    this.name = 'TooManyInboundProtocolStreamsError'\n  }\n}\n\n/**\n * This error is thrown where there are too many outbound protocols streams open\n */\nexport class TooManyOutboundProtocolStreamsError extends Error {\n  static name = 'TooManyOutboundProtocolStreamsError'\n\n  constructor (message = 'Too many outbound protocol streams') {\n    super(message)\n    this.name = 'TooManyOutboundProtocolStreamsError'\n  }\n}\n\n/**\n * Thrown when an attempt to operate on an unsupported key was made\n */\nexport class UnsupportedKeyTypeError extends Error {\n  static name = 'UnsupportedKeyTypeError'\n\n  constructor (message = 'Unsupported key type') {\n    super(message)\n    this.name = 'UnsupportedKeyTypeError'\n  }\n}\n\n/**\n * Thrown when an operation has not been implemented\n */\nexport class NotImplementedError extends Error {\n  static name = 'NotImplementedError'\n\n  constructor (message = 'Not implemented') {\n    super(message)\n    this.name = 'NotImplementedError'\n  }\n}\n", "import type { Ed25519PublicKey, KeyType, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { CID } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nexport type PeerIdType = KeyType | string\n\n/**\n * A PeerId generated from an RSA public key - it is a base58btc encoded sha-256\n * hash of the public key.\n *\n * RSA public keys are too large to pass around freely, instead Ed25519 or\n * secp256k1 should be preferred as they can embed their public key in the\n * PeerId itself.\n *\n * @deprecated Ed25519 or secp256k1 keys are preferred to RSA\n */\nexport interface RSAPeerId {\n  readonly type: 'RSA'\n\n  /**\n   * RSA public keys are too large to embed in the multihash commonly used to\n   * refer to peers, so this will only be defined if the public key has\n   * previously been found through a routing query or during normal protocol\n   * operations\n   */\n  readonly publicKey?: RSAPublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the SHA2-256 hash of the public\n   * key\n   */\n  toMultihash(): MultihashDigest<0x12>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x12, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Ed25519PeerId {\n  readonly type: 'Ed25519'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Ed25519PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface Secp256k1PeerId {\n  readonly type: 'secp256k1'\n\n  /**\n   * This will always be defined as the public key is embedded in the multihash\n   * of this PeerId\n   */\n  readonly publicKey: Secp256k1PublicKey\n\n  /**\n   * Returns the multihash from `toMultihash()` as a base58btc encoded string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the protobuf-encoded public key\n   * encoded as an identity hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the libp2p key code and the same multihash as\n   * `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x72, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\nexport interface URLPeerId {\n  readonly type: 'url'\n\n  /**\n   * This will always be undefined as URL Peers do not have public keys\n   */\n  readonly publicKey: undefined\n\n  /**\n   * Returns CID from `toCID()` encoded as a base36 string\n   */\n  toString(): string\n\n  /**\n   * Returns a multihash, the digest of which is the URL encoded as an identity\n   * hash\n   */\n  toMultihash(): MultihashDigest<0x0>\n\n  /**\n   * Returns a CID with the Transport IPFS Gateway HTTP code and the same\n   * multihash as `toMultihash()`\n   */\n  toCID(): CID<Uint8Array, 0x0920, 0x0, 1>\n\n  /**\n   * Returns true if the passed argument is equivalent to this PeerId\n   */\n  equals(other?: any): boolean\n}\n\n/**\n * This is a union of all known PeerId types - use the `.type` field to\n * disambiguate them\n */\nexport type PeerId = RSAPeerId | Ed25519PeerId | Secp256k1PeerId | URLPeerId\n\n/**\n * All PeerId implementations must use this symbol as the name of a property\n * with a boolean `true` value\n */\nexport const peerIdSymbol = Symbol.for('@libp2p/peer-id')\n\n/**\n * Returns true if the passed argument is a PeerId implementation\n */\nexport function isPeerId (other?: any): other is PeerId {\n  return Boolean(other?.[peerIdSymbol])\n}\n", "/**\n * @packageDocumentation\n *\n * Adds types to the EventTarget class.\n *\n * Hopefully this won't be necessary\n * forever:\n *\n * - https://github.com/microsoft/TypeScript/issues/28357\n * - https://github.com/microsoft/TypeScript/issues/43477\n * - https://github.com/microsoft/TypeScript/issues/299\n * - https://www.npmjs.com/package/typed-events\n * - https://www.npmjs.com/package/typed-event-emitter\n * - https://www.npmjs.com/package/typed-event-target\n * - etc\n *\n * In addition to types, a `safeDispatchEvent` method is available which\n * prevents dispatching events that aren't in the event map, and a\n * `listenerCount` method which reports the number of listeners that are\n * currently registered for a given event.\n *\n * @example\n *\n * ```ts\n * import { TypedEventEmitter } from 'main-event'\n * import type { TypedEventTarget } from 'main-event'\n *\n * interface EventTypes {\n *   'test': CustomEvent<string>\n * }\n *\n * const target = new TypedEventEmitter<EventTypes>()\n *\n * // it's a regular EventTarget\n * console.info(target instanceof EventTarget) // true\n *\n * // register listeners normally\n * target.addEventListener('test', (evt) => {\n *   // evt is CustomEvent<string>\n * })\n *\n * // @ts-expect-error 'derp' is not in the event map\n * target.addEventListener('derp', () => {})\n *\n * // use normal dispatchEvent method\n * target.dispatchEvent(new CustomEvent('test', {\n *   detail: 'hello'\n * }))\n *\n * // use type safe dispatch method\n * target.safeDispatchEvent('test', {\n *   detail: 'world'\n * })\n *\n * // report listener count\n * console.info(target.listenerCount('test')) // 0\n *\n * // event emitters can be used purely as interfaces too\n * function acceptTarget (target: TypedEventTarget<EventTypes>) {\n *   // ...\n * }\n * ```\n */\n\nimport { setMaxListeners } from './events.js'\n\nexport interface EventCallback<EventType> { (evt: EventType): void }\nexport interface EventObject<EventType> { handleEvent: EventCallback<EventType> }\nexport type EventHandler<EventType> = EventCallback<EventType> | EventObject<EventType>\n\ninterface Listener {\n  once: boolean\n  callback: any\n}\n\n/**\n *\n */\nexport interface TypedEventTarget <EventMap extends Record<string, any>> extends EventTarget {\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n\n  listenerCount (type: string): number\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail?: CustomEventInit<Detail>): boolean\n}\n\n/**\n * An implementation of a typed event target\n */\nexport class TypedEventEmitter<EventMap extends Record<string, any>> extends EventTarget implements TypedEventTarget<EventMap> {\n  readonly #listeners = new Map<any, Listener[]>()\n\n  constructor () {\n    super()\n\n    // silence MaxListenersExceededWarning warning on Node.js, this is a red\n    // herring almost all of the time\n    setMaxListeners(Infinity, this)\n  }\n\n  listenerCount (type: string): number {\n    const listeners = this.#listeners.get(type)\n\n    if (listeners == null) {\n      return 0\n    }\n\n    return listeners.length\n  }\n\n  addEventListener<K extends keyof EventMap>(type: K, listener: EventHandler<EventMap[K]> | null, options?: boolean | AddEventListenerOptions): void\n  addEventListener (type: string, listener: EventHandler<Event>, options?: boolean | AddEventListenerOptions): void {\n    super.addEventListener(type, listener, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      list = []\n      this.#listeners.set(type, list)\n    }\n\n    list.push({\n      callback: listener,\n      once: (options !== true && options !== false && options?.once) ?? false\n    })\n  }\n\n  removeEventListener<K extends keyof EventMap>(type: K, listener?: EventHandler<EventMap[K]> | null, options?: boolean | EventListenerOptions): void\n  removeEventListener (type: string, listener?: EventHandler<Event>, options?: boolean | EventListenerOptions): void {\n    super.removeEventListener(type.toString(), listener ?? null, options)\n\n    let list = this.#listeners.get(type)\n\n    if (list == null) {\n      return\n    }\n\n    list = list.filter(({ callback }) => callback !== listener)\n    this.#listeners.set(type, list)\n  }\n\n  dispatchEvent (event: Event): boolean {\n    const result = super.dispatchEvent(event)\n\n    let list = this.#listeners.get(event.type)\n\n    if (list == null) {\n      return result\n    }\n\n    list = list.filter(({ once }) => !once)\n    this.#listeners.set(event.type, list)\n\n    return result\n  }\n\n  safeDispatchEvent<Detail>(type: keyof EventMap, detail: CustomEventInit<Detail> = {}): boolean {\n    return this.dispatchEvent(new CustomEvent<Detail>(type as string, detail))\n  }\n}\n\nexport { setMaxListeners }\n", "/**\n * @packageDocumentation\n *\n * Exports a `Libp2p` type for modules to use as a type argument.\n *\n * @example\n *\n * ```typescript\n * import type { Libp2p } from '@libp2p/interface'\n *\n * function doSomethingWithLibp2p (node: Libp2p) {\n *   // ...\n * }\n * ```\n */\n\nimport type { Connection, NewStreamOptions } from './connection.js'\nimport type { ContentRouting } from './content-routing.js'\nimport type { Ed25519PublicKey, PublicKey, RSAPublicKey, Secp256k1PublicKey } from './keys.js'\nimport type { Metrics } from './metrics.js'\nimport type { Ed25519PeerId, PeerId, RSAPeerId, Secp256k1PeerId, URLPeerId } from './peer-id.js'\nimport type { PeerInfo } from './peer-info.js'\nimport type { PeerRouting } from './peer-routing.js'\nimport type { Address, Peer, PeerStore } from './peer-store.js'\nimport type { Startable } from './startable.js'\nimport type { StreamHandler, StreamHandlerOptions, StreamMiddleware } from './stream-handler.js'\nimport type { Stream } from './stream.js'\nimport type { Topology } from './topology.js'\nimport type { Listener, OutboundConnectionUpgradeEvents } from './transport.js'\nimport type { DNS } from '@multiformats/dns'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { TypedEventTarget } from 'main-event'\nimport type { ProgressOptions, ProgressEvent } from 'progress-events'\n\n/**\n * Used by the connection manager to sort addresses into order before dialling\n */\nexport interface AddressSorter {\n  (a: Address, b: Address): -1 | 0 | 1\n}\n\n/**\n * Event detail emitted when peer data changes\n */\nexport interface PeerUpdate {\n  peer: Peer\n  previous?: Peer\n}\n\n/**\n * Peer data signed by the remote Peer's public key\n */\nexport interface SignedPeerRecord {\n  addresses: Multiaddr[]\n  seq: bigint\n}\n\n/**\n * A certificate that can be used to secure connections\n */\nexport interface TLSCertificate {\n  /**\n   * The private key that corresponds to the certificate in PEM format\n   */\n  key: string\n\n  /**\n   * The certificate chain in PEM format\n   */\n  cert: string\n}\n\n/**\n * Data returned from a successful identify response\n */\nexport interface IdentifyResult {\n  /**\n   * The remote Peer's PeerId\n   */\n  peerId: PeerId\n\n  /**\n   * The unsigned addresses they are listening on. Note - any multiaddrs present\n   * in the signed peer record should be preferred to the value here.\n   */\n  listenAddrs: Multiaddr[]\n\n  /**\n   * The protocols the remote peer supports\n   */\n  protocols: string[]\n\n  /**\n   * The remote protocol version\n   */\n  protocolVersion?: string\n\n  /**\n   * The remote agent version\n   */\n  agentVersion?: string\n\n  /**\n   * The public key part of the remote PeerId - this is only useful for older\n   * RSA-based PeerIds, the more modern Ed25519 and secp256k1 types have the\n   * public key embedded in them\n   */\n  publicKey?: Uint8Array\n\n  /**\n   * If set this is the address that the remote peer saw the identify request\n   * originate from\n   */\n  observedAddr?: Multiaddr\n\n  /**\n   * If sent by the remote peer this is the deserialized signed peer record\n   */\n  signedPeerRecord?: SignedPeerRecord\n\n  /**\n   * The connection that the identify protocol ran over\n   */\n  connection: Connection\n}\n\n/**\n * Logger component for libp2p\n */\nexport interface Logger {\n  /**\n   * Log a message\n   */\n  (formatter: any, ...args: any[]): void\n\n  /**\n   * Log an error message\n   */\n  error(formatter: any, ...args: any[]): void\n\n  /**\n   * Log a trace message\n   */\n  trace(formatter: any, ...args: any[]): void\n\n  /**\n   * `true` if this logger is enabled\n   */\n  enabled: boolean\n\n  /**\n   * Create a logger scoped below this one\n   *\n   * @example\n   *\n   * ```ts\n   * import { defaultLogger } from '@libp2p/logger'\n   *\n   * const log = defaultLogger().forComponent('foo')\n   *\n   * log('hello')\n   * // foo hello\n   *\n   * const subLog = log.newScope('bar')\n   *\n   * subLog('hello')\n   * // foo:bar hello\n   * ```\n   */\n  newScope(name: string): Logger\n}\n\n/**\n * Peer logger component for libp2p. This can be used to create loggers that are\n * scoped to individual system components or services.\n *\n * To see logs, run your app with `DEBUG` set as an env var or for browsers, in\n * `localStorage`:\n *\n * ```console\n * $ DEBUG=libp2p* node index.js\n *  libp2p:my-service hello +0ms\n * ```\n */\nexport interface ComponentLogger {\n  /**\n   * Returns a logger for the specified component.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { ComponentLogger, Logger } from '@libp2p/interface'\n   *\n   * interface MyServiceComponents {\n   *   logger: ComponentLogger\n   * }\n   *\n   * class MyService {\n   *   private readonly log: Logger\n   *\n   *   constructor (components) {\n   *     this.log = components.logger.forComponent('libp2p:my-service')\n   *\n   *     this.log('hello')\n   *     // logs:\n   *     // libp2p:my-service hello +0ms\n   *   }\n   * }\n   * ```\n   */\n  forComponent(name: string): Logger\n}\n\nexport interface MultiaddrResolveOptions extends AbortOptions, LoggerOptions {\n  /**\n   * An optional DNS resolver\n   */\n  dns?: DNS\n}\n\n/**\n * `MultiaddrResolver`s perform resolution of multiaddr components that require\n * translation by external systems (for example DNSADDR to TXT records).\n */\nexport interface MultiaddrResolver {\n  /**\n   * Returns true if this resolver can resolve components of this multiaddr\n   */\n  canResolve (address: Multiaddr): boolean\n\n  /**\n   * Returns one or more multiaddrs with components resolved to other values\n   */\n  resolve (address: Multiaddr, options: MultiaddrResolveOptions): Promise<Multiaddr[]>\n}\n\n/**\n * Once you have a libp2p instance, you can listen to several events it emits,\n * so that you can be notified of relevant network events.\n *\n * Event names are `noun:verb` so the first part is the name of the object\n * being acted on and the second is the action.\n */\nexport interface Libp2pEvents<T extends ServiceMap = ServiceMap> {\n  /**\n   * This event is dispatched when a new network peer is discovered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:discovery', (event) => {\n   *    const peerInfo = event.detail\n   *    // ...\n   * })\n   * ```\n   */\n  'peer:discovery': CustomEvent<PeerInfo>\n\n  /**\n   * This event will be triggered any time a new peer connects.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:connect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:connect': CustomEvent<PeerId>\n\n  /**\n   * This event will be triggered any time we are disconnected from another\n   * peer, regardless of the circumstances of that disconnection. If we happen\n   * to have multiple connections to a peer, this event will **only** be\n   * triggered when the last connection is closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:disconnect', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:disconnect': CustomEvent<PeerId>\n\n  /**\n   * When a peer tagged with `keep-alive` disconnects, we will make multiple\n   * attempts to reconnect to it with a backoff factor (see the connection\n   * manager settings for details). If these all fail, the `keep-alive` tag will\n   * be removed and this event will be emitted.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:reconnect-failure', (event) => {\n   *   const peerId = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:reconnect-failure': CustomEvent<PeerId>\n\n  /**\n   * This event is dispatched after a remote peer has successfully responded to\n   * the identify protocol. Note that for this to be emitted, both peers must\n   * have an identify service configured.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('peer:identify', (event) => {\n   *   const identifyResult = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'peer:identify': CustomEvent<IdentifyResult>\n\n  /**\n   * This event is dispatched when the peer store data for a peer has been\n   * updated - e.g. their multiaddrs, protocols etc have changed.\n   *\n   * If they were previously known to this node, the old peer data will be\n   * set in the `previous` field.\n   *\n   * This may be in response to the identify protocol running, a manual\n   * update or some other event.\n   */\n  'peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when the current node's peer record changes -\n   * for example a transport started listening on a new address or a new\n   * protocol handler was registered.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('self:peer:update', (event) => {\n   *   const { peer } = event.detail\n   *   // ...\n   * })\n   * ```\n   */\n  'self:peer:update': CustomEvent<PeerUpdate>\n\n  /**\n   * This event is dispatched when a transport begins listening on a new address\n   */\n  'transport:listening': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when a transport stops listening on an address\n   */\n  'transport:close': CustomEvent<Listener>\n\n  /**\n   * This event is dispatched when the connection manager has more than the\n   * configured allowable max connections and has closed some connections to\n   * bring the node back under the limit.\n   */\n  'connection:prune': CustomEvent<Connection[]>\n\n  /**\n   * This event notifies listeners when new incoming or outgoing connections\n   * are opened.\n   */\n  'connection:open': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners when incoming or outgoing connections are\n   * closed.\n   */\n  'connection:close': CustomEvent<Connection>\n\n  /**\n   * This event notifies listeners that a TLS certificate is available for use\n   */\n  'certificate:provision': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that a new TLS certificate is available for\n   * use. Any previous certificate may no longer be valid.\n   */\n  'certificate:renew': CustomEvent<TLSCertificate>\n\n  /**\n   * This event notifies listeners that the node has started\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('start', (event) => {\n   *   console.info(libp2p.isStarted()) // true\n   * })\n   * ```\n   */\n  start: CustomEvent<Libp2p<T>>\n\n  /**\n   * This event notifies listeners that the node has stopped\n   *\n   * ```TypeScript\n   * libp2p.addEventListener('stop', (event) => {\n   *   console.info(libp2p.isStarted()) // false\n   * })\n   * ```\n   */\n  stop: CustomEvent<Libp2p<T>>\n}\n\n/**\n * A map of user defined services available on the libp2p node via the\n * `services` key\n *\n * @example\n *\n * ```TypeScript\n * const node = await createLibp2p({\n *   // ...other options\n *   services: {\n *     myService: myService({\n *       // ...service options\n *     })\n *   }\n * })\n *\n * // invoke methods on the service\n * node.services.myService.anOperation()\n * ```\n */\nexport type ServiceMap = Record<string, unknown>\n\nexport type PendingDialStatus = 'queued' | 'active' | 'error' | 'success'\n\n/**\n * An item in the dial queue\n */\nexport interface PendingDial {\n  /**\n   * A unique identifier for this dial\n   */\n  id: string\n\n  /**\n   * The current status of the dial\n   */\n  status: PendingDialStatus\n\n  /**\n   * If known, this is the peer id that libp2p expects to be dialling\n   */\n  peerId?: PeerId\n\n  /**\n   * The list of multiaddrs that will be dialled. The returned connection will\n   * use the first address that succeeds, all other dials part of this pending\n   * dial will be cancelled.\n   */\n  multiaddrs: Multiaddr[]\n}\n\nexport type Libp2pStatus = 'starting' | 'started' | 'stopping' | 'stopped'\n\nexport interface IsDialableOptions extends AbortOptions {\n  /**\n   * If the dial attempt would open a protocol, and the multiaddr being dialed\n   * is a circuit relay address, passing true here would cause the test to fail\n   * because that protocol would not be allowed to run over a data/time limited\n   * connection.\n   */\n  runOnLimitedConnection?: boolean\n}\n\nexport type TransportManagerDialProgressEvents =\n  ProgressEvent<'transport-manager:selected-transport', string>\n\nexport type OpenConnectionProgressEvents =\n  TransportManagerDialProgressEvents |\n  ProgressEvent<'dial-queue:already-connected'> |\n  ProgressEvent<'dial-queue:already-in-dial-queue'> |\n  ProgressEvent<'dial-queue:add-to-dial-queue'> |\n  ProgressEvent<'dial-queue:start-dial'> |\n  ProgressEvent<'dial-queue:calculated-addresses', Address[]> |\n  OutboundConnectionUpgradeEvents\n\nexport interface DialOptions extends AbortOptions, ProgressOptions {\n  /**\n   * If true, open a new connection to the remote even if one already exists\n   */\n  force?: boolean\n}\n\nexport interface DialProtocolOptions extends NewStreamOptions {\n\n}\n\n/**\n * Libp2p nodes implement this interface.\n */\nexport interface Libp2p<T extends ServiceMap = ServiceMap> extends Startable, TypedEventTarget<Libp2pEvents<T>> {\n  /**\n   * The PeerId is a unique identifier for a node on the network.\n   *\n   * It is the hash of an RSA public key or, for Ed25519 or secp256k1 keys,\n   * the key itself.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * console.info(libp2p.peerId)\n   * // PeerId(12D3Foo...)\n   * ````\n   */\n  peerId: PeerId\n\n  /**\n   * The peer store holds information we know about other peers on the network.\n   * - multiaddrs, supported protocols, etc.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peer = await libp2p.peerStore.get(peerId)\n   * console.info(peer)\n   * // { id: PeerId(12D3Foo...), addresses: [] ... }\n   * ```\n   */\n  peerStore: PeerStore\n\n  /**\n   * The peer routing subsystem allows the user to find peers on the network\n   * or to find peers close to binary keys.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const peerInfo = await libp2p.peerRouting.findPeer(peerId)\n   * console.info(peerInfo)\n   * // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * ```\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.peerRouting.getClosestPeers(key)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  peerRouting: PeerRouting\n\n  /**\n   * The content routing subsystem allows the user to find providers for content,\n   * let the network know they are providers for content, and get/put values to\n   * the DHT.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for await (const peerInfo of libp2p.contentRouting.findProviders(cid)) {\n   *   console.info(peerInfo)\n   *   // { id: PeerId(12D3Foo...), multiaddrs: [] ... }\n   * }\n   * ```\n   */\n  contentRouting: ContentRouting\n\n  /**\n   * The metrics subsystem allows recording values to assess the health/performance\n   * of the running node.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const metric = libp2p.metrics.registerMetric({\n   *   'my-metric'\n   * })\n   *\n   * // later\n   * metric.update(5)\n   * ```\n   */\n  metrics?: Metrics\n\n  /**\n   * The logger used by this libp2p node\n   */\n  logger: ComponentLogger\n\n  /**\n   * The current status of the libp2p node\n   */\n  status: Libp2pStatus\n\n  /**\n   * Get a deduplicated list of peer advertising multiaddrs by concatenating\n   * the listen addresses used by transports with any configured\n   * announce addresses as well as observed addresses reported by peers.\n   *\n   * If Announce addrs are specified, configured listen addresses will be\n   * ignored though observed addresses will still be included.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const listenMa = libp2p.getMultiaddrs()\n   * // [ <Multiaddr 047f00000106f9ba - /ip4/127.0.0.1/tcp/63930> ]\n   * ```\n   */\n  getMultiaddrs(): Multiaddr[]\n\n  /**\n   * Returns a list of supported protocols\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const protocols = libp2p.getProtocols()\n   * // [ '/ipfs/ping/1.0.0', '/ipfs/id/1.0.0' ]\n   * ```\n   */\n  getProtocols(): string[]\n\n  /**\n   * Return a list of all connections this node has open, optionally filtering\n   * by a PeerId\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const connection of libp2p.getConnections()) {\n   *   console.log(peerId, connection.remoteAddr.toString())\n   *   // Logs the PeerId string and the observed remote multiaddr of each Connection\n   * }\n   * ```\n   */\n  getConnections(peerId?: PeerId): Connection[]\n\n  /**\n   * Return the list of dials currently in progress or queued to start\n   *\n   * @example\n   *\n   * ```TypeScript\n   * for (const pendingDial of libp2p.getDialQueue()) {\n   *   console.log(pendingDial)\n   * }\n   * ```\n   */\n  getDialQueue(): PendingDial[]\n\n  /**\n   * Return a list of all peers we currently have a connection open to\n   */\n  getPeers(): PeerId[]\n\n  /**\n   * Dials to the provided peer. If successful, the known metadata of the\n   * peer will be added to the nodes `peerStore`.\n   *\n   * If a PeerId is passed as the first argument, the peer will need to have known multiaddrs for it in the PeerStore.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const conn = await libp2p.dial(remotePeerId)\n   *\n   * // create a new stream within the connection\n   * const stream = await conn.newStream(['/echo/1.1.0', '/echo/1.0.0'])\n   *\n   * // protocol negotiated: 'echo/1.0.0' means that the other party only supports the older version\n   *\n   * // ...\n   * await conn.close()\n   * ```\n   */\n  dial(peer: PeerId | Multiaddr | Multiaddr[], options?: DialOptions): Promise<Connection>\n\n  /**\n   * Dials to the provided peer and tries to handshake with the given protocols in order.\n   * If successful, the known metadata of the peer will be added to the nodes `peerStore`,\n   * and the `MuxedStream` will be returned together with the successful negotiated protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * import { pipe } from 'it-pipe'\n   *\n   * const { stream, protocol } = await libp2p.dialProtocol(remotePeerId, protocols)\n   *\n   * // Use this new stream like any other duplex stream\n   * pipe([1, 2, 3], stream, consume)\n   * ```\n   */\n  dialProtocol(peer: PeerId | Multiaddr | Multiaddr[], protocols: string | string[], options?: DialProtocolOptions): Promise<Stream>\n\n  /**\n   * Attempts to gracefully close an open connection to the given peer. If the\n   * connection is not closed in the grace period, it will be forcefully closed.\n   *\n   * An AbortSignal can optionally be passed to control when the connection is\n   * forcefully closed.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * await libp2p.hangUp(remotePeerId)\n   * ```\n   */\n  hangUp(peer: PeerId | Multiaddr, options?: AbortOptions): Promise<void>\n\n  /**\n   * Sets up [multistream-select routing](https://github.com/multiformats/multistream-select) of protocols to their application handlers. Whenever a stream is opened on one of the provided protocols, the handler will be called. `handle` must be called in order to register a handler and support for a given protocol. This also informs other peers of the protocols you support.\n   *\n   * `libp2p.handle(protocols, handler, options)`\n   *\n   * In the event of a new handler for the same protocol being added and error\n   * will be thrown. Pass `force: true` to override this.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const handler = ({ connection, stream, protocol }) => {\n   *   // use stream or connection according to the needs\n   * }\n   *\n   * libp2p.handle('/echo/1.0.0', handler, {\n   *   maxInboundStreams: 5,\n   *   maxOutboundStreams: 5\n   * })\n   * ```\n   */\n  handle(protocol: string | string[], handler: StreamHandler, options?: StreamHandlerOptions): Promise<void>\n\n  /**\n   * Removes the handler for each protocol. The protocol\n   * will no longer be supported on streams.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unhandle(['/echo/1.0.0'])\n   * ```\n   */\n  unhandle(protocols: string[] | string, options?: AbortOptions): Promise<void>\n\n  /**\n   * Register a topology to be informed when peers are encountered that\n   * support the specified protocol\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register('/echo/1.0.0', {\n   *   onConnect: (peer, connection) => {\n   *     // handle connect\n   *   },\n   *   onDisconnect: (peer, connection) => {\n   *     // handle disconnect\n   *   }\n   * })\n   * ```\n   */\n  register(protocol: string, topology: Topology, options?: AbortOptions): Promise<string>\n\n  /**\n   * Unregister topology to no longer be informed when peers connect or\n   * disconnect.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * const id = await libp2p.register(...)\n   *\n   * libp2p.unregister(id)\n   * ```\n   */\n  unregister(id: string): void\n\n  /**\n   * Registers one or more middleware implementations that will be invoked for\n   * incoming and outgoing protocol streams that match the passed protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.use('/my/protocol/1.0.0', (stream, connection, next) => {\n   *   // do something with stream and/or connection\n   *   next(stream, connection)\n   * })\n   * ```\n   */\n  use (protocol: string, middleware: StreamMiddleware | StreamMiddleware[]): void\n\n  /**\n   * Deregisters all middleware for the passed protocol.\n   *\n   * @example\n   *\n   * ```TypeScript\n   * libp2p.unuse('/my/protocol/1.0.0')\n   * // any previously registered middleware will no longer be invoked\n   * ```\n   */\n  unuse (protocol: string): void\n\n  /**\n   * Returns the public key for the passed PeerId. If the PeerId is of the 'RSA'\n   * type this may mean searching the routing if the peer's key is not present\n   * in the peer store.\n   */\n  getPublicKey(peer: Ed25519PeerId, options?: AbortOptions): Promise<Ed25519PublicKey>\n  getPublicKey(peer: Secp256k1PeerId, options?: AbortOptions): Promise<Secp256k1PublicKey>\n  getPublicKey(peer: RSAPeerId, options?: AbortOptions): Promise<RSAPublicKey>\n  getPublicKey(peer: URLPeerId, options?: AbortOptions): Promise<never>\n  getPublicKey(peer: PeerId, options?: AbortOptions): Promise<PublicKey>\n\n  /**\n   * Given the current node configuration, returns a promise of `true` or\n   * `false` if the node would attempt to dial the passed multiaddr.\n   *\n   * This means a relevant transport is configured, and the connection gater\n   * would not block the dial attempt.\n   *\n   * This may involve resolving DNS addresses so you should pass an AbortSignal.\n   */\n  isDialable(multiaddr: Multiaddr | Multiaddr[], options?: IsDialableOptions): Promise<boolean>\n\n  /**\n   * A set of user defined services\n   */\n  services: T\n}\n\n/**\n * Metadata about the current node\n */\nexport interface NodeInfo {\n  /**\n   * The implementation name\n   */\n  name: string\n\n  /**\n   * The implementation version\n   */\n  version: string\n\n  /**\n   * A string that contains information about the implementation and runtime\n   */\n  userAgent: string\n}\n\n/**\n * An object that contains an AbortSignal as\n * the optional `signal` property.\n *\n * @example\n *\n * ```TypeScript\n * const controller = new AbortController()\n *\n * aLongRunningOperation({\n *   signal: controller.signal\n * })\n *\n * // later\n *\n * controller.abort()\n */\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\n/**\n * An object that contains a Logger as the `log` property.\n */\nexport interface LoggerOptions {\n  log: Logger\n}\n\n/**\n * An object that includes a trace object that is passed onwards.\n *\n * This is used by metrics method tracing to link function calls together.\n */\nexport interface TraceOptions {\n  trace?: any\n}\n\n/**\n * A signal that needs to be cleared when no longer in use\n */\nexport interface ClearableSignal extends AbortSignal {\n  clear(): void\n}\n\n/**\n * When a routing operation involves reading values, these options allow\n * controlling where the values are read from. By default libp2p will check\n * local caches but may not use the network if a valid local value is found,\n * these options allow tuning that behavior.\n */\nexport interface RoutingOptions extends AbortOptions, ProgressOptions, TraceOptions {\n  /**\n   * Pass `false` to not use the network\n   *\n   * @default true\n   */\n  useNetwork?: boolean\n\n  /**\n   * Pass `false` to not use cached values\n   *\n   * @default true\n   */\n  useCache?: boolean\n}\n\n/**\n * This symbol is used by libp2p services to define the capabilities they can\n * provide to other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of provided capabilities.\n */\nexport const serviceCapabilities = Symbol.for('@libp2p/service-capabilities')\n\n/**\n * This symbol is used by libp2p services to define the capabilities they\n * require from other libp2p services.\n *\n * The service should define a property with this symbol as the key and the\n * value should be a string array of required capabilities.\n */\nexport const serviceDependencies = Symbol.for('@libp2p/service-dependencies')\n\nexport * from './connection.js'\nexport * from './connection-encrypter.js'\nexport * from './connection-gater.js'\nexport * from './connection-protector.js'\nexport * from './content-routing.js'\nexport * from './errors.js'\nexport * from './events.js'\nexport * from './keys.js'\nexport * from './message-stream.js'\nexport * from './metrics.js'\nexport * from './multiaddr-connection.js'\nexport * from './peer-discovery.js'\nexport * from './peer-id.js'\nexport * from './peer-info.js'\nexport * from './peer-routing.js'\nexport * from './peer-store.js'\nexport * from './record.js'\nexport * from './startable.js'\nexport * from './stream-handler.js'\nexport * from './stream-muxer.js'\nexport * from './stream.js'\nexport * from './topology.js'\nexport * from './transport.js'\n\nexport * from 'main-event'\n", "import { baseX } from './base.js'\n\nexport const base58btc = baseX({\n  name: 'base58btc',\n  prefix: 'z',\n  alphabet: '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n})\n\nexport const base58flickr = baseX({\n  name: 'base58flickr',\n  prefix: 'Z',\n  alphabet: '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n})\n", "export const empty = new Uint8Array(0)\n\nexport function toHex (d: Uint8Array): string {\n  return d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, '0'), '')\n}\n\nexport function fromHex (hex: string): Uint8Array {\n  const hexes = hex.match(/../g)\n  return hexes != null ? new Uint8Array(hexes.map(b => parseInt(b, 16))) : empty\n}\n\nexport function equals (aa: Uint8Array, bb: Uint8Array): boolean {\n  if (aa === bb) { return true }\n  if (aa.byteLength !== bb.byteLength) {\n    return false\n  }\n\n  for (let ii = 0; ii < aa.byteLength; ii++) {\n    if (aa[ii] !== bb[ii]) {\n      return false\n    }\n  }\n\n  return true\n}\n\nexport function coerce (o: ArrayBufferView | ArrayBuffer | Uint8Array): Uint8Array {\n  if (o instanceof Uint8Array && o.constructor.name === 'Uint8Array') { return o }\n  if (o instanceof ArrayBuffer) { return new Uint8Array(o) }\n  if (ArrayBuffer.isView(o)) {\n    return new Uint8Array(o.buffer, o.byteOffset, o.byteLength)\n  }\n  throw new Error('Unknown type, must be binary type')\n}\n\nexport function isBinary (o: unknown): o is ArrayBuffer | ArrayBufferView {\n  return o instanceof ArrayBuffer || ArrayBuffer.isView(o)\n}\n\nexport function fromString (str: string): Uint8Array {\n  return new TextEncoder().encode(str)\n}\n\nexport function toString (b: Uint8Array): string {\n  return new TextDecoder().decode(b)\n}\n", "/* eslint-disable */\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n/**\n * @param {string} ALPHABET\n * @param {any} name\n */\nfunction base (ALPHABET, name) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256);\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255;\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i);\n    var xc = x.charCodeAt(0);\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i;\n  }\n  var BASE = ALPHABET.length;\n  var LEADER = ALPHABET.charAt(0);\n  var FACTOR = Math.log(BASE) / Math.log(256); // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE); // log(256) / log(BASE), rounded up\n  /**\n   * @param {any[] | Iterable<number>} source\n   */\n  function encode (source) {\n    // @ts-ignore\n    if (source instanceof Uint8Array) ; else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source);\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0;\n    var length = 0;\n    var pbegin = 0;\n    var pend = source.length;\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++;\n      zeroes++;\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0;\n    var b58 = new Uint8Array(size);\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0;\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0;\n        b58[it1] = (carry % BASE) >>> 0;\n        carry = (carry / BASE) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      pbegin++;\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length;\n    while (it2 !== size && b58[it2] === 0) {\n      it2++;\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes);\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]); }\n    return str\n  }\n  /**\n   * @param {string | string[]} source\n   */\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0;\n        // Skip leading spaces.\n    if (source[psz] === ' ') { return }\n        // Skip and count leading '1's.\n    var zeroes = 0;\n    var length = 0;\n    while (source[psz] === LEADER) {\n      zeroes++;\n      psz++;\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0; // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size);\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0;\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0;\n        b256[it3] = (carry % 256) >>> 0;\n        carry = (carry / 256) >>> 0;\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i;\n      psz++;\n    }\n        // Skip trailing spaces.\n    if (source[psz] === ' ') { return }\n        // Skip leading zeroes in b256.\n    var it4 = size - length;\n    while (it4 !== size && b256[it4] === 0) {\n      it4++;\n    }\n    var vch = new Uint8Array(zeroes + (size - it4));\n    var j = zeroes;\n    while (it4 !== size) {\n      vch[j++] = b256[it4++];\n    }\n    return vch\n  }\n  /**\n   * @param {string | string[]} string\n   */\n  function decode (string) {\n    var buffer = decodeUnsafe(string);\n    if (buffer) { return buffer }\n    throw new Error(`Non-${name} character`)\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nvar src = base;\n\nvar _brrp__multiformats_scope_baseX = src;\n\nexport default _brrp__multiformats_scope_baseX;\n", "import { coerce } from '../bytes.js'\nimport basex from '../vendor/base-x.js'\nimport type { BaseCodec, BaseDecoder, BaseEncoder, CombobaseDecoder, Multibase, MultibaseCodec, MultibaseDecoder, MultibaseEncoder, UnibaseDecoder } from './interface.js'\n\ninterface EncodeFn { (bytes: Uint8Array): string }\ninterface DecodeFn { (text: string): Uint8Array }\n\n/**\n * Class represents both BaseEncoder and MultibaseEncoder meaning it\n * can be used to encode to multibase or base encode without multibase\n * prefix.\n */\nclass Encoder<Base extends string, Prefix extends string> implements MultibaseEncoder<Prefix>, BaseEncoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n  }\n\n  encode (bytes: Uint8Array): Multibase<Prefix> {\n    if (bytes instanceof Uint8Array) {\n      return `${this.prefix}${this.baseEncode(bytes)}`\n    } else {\n      throw Error('Unknown type, must be binary type')\n    }\n  }\n}\n\n/**\n * Class represents both BaseDecoder and MultibaseDecoder so it could be used\n * to decode multibases (with matching prefix) or just base decode strings\n * with corresponding base encoding.\n */\nclass Decoder<Base extends string, Prefix extends string> implements MultibaseDecoder<Prefix>, UnibaseDecoder<Prefix>, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseDecode: DecodeFn\n  private readonly prefixCodePoint: number\n\n  constructor (name: Base, prefix: Prefix, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    const prefixCodePoint = prefix.codePointAt(0)\n    /* c8 ignore next 3 */\n    if (prefixCodePoint === undefined) {\n      throw new Error('Invalid prefix character')\n    }\n    this.prefixCodePoint = prefixCodePoint\n    this.baseDecode = baseDecode\n  }\n\n  decode (text: string): Uint8Array {\n    if (typeof text === 'string') {\n      if (text.codePointAt(0) !== this.prefixCodePoint) {\n        throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)\n      }\n      return this.baseDecode(text.slice(this.prefix.length))\n    } else {\n      throw Error('Can only multibase decode strings')\n    }\n  }\n\n  or<OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n}\n\ntype Decoders<Prefix extends string> = Record<Prefix, UnibaseDecoder<Prefix>>\n\nclass ComposedDecoder<Prefix extends string> implements MultibaseDecoder<Prefix>, CombobaseDecoder<Prefix> {\n  readonly decoders: Decoders<Prefix>\n\n  constructor (decoders: Decoders<Prefix>) {\n    this.decoders = decoders\n  }\n\n  or <OtherPrefix extends string> (decoder: UnibaseDecoder<OtherPrefix> | ComposedDecoder<OtherPrefix>): ComposedDecoder<Prefix | OtherPrefix> {\n    return or(this, decoder)\n  }\n\n  decode (input: string): Uint8Array {\n    const prefix = input[0] as Prefix\n    const decoder = this.decoders[prefix]\n    if (decoder != null) {\n      return decoder.decode(input)\n    } else {\n      throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)\n    }\n  }\n}\n\nexport function or <L extends string, R extends string> (left: UnibaseDecoder<L> | CombobaseDecoder<L>, right: UnibaseDecoder<R> | CombobaseDecoder<R>): ComposedDecoder<L | R> {\n  return new ComposedDecoder({\n    ...(left.decoders ?? { [(left as UnibaseDecoder<L>).prefix]: left }),\n    ...(right.decoders ?? { [(right as UnibaseDecoder<R>).prefix]: right })\n  } as Decoders<L | R>)\n}\n\nexport class Codec<Base extends string, Prefix extends string> implements MultibaseCodec<Prefix>, MultibaseEncoder<Prefix>, MultibaseDecoder<Prefix>, BaseCodec, BaseEncoder, BaseDecoder {\n  readonly name: Base\n  readonly prefix: Prefix\n  readonly baseEncode: EncodeFn\n  readonly baseDecode: DecodeFn\n  readonly encoder: Encoder<Base, Prefix>\n  readonly decoder: Decoder<Base, Prefix>\n\n  constructor (name: Base, prefix: Prefix, baseEncode: EncodeFn, baseDecode: DecodeFn) {\n    this.name = name\n    this.prefix = prefix\n    this.baseEncode = baseEncode\n    this.baseDecode = baseDecode\n    this.encoder = new Encoder(name, prefix, baseEncode)\n    this.decoder = new Decoder(name, prefix, baseDecode)\n  }\n\n  encode (input: Uint8Array): string {\n    return this.encoder.encode(input)\n  }\n\n  decode (input: string): Uint8Array {\n    return this.decoder.decode(input)\n  }\n}\n\nexport function from <Base extends string, Prefix extends string> ({ name, prefix, encode, decode }: { name: Base, prefix: Prefix, encode: EncodeFn, decode: DecodeFn }): Codec<Base, Prefix> {\n  return new Codec(name, prefix, encode, decode)\n}\n\nexport function baseX <Base extends string, Prefix extends string> ({ name, prefix, alphabet }: { name: Base, prefix: Prefix, alphabet: string }): Codec<Base, Prefix> {\n  const { encode, decode } = basex(alphabet, name)\n  return from({\n    prefix,\n    name,\n    encode,\n    decode: (text: string): Uint8Array => coerce(decode(text))\n  })\n}\n\nfunction decode (string: string, alphabetIdx: Record<string, number>, bitsPerChar: number, name: string): Uint8Array {\n  // Count the padding bytes:\n  let end = string.length\n  while (string[end - 1] === '=') {\n    --end\n  }\n\n  // Allocate the output:\n  const out = new Uint8Array((end * bitsPerChar / 8) | 0)\n\n  // Parse the data:\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  let written = 0 // Next byte to write\n  for (let i = 0; i < end; ++i) {\n    // Read one character from the string:\n    const value = alphabetIdx[string[i]]\n    if (value === undefined) {\n      throw new SyntaxError(`Non-${name} character`)\n    }\n\n    // Append the bits to the buffer:\n    buffer = (buffer << bitsPerChar) | value\n    bits += bitsPerChar\n\n    // Write out some bits if the buffer has a byte's worth:\n    if (bits >= 8) {\n      bits -= 8\n      out[written++] = 0xff & (buffer >> bits)\n    }\n  }\n\n  // Verify that we have received just enough bits:\n  if (bits >= bitsPerChar || (0xff & (buffer << (8 - bits))) !== 0) {\n    throw new SyntaxError('Unexpected end of data')\n  }\n\n  return out\n}\n\nfunction encode (data: Uint8Array, alphabet: string, bitsPerChar: number): string {\n  const pad = alphabet[alphabet.length - 1] === '='\n  const mask = (1 << bitsPerChar) - 1\n  let out = ''\n\n  let bits = 0 // Number of bits currently in the buffer\n  let buffer = 0 // Bits waiting to be written out, MSB first\n  for (let i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = (buffer << 8) | data[i]\n    bits += 8\n\n    // Write out as much as we can:\n    while (bits > bitsPerChar) {\n      bits -= bitsPerChar\n      out += alphabet[mask & (buffer >> bits)]\n    }\n  }\n\n  // Partial character:\n  if (bits !== 0) {\n    out += alphabet[mask & (buffer << (bitsPerChar - bits))]\n  }\n\n  // Add padding characters until we hit a byte boundary:\n  if (pad) {\n    while (((out.length * bitsPerChar) & 7) !== 0) {\n      out += '='\n    }\n  }\n\n  return out\n}\n\nfunction createAlphabetIdx (alphabet: string): Record<string, number> {\n  // Build the character lookup table:\n  const alphabetIdx: Record<string, number> = {}\n  for (let i = 0; i < alphabet.length; ++i) {\n    alphabetIdx[alphabet[i]] = i\n  }\n  return alphabetIdx\n}\n\n/**\n * RFC4648 Factory\n */\nexport function rfc4648 <Base extends string, Prefix extends string> ({ name, prefix, bitsPerChar, alphabet }: { name: Base, prefix: Prefix, bitsPerChar: number, alphabet: string }): Codec<Base, Prefix> {\n  const alphabetIdx = createAlphabetIdx(alphabet)\n  return from({\n    prefix,\n    name,\n    encode (input: Uint8Array): string {\n      return encode(input, alphabet, bitsPerChar)\n    },\n    decode (input: string): Uint8Array {\n      return decode(input, alphabetIdx, bitsPerChar, name)\n    }\n  })\n}\n", "import { rfc4648 } from './base.js'\n\nexport const base32 = rfc4648({\n  prefix: 'b',\n  name: 'base32',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567',\n  bitsPerChar: 5\n})\n\nexport const base32upper = rfc4648({\n  prefix: 'B',\n  name: 'base32upper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bitsPerChar: 5\n})\n\nexport const base32pad = rfc4648({\n  prefix: 'c',\n  name: 'base32pad',\n  alphabet: 'abcdefghijklmnopqrstuvwxyz234567=',\n  bitsPerChar: 5\n})\n\nexport const base32padupper = rfc4648({\n  prefix: 'C',\n  name: 'base32padupper',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=',\n  bitsPerChar: 5\n})\n\nexport const base32hex = rfc4648({\n  prefix: 'v',\n  name: 'base32hex',\n  alphabet: '0123456789abcdefghijklmnopqrstuv',\n  bitsPerChar: 5\n})\n\nexport const base32hexupper = rfc4648({\n  prefix: 'V',\n  name: 'base32hexupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bitsPerChar: 5\n})\n\nexport const base32hexpad = rfc4648({\n  prefix: 't',\n  name: 'base32hexpad',\n  alphabet: '0123456789abcdefghijklmnopqrstuv=',\n  bitsPerChar: 5\n})\n\nexport const base32hexpadupper = rfc4648({\n  prefix: 'T',\n  name: 'base32hexpadupper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUV=',\n  bitsPerChar: 5\n})\n\nexport const base32z = rfc4648({\n  prefix: 'h',\n  name: 'base32z',\n  alphabet: 'ybndrfg8ejkmcpqxot1uwisza345h769',\n  bitsPerChar: 5\n})\n", "import { baseX } from './base.js'\n\nexport const base36 = baseX({\n  prefix: 'k',\n  name: 'base36',\n  alphabet: '0123456789abcdefghijklmnopqrstuvwxyz'\n})\n\nexport const base36upper = baseX({\n  prefix: 'K',\n  name: 'base36upper',\n  alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n})\n", "/* eslint-disable */\nvar encode_1 = encode;\n\nvar MSB = 0x80\n  , REST = 0x7F\n  , MSBALL = ~REST\n  , INT = Math.pow(2, 31);\n\n/**\n * @param {number} num\n * @param {number[]} out\n * @param {number} offset\n */\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n\n  while(num >= INT) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num /= 128;\n  }\n  while(num & MSBALL) {\n    out[offset++] = (num & 0xFF) | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  \n  // @ts-ignore\n  encode.bytes = offset - oldOffset + 1;\n  \n  return out\n}\n\nvar decode = read;\n\nvar MSB$1 = 0x80\n  , REST$1 = 0x7F;\n\n/**\n * @param {string | any[]} buf\n * @param {number} offset\n */\nfunction read(buf, offset) {\n  var res    = 0\n    , offset = offset || 0\n    , shift  = 0\n    , counter = offset\n    , b\n    , l = buf.length;\n\n  do {\n    if (counter >= l) {\n      // @ts-ignore\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint')\n    }\n    b = buf[counter++];\n    res += shift < 28\n      ? (b & REST$1) << shift\n      : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1)\n\n  // @ts-ignore\n  read.bytes = counter - offset;\n\n  return res\n}\n\nvar N1 = Math.pow(2,  7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\n\nvar length = function (/** @type {number} */ value) {\n  return (\n    value < N1 ? 1\n  : value < N2 ? 2\n  : value < N3 ? 3\n  : value < N4 ? 4\n  : value < N5 ? 5\n  : value < N6 ? 6\n  : value < N7 ? 7\n  : value < N8 ? 8\n  : value < N9 ? 9\n  :              10\n  )\n};\n\nvar varint = {\n    encode: encode_1\n  , decode: decode\n  , encodingLength: length\n};\n\nvar _brrp_varint = varint;\n\nexport default _brrp_varint;\n", "import varint from './vendor/varint.js'\n\nexport function decode (data: Uint8Array, offset = 0): [number, number] {\n  const code = varint.decode(data, offset)\n  return [code, varint.decode.bytes]\n}\n\nexport function encodeTo (int: number, target: Uint8Array, offset = 0): Uint8Array {\n  varint.encode(int, target, offset)\n  return target\n}\n\nexport function encodingLength (int: number): number {\n  return varint.encodingLength(int)\n}\n", "import { coerce, equals as equalBytes } from '../bytes.js'\nimport * as varint from '../varint.js'\nimport type { MultihashDigest } from './interface.js'\n\n/**\n * Creates a multihash digest.\n */\nexport function create <Code extends number> (code: Code, digest: Uint8Array): Digest<Code, number> {\n  const size = digest.byteLength\n  const sizeOffset = varint.encodingLength(code)\n  const digestOffset = sizeOffset + varint.encodingLength(size)\n\n  const bytes = new Uint8Array(digestOffset + size)\n  varint.encodeTo(code, bytes, 0)\n  varint.encodeTo(size, bytes, sizeOffset)\n  bytes.set(digest, digestOffset)\n\n  return new Digest(code, size, digest, bytes)\n}\n\n/**\n * Turns bytes representation of multihash digest into an instance.\n */\nexport function decode (multihash: Uint8Array): MultihashDigest {\n  const bytes = coerce(multihash)\n  const [code, sizeOffset] = varint.decode(bytes)\n  const [size, digestOffset] = varint.decode(bytes.subarray(sizeOffset))\n  const digest = bytes.subarray(sizeOffset + digestOffset)\n\n  if (digest.byteLength !== size) {\n    throw new Error('Incorrect length')\n  }\n\n  return new Digest(code, size, digest, bytes)\n}\n\nexport function equals (a: MultihashDigest, b: unknown): b is MultihashDigest {\n  if (a === b) {\n    return true\n  } else {\n    const data = b as { code?: unknown, size?: unknown, bytes?: unknown }\n\n    return (\n      a.code === data.code &&\n      a.size === data.size &&\n      data.bytes instanceof Uint8Array &&\n      equalBytes(a.bytes, data.bytes)\n    )\n  }\n}\n\n/**\n * Represents a multihash digest which carries information about the\n * hashing algorithm and an actual hash digest.\n */\nexport class Digest<Code extends number, Size extends number> implements MultihashDigest {\n  readonly code: Code\n  readonly size: Size\n  readonly digest: Uint8Array\n  readonly bytes: Uint8Array\n\n  /**\n   * Creates a multihash digest.\n   */\n  constructor (code: Code, size: Size, digest: Uint8Array, bytes: Uint8Array) {\n    this.code = code\n    this.size = size\n    this.digest = digest\n    this.bytes = bytes\n  }\n}\n\n/**\n * Used to check that the passed multihash has the passed code\n */\nexport function hasCode <T extends number> (digest: MultihashDigest, code: T): digest is MultihashDigest<T> {\n  return digest.code === code\n}\n", "import { base32 } from './bases/base32.js'\nimport { base36 } from './bases/base36.js'\nimport { base58btc } from './bases/base58.js'\nimport { coerce } from './bytes.js'\nimport * as Digest from './hashes/digest.js'\nimport * as varint from './varint.js'\nimport type * as API from './link/interface.js'\n\n// This way TS will also expose all the types from module\nexport * from './link/interface.js'\n\nexport function format <T extends API.Link<unknown, number, number, API.Version>, Prefix extends string> (link: T, base?: API.MultibaseEncoder<Prefix>): API.ToString<T, Prefix> {\n  const { bytes, version } = link\n  switch (version) {\n    case 0:\n      return toStringV0(\n        bytes,\n        baseCache(link),\n        base as API.MultibaseEncoder<'z'> ?? base58btc.encoder\n      )\n    default:\n      return toStringV1(\n        bytes,\n        baseCache(link),\n        (base ?? base32.encoder) as API.MultibaseEncoder<Prefix>\n      )\n  }\n}\n\nexport function toJSON <Link extends API.UnknownLink> (link: Link): API.LinkJSON<Link> {\n  return {\n    '/': format(link)\n  }\n}\n\nexport function fromJSON <Link extends API.UnknownLink> (json: API.LinkJSON<Link>): CID<unknown, number, number, API.Version> {\n  return CID.parse(json['/'])\n}\n\nconst cache = new WeakMap<API.UnknownLink, Map<string, string>>()\n\nfunction baseCache (cid: API.UnknownLink): Map<string, string> {\n  const baseCache = cache.get(cid)\n  if (baseCache == null) {\n    const baseCache = new Map()\n    cache.set(cid, baseCache)\n    return baseCache\n  }\n  return baseCache\n}\n\nexport class CID<Data = unknown, Format extends number = number, Alg extends number = number, Version extends API.Version = API.Version> implements API.Link<Data, Format, Alg, Version> {\n  readonly code: Format\n  readonly version: Version\n  readonly multihash: API.MultihashDigest<Alg>\n  readonly bytes: Uint8Array\n  readonly '/': Uint8Array\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param multihash - (Multi)hash of the of the content.\n   */\n  constructor (version: Version, code: Format, multihash: API.MultihashDigest<Alg>, bytes: Uint8Array) {\n    this.code = code\n    this.version = version\n    this.multihash = multihash\n    this.bytes = bytes\n\n    // flag to serializers that this is a CID and\n    // should be treated specially\n    this['/'] = bytes\n  }\n\n  /**\n   * Signalling `cid.asCID === cid` has been replaced with `cid['/'] === cid.bytes`\n   * please either use `CID.asCID(cid)` or switch to new signalling mechanism\n   *\n   * @deprecated\n   */\n  get asCID (): this {\n    return this\n  }\n\n  // ArrayBufferView\n  get byteOffset (): number {\n    return this.bytes.byteOffset\n  }\n\n  // ArrayBufferView\n  get byteLength (): number {\n    return this.bytes.byteLength\n  }\n\n  toV0 (): CID<Data, API.DAG_PB, API.SHA_256, 0> {\n    switch (this.version) {\n      case 0: {\n        return this as CID<Data, API.DAG_PB, API.SHA_256, 0>\n      }\n      case 1: {\n        const { code, multihash } = this\n\n        if (code !== DAG_PB_CODE) {\n          throw new Error('Cannot convert a non dag-pb CID to CIDv0')\n        }\n\n        // sha2-256\n        if (multihash.code !== SHA_256_CODE) {\n          throw new Error('Cannot convert non sha2-256 multihash CID to CIDv0')\n        }\n\n        return (\n          CID.createV0(\n            multihash as API.MultihashDigest<API.SHA_256>\n          )\n        )\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 0. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  toV1 (): CID<Data, Format, Alg, 1> {\n    switch (this.version) {\n      case 0: {\n        const { code, digest } = this.multihash\n        const multihash = Digest.create(code, digest)\n        return (\n          CID.createV1(this.code, multihash)\n        )\n      }\n      case 1: {\n        return this as CID<Data, Format, Alg, 1>\n      }\n      default: {\n        throw Error(\n          `Can not convert CID version ${this.version} to version 1. This is a bug please report`\n        )\n      }\n    }\n  }\n\n  equals (other: unknown): other is CID<Data, Format, Alg, Version> {\n    return CID.equals(this, other)\n  }\n\n  static equals <Data, Format extends number, Alg extends number, Version extends API.Version>(self: API.Link<Data, Format, Alg, Version>, other: unknown): other is CID {\n    const unknown = other as { code?: unknown, version?: unknown, multihash?: unknown }\n    return (\n      unknown != null &&\n      self.code === unknown.code &&\n      self.version === unknown.version &&\n      Digest.equals(self.multihash, unknown.multihash)\n    )\n  }\n\n  toString (base?: API.MultibaseEncoder<string>): string {\n    return format(this, base)\n  }\n\n  toJSON (): API.LinkJSON<this> {\n    return { '/': format(this) }\n  }\n\n  link (): this {\n    return this\n  }\n\n  readonly [Symbol.toStringTag] = 'CID';\n\n  // Legacy\n\n  [Symbol.for('nodejs.util.inspect.custom')] (): string {\n    return `CID(${this.toString()})`\n  }\n\n  /**\n   * Takes any input `value` and returns a `CID` instance if it was\n   * a `CID` otherwise returns `null`. If `value` is instanceof `CID`\n   * it will return value back. If `value` is not instance of this CID\n   * class, but is compatible CID it will return new instance of this\n   * `CID` class. Otherwise returns null.\n   *\n   * This allows two different incompatible versions of CID library to\n   * co-exist and interop as long as binary interface is compatible.\n   */\n  static asCID <Data, Format extends number, Alg extends number, Version extends API.Version, U>(input: API.Link<Data, Format, Alg, Version> | U): CID<Data, Format, Alg, Version> | null {\n    if (input == null) {\n      return null\n    }\n\n    const value = input as any\n    if (value instanceof CID) {\n      // If value is instance of CID then we're all set.\n      return value\n    } else if ((value['/'] != null && value['/'] === value.bytes) || value.asCID === value) {\n      // If value isn't instance of this CID class but `this.asCID === this` or\n      // `value['/'] === value.bytes` is true it is CID instance coming from a\n      // different implementation (diff version or duplicate). In that case we\n      // rebase it to this `CID` implementation so caller is guaranteed to get\n      // instance with expected API.\n      const { version, code, multihash, bytes } = value\n      return new CID(\n        version,\n        code,\n        multihash as API.MultihashDigest<Alg>,\n        bytes ?? encodeCID(version, code, multihash.bytes)\n      )\n    } else if (value[cidSymbol] === true) {\n      // If value is a CID from older implementation that used to be tagged via\n      // symbol we still rebase it to the this `CID` implementation by\n      // delegating that to a constructor.\n      const { version, multihash, code } = value\n      const digest = Digest.decode(multihash) as API.MultihashDigest<Alg>\n      return CID.create(version, code, digest)\n    } else {\n      // Otherwise value is not a CID (or an incompatible version of it) in\n      // which case we return `null`.\n      return null\n    }\n  }\n\n  /**\n   * @param version - Version of the CID\n   * @param code - Code of the codec content is encoded in, see https://github.com/multiformats/multicodec/blob/master/table.csv\n   * @param digest - (Multi)hash of the of the content.\n   */\n  static create <Data, Format extends number, Alg extends number, Version extends API.Version>(version: Version, code: Format, digest: API.MultihashDigest<Alg>): CID<Data, Format, Alg, Version> {\n    if (typeof code !== 'number') {\n      throw new Error('String codecs are no longer supported')\n    }\n\n    if (!(digest.bytes instanceof Uint8Array)) {\n      throw new Error('Invalid digest')\n    }\n\n    switch (version) {\n      case 0: {\n        if (code !== DAG_PB_CODE) {\n          throw new Error(\n            `Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`\n          )\n        } else {\n          return new CID(version, code, digest, digest.bytes)\n        }\n      }\n      case 1: {\n        const bytes = encodeCID(version, code, digest.bytes)\n        return new CID(version, code, digest, bytes)\n      }\n      default: {\n        throw new Error('Invalid version')\n      }\n    }\n  }\n\n  /**\n   * Simplified version of `create` for CIDv0.\n   */\n  static createV0 <T = unknown>(digest: API.MultihashDigest<typeof SHA_256_CODE>): CID<T, typeof DAG_PB_CODE, typeof SHA_256_CODE, 0> {\n    return CID.create(0, DAG_PB_CODE, digest)\n  }\n\n  /**\n   * Simplified version of `create` for CIDv1.\n   *\n   * @param code - Content encoding format code.\n   * @param digest - Multihash of the content.\n   */\n  static createV1 <Data, Code extends number, Alg extends number>(code: Code, digest: API.MultihashDigest<Alg>): CID<Data, Code, Alg, 1> {\n    return CID.create(1, code, digest)\n  }\n\n  /**\n   * Decoded a CID from its binary representation. The byte array must contain\n   * only the CID with no additional bytes.\n   *\n   * An error will be thrown if the bytes provided do not contain a valid\n   * binary representation of a CID.\n   */\n  static decode <Data, Code extends number, Alg extends number, Version extends API.Version>(bytes: API.ByteView<API.Link<Data, Code, Alg, Version>>): CID<Data, Code, Alg, Version> {\n    const [cid, remainder] = CID.decodeFirst(bytes)\n    if (remainder.length !== 0) {\n      throw new Error('Incorrect length')\n    }\n    return cid\n  }\n\n  /**\n   * Decoded a CID from its binary representation at the beginning of a byte\n   * array.\n   *\n   * Returns an array with the first element containing the CID and the second\n   * element containing the remainder of the original byte array. The remainder\n   * will be a zero-length byte array if the provided bytes only contained a\n   * binary CID representation.\n   */\n  static decodeFirst <T, C extends number, A extends number, V extends API.Version>(bytes: API.ByteView<API.Link<T, C, A, V>>): [CID<T, C, A, V>, Uint8Array] {\n    const specs = CID.inspectBytes(bytes)\n    const prefixSize = specs.size - specs.multihashSize\n    const multihashBytes = coerce(\n      bytes.subarray(prefixSize, prefixSize + specs.multihashSize)\n    )\n    if (multihashBytes.byteLength !== specs.multihashSize) {\n      throw new Error('Incorrect length')\n    }\n    const digestBytes = multihashBytes.subarray(\n      specs.multihashSize - specs.digestSize\n    )\n    const digest = new Digest.Digest(\n      specs.multihashCode,\n      specs.digestSize,\n      digestBytes,\n      multihashBytes\n    )\n    const cid =\n      specs.version === 0\n        ? CID.createV0(digest as API.MultihashDigest<API.SHA_256>)\n        : CID.createV1(specs.codec, digest)\n    return [cid as CID<T, C, A, V>, bytes.subarray(specs.size)]\n  }\n\n  /**\n   * Inspect the initial bytes of a CID to determine its properties.\n   *\n   * Involves decoding up to 4 varints. Typically this will require only 4 to 6\n   * bytes but for larger multicodec code values and larger multihash digest\n   * lengths these varints can be quite large. It is recommended that at least\n   * 10 bytes be made available in the `initialBytes` argument for a complete\n   * inspection.\n   */\n  static inspectBytes <T, C extends number, A extends number, V extends API.Version>(initialBytes: API.ByteView<API.Link<T, C, A, V>>): { version: V, codec: C, multihashCode: A, digestSize: number, multihashSize: number, size: number } {\n    let offset = 0\n    const next = (): number => {\n      const [i, length] = varint.decode(initialBytes.subarray(offset))\n      offset += length\n      return i\n    }\n\n    let version = next() as V\n    let codec = DAG_PB_CODE as C\n    if (version as number === 18) {\n      // CIDv0\n      version = 0 as V\n      offset = 0\n    } else {\n      codec = next() as C\n    }\n\n    if (version !== 0 && version !== 1) {\n      throw new RangeError(`Invalid CID version ${version}`)\n    }\n\n    const prefixSize = offset\n    const multihashCode = next() as A // multihash code\n    const digestSize = next() // multihash length\n    const size = offset + digestSize\n    const multihashSize = size - prefixSize\n\n    return { version, codec, multihashCode, digestSize, multihashSize, size }\n  }\n\n  /**\n   * Takes cid in a string representation and creates an instance. If `base`\n   * decoder is not provided will use a default from the configuration. It will\n   * throw an error if encoding of the CID is not compatible with supplied (or\n   * a default decoder).\n   */\n  static parse <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version>(source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): CID<Data, Code, Alg, Version> {\n    const [prefix, bytes] = parseCIDtoBytes(source, base)\n\n    const cid = CID.decode(bytes)\n\n    if (cid.version === 0 && source[0] !== 'Q') {\n      throw Error('Version 0 CID string must not include multibase prefix')\n    }\n\n    // Cache string representation to avoid computing it on `this.toString()`\n    baseCache(cid).set(prefix, source)\n\n    return cid\n  }\n}\n\nfunction parseCIDtoBytes <Prefix extends string, Data, Code extends number, Alg extends number, Version extends API.Version> (source: API.ToString<API.Link<Data, Code, Alg, Version>, Prefix>, base?: API.MultibaseDecoder<Prefix>): [Prefix, API.ByteView<API.Link<Data, Code, Alg, Version>>] {\n  switch (source[0]) {\n    // CIDv0 is parsed differently\n    case 'Q': {\n      const decoder = base ?? base58btc\n      return [\n        base58btc.prefix as Prefix,\n        decoder.decode(`${base58btc.prefix}${source}`)\n      ]\n    }\n    case base58btc.prefix: {\n      const decoder = base ?? base58btc\n      return [base58btc.prefix as Prefix, decoder.decode(source)]\n    }\n    case base32.prefix: {\n      const decoder = base ?? base32\n      return [base32.prefix as Prefix, decoder.decode(source)]\n    }\n    case base36.prefix: {\n      const decoder = base ?? base36\n      return [base36.prefix as Prefix, decoder.decode(source)]\n    }\n    default: {\n      if (base == null) {\n        throw Error(\n          'To parse non base32, base36 or base58btc encoded CID multibase decoder must be provided'\n        )\n      }\n      return [source[0] as Prefix, base.decode(source)]\n    }\n  }\n}\n\nfunction toStringV0 (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<'z'>): string {\n  const { prefix } = base\n  if (prefix !== base58btc.prefix) {\n    throw Error(`Cannot string encode V0 in ${base.name} encoding`)\n  }\n\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes).slice(1)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nfunction toStringV1 <Prefix extends string> (bytes: Uint8Array, cache: Map<string, string>, base: API.MultibaseEncoder<Prefix>): string {\n  const { prefix } = base\n  const cid = cache.get(prefix)\n  if (cid == null) {\n    const cid = base.encode(bytes)\n    cache.set(prefix, cid)\n    return cid\n  } else {\n    return cid\n  }\n}\n\nconst DAG_PB_CODE = 0x70\nconst SHA_256_CODE = 0x12\n\nfunction encodeCID (version: API.Version, code: number, multihash: Uint8Array): Uint8Array {\n  const codeOffset = varint.encodingLength(version)\n  const hashOffset = codeOffset + varint.encodingLength(code)\n  const bytes = new Uint8Array(hashOffset + multihash.byteLength)\n  varint.encodeTo(version, bytes, 0)\n  varint.encodeTo(code, bytes, codeOffset)\n  bytes.set(multihash, hashOffset)\n  return bytes\n}\n\nconst cidSymbol = Symbol.for('@ipld/js-cid/CID')\n", "import { coerce } from '../bytes.js'\nimport * as Digest from './digest.js'\nimport type { DigestOptions } from './hasher.js'\n\nconst code: 0x0 = 0x0\nconst name = 'identity'\n\nconst encode: (input: Uint8Array) => Uint8Array = coerce\n\nfunction digest (input: Uint8Array, options?: DigestOptions): Digest.Digest<typeof code, number> {\n  if (options?.truncate != null && options.truncate !== input.byteLength) {\n    if (options.truncate < 0 || options.truncate > input.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${input.byteLength}`)\n    }\n\n    input = input.subarray(0, options.truncate)\n  }\n\n  return Digest.create(code, encode(input))\n}\n\nexport const identity = { code, name, encode, digest }\n", "/**\n * Returns true if the two passed Uint8Arrays have the same content\n */\nexport function equals (a: Uint8Array, b: Uint8Array): boolean {\n  if (a === b) {\n    return true\n  }\n\n  if (a.byteLength !== b.byteLength) {\n    return false\n  }\n\n  for (let i = 0; i < a.byteLength; i++) {\n    if (a[i] !== b[i]) {\n      return false\n    }\n  }\n\n  return true\n}\n", "/**\n * Returns a `Uint8Array` of the requested size. Referenced memory will\n * be initialized to 0.\n */\nexport function alloc (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n\n/**\n * Where possible returns a Uint8Array of the requested size that references\n * uninitialized memory. Only use if you are certain you will immediately\n * overwrite every value in the returned `Uint8Array`.\n */\nexport function allocUnsafe (size: number = 0): Uint8Array {\n  return new Uint8Array(size)\n}\n", "import { allocUnsafe } from '#alloc'\nimport { asUint8Array } from '#util/as-uint8array'\n\n/**\n * Returns a new Uint8Array created by concatenating the passed Uint8Arrays\n */\nexport function concat (arrays: Uint8Array[], length?: number): Uint8Array {\n  if (length == null) {\n    length = arrays.reduce((acc, curr) => acc + curr.length, 0)\n  }\n\n  const output = allocUnsafe(length)\n  let offset = 0\n\n  for (const arr of arrays) {\n    output.set(arr, offset)\n    offset += arr.length\n  }\n\n  return asUint8Array(output)\n}\n", "/**\n * @packageDocumentation\n *\n * A class that lets you do operations over a list of Uint8Arrays without\n * copying them.\n *\n * ```js\n * import { Uint8ArrayList } from 'uint8arraylist'\n *\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray()\n * // -> Uint8Array([0, 1, 2, 3, 4, 5])\n *\n * list.consume(3)\n * list.subarray()\n * // -> Uint8Array([3, 4, 5])\n *\n * // you can also iterate over the list\n * for (const buf of list) {\n *   // ..do something with `buf`\n * }\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ## Converting Uint8ArrayLists to Uint8Arrays\n *\n * There are two ways to turn a `Uint8ArrayList` into a `Uint8Array` - `.slice` and `.subarray` and one way to turn a `Uint8ArrayList` into a `Uint8ArrayList` with different contents - `.sublist`.\n *\n * ### slice\n *\n * Slice follows the same semantics as [Uint8Array.slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/slice) in that it creates a new `Uint8Array` and copies bytes into it using an optional offset & length.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.slice(0, 1)\n * // -> Uint8Array([0])\n * ```\n *\n * ### subarray\n *\n * Subarray attempts to follow the same semantics as [Uint8Array.subarray](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray/subarray) with one important different - this is a no-copy operation, unless the requested bytes span two internal buffers in which case it is a copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.subarray(0, 1)\n * // -> Uint8Array([0]) - no-copy\n *\n * list.subarray(2, 5)\n * // -> Uint8Array([2, 3, 4]) - copy\n * ```\n *\n * ### sublist\n *\n * Sublist creates and returns a new `Uint8ArrayList` that shares the underlying buffers with the original so is always a no-copy operation.\n *\n * ```js\n * const list = new Uint8ArrayList()\n * list.append(Uint8Array.from([0, 1, 2]))\n * list.append(Uint8Array.from([3, 4, 5]))\n *\n * list.sublist(0, 1)\n * // -> Uint8ArrayList([0]) - no-copy\n *\n * list.sublist(2, 5)\n * // -> Uint8ArrayList([2], [3, 4]) - no-copy\n * ```\n *\n * ## Inspiration\n *\n * Borrows liberally from [bl](https://www.npmjs.com/package/bl) but only uses native JS types.\n */\nimport { allocUnsafe, alloc } from 'uint8arrays/alloc'\nimport { concat } from 'uint8arrays/concat'\nimport { equals } from 'uint8arrays/equals'\n\nconst symbol = Symbol.for('@achingbrain/uint8arraylist')\n\nexport type Appendable = Uint8ArrayList | Uint8Array\n\nfunction findBufAndOffset (bufs: Uint8Array[], index: number): { buf: Uint8Array, index: number } {\n  if (index == null || index < 0) {\n    throw new RangeError('index is out of bounds')\n  }\n\n  let offset = 0\n\n  for (const buf of bufs) {\n    const bufEnd = offset + buf.byteLength\n\n    if (index < bufEnd) {\n      return {\n        buf,\n        index: index - offset\n      }\n    }\n\n    offset = bufEnd\n  }\n\n  throw new RangeError('index is out of bounds')\n}\n\n/**\n * Check if object is a CID instance\n *\n * @example\n *\n * ```js\n * import { isUint8ArrayList, Uint8ArrayList } from 'uint8arraylist'\n *\n * isUint8ArrayList(true) // false\n * isUint8ArrayList([]) // false\n * isUint8ArrayList(new Uint8ArrayList()) // true\n * ```\n */\nexport function isUint8ArrayList (value: any): value is Uint8ArrayList {\n  return Boolean(value?.[symbol])\n}\n\nexport class Uint8ArrayList implements Iterable<Uint8Array> {\n  private bufs: Uint8Array[]\n  public length: number\n  public readonly [symbol] = true\n\n  constructor (...data: Appendable[]) {\n    this.bufs = []\n    this.length = 0\n\n    if (data.length > 0) {\n      this.appendAll(data)\n    }\n  }\n\n  * [Symbol.iterator] (): Iterator<Uint8Array> {\n    yield * this.bufs\n  }\n\n  get byteLength (): number {\n    return this.length\n  }\n\n  /**\n   * Add one or more `bufs` to the end of this Uint8ArrayList\n   */\n  append (...bufs: Appendable[]): void {\n    this.appendAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the end of this Uint8ArrayList\n   */\n  appendAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.push(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.push(...buf.bufs)\n      } else {\n        throw new Error('Could not append value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Add one or more `bufs` to the start of this Uint8ArrayList\n   */\n  prepend (...bufs: Appendable[]): void {\n    this.prependAll(bufs)\n  }\n\n  /**\n   * Add all `bufs` to the start of this Uint8ArrayList\n   */\n  prependAll (bufs: Appendable[]): void {\n    let length = 0\n\n    for (const buf of bufs.reverse()) {\n      if (buf instanceof Uint8Array) {\n        length += buf.byteLength\n        this.bufs.unshift(buf)\n      } else if (isUint8ArrayList(buf)) {\n        length += buf.byteLength\n        this.bufs.unshift(...buf.bufs)\n      } else {\n        throw new Error('Could not prepend value, must be an Uint8Array or a Uint8ArrayList')\n      }\n    }\n\n    this.length += length\n  }\n\n  /**\n   * Read the value at `index`\n   */\n  get (index: number): number {\n    const res = findBufAndOffset(this.bufs, index)\n\n    return res.buf[res.index]\n  }\n\n  /**\n   * Set the value at `index` to `value`\n   */\n  set (index: number, value: number): void {\n    const res = findBufAndOffset(this.bufs, index)\n\n    res.buf[res.index] = value\n  }\n\n  /**\n   * Copy bytes from `buf` to the index specified by `offset`\n   */\n  write (buf: Appendable, offset: number = 0): void {\n    if (buf instanceof Uint8Array) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf[i])\n      }\n    } else if (isUint8ArrayList(buf)) {\n      for (let i = 0; i < buf.length; i++) {\n        this.set(offset + i, buf.get(i))\n      }\n    } else {\n      throw new Error('Could not write value, must be an Uint8Array or a Uint8ArrayList')\n    }\n  }\n\n  /**\n   * Remove bytes from the front of the pool\n   */\n  consume (bytes: number): void {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes)\n\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) {\n      return\n    }\n\n    // if consuming all bytes, skip iterating\n    if (bytes === this.byteLength) {\n      this.bufs = []\n      this.length = 0\n      return\n    }\n\n    while (this.bufs.length > 0) {\n      if (bytes >= this.bufs[0].byteLength) {\n        bytes -= this.bufs[0].byteLength\n        this.length -= this.bufs[0].byteLength\n        this.bufs.shift()\n      } else {\n        this.bufs[0] = this.bufs[0].subarray(bytes)\n        this.length -= bytes\n        break\n      }\n    }\n  }\n\n  /**\n   * Extracts a section of an array and returns a new array.\n   *\n   * This is a copy operation as it is with Uint8Arrays and Arrays\n   * - note this is different to the behaviour of Node Buffers.\n   */\n  slice (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a alloc from the given start and end element index.\n   *\n   * In the best case where the data extracted comes from a single Uint8Array\n   * internally this is a no-copy operation otherwise it is a copy operation.\n   */\n  subarray (beginInclusive?: number, endExclusive?: number): Uint8Array {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    if (bufs.length === 1) {\n      return bufs[0]\n    }\n\n    return concat(bufs, length)\n  }\n\n  /**\n   * Returns a allocList from the given start and end element index.\n   *\n   * This is a no-copy operation.\n   */\n  sublist (beginInclusive?: number, endExclusive?: number): Uint8ArrayList {\n    const { bufs, length } = this._subList(beginInclusive, endExclusive)\n\n    const list = new Uint8ArrayList()\n    list.length = length\n    // don't loop, just set the bufs\n    list.bufs = [...bufs]\n\n    return list\n  }\n\n  private _subList (beginInclusive?: number, endExclusive?: number): { bufs: Uint8Array[], length: number } {\n    beginInclusive = beginInclusive ?? 0\n    endExclusive = endExclusive ?? this.length\n\n    if (beginInclusive < 0) {\n      beginInclusive = this.length + beginInclusive\n    }\n\n    if (endExclusive < 0) {\n      endExclusive = this.length + endExclusive\n    }\n\n    if (beginInclusive < 0 || endExclusive > this.length) {\n      throw new RangeError('index is out of bounds')\n    }\n\n    if (beginInclusive === endExclusive) {\n      return { bufs: [], length: 0 }\n    }\n\n    if (beginInclusive === 0 && endExclusive === this.length) {\n      return { bufs: this.bufs, length: this.length }\n    }\n\n    const bufs: Uint8Array[] = []\n    let offset = 0\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      const buf = this.bufs[i]\n      const bufStart = offset\n      const bufEnd = bufStart + buf.byteLength\n\n      // for next loop\n      offset = bufEnd\n\n      if (beginInclusive >= bufEnd) {\n        // start after this buf\n        continue\n      }\n\n      const sliceStartInBuf = beginInclusive >= bufStart && beginInclusive < bufEnd\n      const sliceEndsInBuf = endExclusive > bufStart && endExclusive <= bufEnd\n\n      if (sliceStartInBuf && sliceEndsInBuf) {\n        // slice is wholly contained within this buffer\n        if (beginInclusive === bufStart && endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        const start = beginInclusive - bufStart\n        bufs.push(buf.subarray(start, start + (endExclusive - beginInclusive)))\n        break\n      }\n\n      if (sliceStartInBuf) {\n        // slice starts in this buffer\n        if (beginInclusive === 0) {\n          // requested whole buffer\n          bufs.push(buf)\n          continue\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(beginInclusive - bufStart))\n        continue\n      }\n\n      if (sliceEndsInBuf) {\n        if (endExclusive === bufEnd) {\n          // requested whole buffer\n          bufs.push(buf)\n          break\n        }\n\n        // requested part of buffer\n        bufs.push(buf.subarray(0, endExclusive - bufStart))\n        break\n      }\n\n      // slice started before this buffer and ends after it\n      bufs.push(buf)\n    }\n\n    return { bufs, length: endExclusive - beginInclusive }\n  }\n\n  indexOf (search: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n    if (!isUint8ArrayList(search) && !(search instanceof Uint8Array)) {\n      throw new TypeError('The \"value\" argument must be a Uint8ArrayList or Uint8Array')\n    }\n\n    const needle = search instanceof Uint8Array ? search : search.subarray()\n\n    offset = Number(offset ?? 0)\n\n    if (isNaN(offset)) {\n      offset = 0\n    }\n\n    if (offset < 0) {\n      offset = this.length + offset\n    }\n\n    if (offset < 0) {\n      offset = 0\n    }\n\n    if (search.length === 0) {\n      return offset > this.length ? this.length : offset\n    }\n\n    // https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\n    const M: number = needle.byteLength\n\n    if (M === 0) {\n      throw new TypeError('search must be at least 1 byte long')\n    }\n\n    // radix\n    const radix: number = 256\n    const rightmostPositions: Int32Array = new Int32Array(radix)\n\n    // position of the rightmost occurrence of the byte c in the pattern\n    for (let c: number = 0; c < radix; c++) {\n      // -1 for bytes not in pattern\n      rightmostPositions[c] = -1\n    }\n\n    for (let j = 0; j < M; j++) {\n      // rightmost position for bytes in pattern\n      rightmostPositions[needle[j]] = j\n    }\n\n    // Return offset of first match, -1 if no match\n    const right = rightmostPositions\n    const lastIndex = this.byteLength - needle.byteLength\n    const lastPatIndex = needle.byteLength - 1\n    let skip: number\n\n    for (let i = offset; i <= lastIndex; i += skip) {\n      skip = 0\n\n      for (let j = lastPatIndex; j >= 0; j--) {\n        const char: number = this.get(i + j)\n\n        if (needle[j] !== char) {\n          skip = Math.max(1, j - right[char])\n          break\n        }\n      }\n\n      if (skip === 0) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  getInt8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt8(0)\n  }\n\n  setInt8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt16(0, littleEndian)\n  }\n\n  setInt16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getInt32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getInt32(0, littleEndian)\n  }\n\n  setInt32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setInt32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigInt64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigInt64(0, littleEndian)\n  }\n\n  setBigInt64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigInt64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint8 (byteOffset: number): number {\n    const buf = this.subarray(byteOffset, byteOffset + 1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint8(0)\n  }\n\n  setUint8 (byteOffset: number, value: number): void {\n    const buf = allocUnsafe(1)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint8(0, value)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint16 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint16(0, littleEndian)\n  }\n\n  setUint16 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(2)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint16(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getUint32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getUint32(0, littleEndian)\n  }\n\n  setUint32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setUint32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getBigUint64 (byteOffset: number, littleEndian?: boolean): bigint {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getBigUint64(0, littleEndian)\n  }\n\n  setBigUint64 (byteOffset: number, value: bigint, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setBigUint64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat32 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat32(0, littleEndian)\n  }\n\n  setFloat32 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(4)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat32(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  getFloat64 (byteOffset: number, littleEndian?: boolean): number {\n    const buf = this.subarray(byteOffset, byteOffset + 8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n\n    return view.getFloat64(0, littleEndian)\n  }\n\n  setFloat64 (byteOffset: number, value: number, littleEndian?: boolean): void {\n    const buf = alloc(8)\n    const view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength)\n    view.setFloat64(0, value, littleEndian)\n\n    this.write(buf, byteOffset)\n  }\n\n  equals (other: any): other is Uint8ArrayList {\n    if (other == null) {\n      return false\n    }\n\n    if (!(other instanceof Uint8ArrayList)) {\n      return false\n    }\n\n    if (other.bufs.length !== this.bufs.length) {\n      return false\n    }\n\n    for (let i = 0; i < this.bufs.length; i++) {\n      if (!equals(this.bufs[i], other.bufs[i])) {\n        return false\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * Create a Uint8ArrayList from a pre-existing list of Uint8Arrays.  Use this\n   * method if you know the total size of all the Uint8Arrays ahead of time.\n   */\n  static fromUint8Arrays (bufs: Uint8Array[], length?: number): Uint8ArrayList {\n    const list = new Uint8ArrayList()\n    list.bufs = bufs\n\n    if (length == null) {\n      length = bufs.reduce((acc, curr) => acc + curr.byteLength, 0)\n    }\n\n    list.length = length\n\n    return list\n  }\n}\n\n/*\nfunction indexOf (needle: Uint8Array, haystack: Uint8Array, offset = 0) {\n  for (let i = offset; i < haystack.byteLength; i++) {\n    for (let j = 0; j < needle.length; j++) {\n      if (haystack[i + j] !== needle[j]) {\n        break\n      }\n\n      if (j === needle.byteLength -1) {\n        return i\n      }\n    }\n\n    if (haystack.byteLength - i < needle.byteLength) {\n      break\n    }\n  }\n\n  return -1\n}\n*/\n", "import { baseX } from './base.js'\n\nexport const base10 = baseX({\n  prefix: '9',\n  name: 'base10',\n  alphabet: '0123456789'\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base16 = rfc4648({\n  prefix: 'f',\n  name: 'base16',\n  alphabet: '0123456789abcdef',\n  bitsPerChar: 4\n})\n\nexport const base16upper = rfc4648({\n  prefix: 'F',\n  name: 'base16upper',\n  alphabet: '0123456789ABCDEF',\n  bitsPerChar: 4\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base2 = rfc4648({\n  prefix: '0',\n  name: 'base2',\n  alphabet: '01',\n  bitsPerChar: 1\n})\n", "import { from } from './base.js'\n\nconst alphabet = Array.from('\uD83D\uDE80\uD83E\uDE90\u2604\uD83D\uDEF0\uD83C\uDF0C\uD83C\uDF11\uD83C\uDF12\uD83C\uDF13\uD83C\uDF14\uD83C\uDF15\uD83C\uDF16\uD83C\uDF17\uD83C\uDF18\uD83C\uDF0D\uD83C\uDF0F\uD83C\uDF0E\uD83D\uDC09\u2600\uD83D\uDCBB\uD83D\uDDA5\uD83D\uDCBE\uD83D\uDCBF\uD83D\uDE02\u2764\uD83D\uDE0D\uD83E\uDD23\uD83D\uDE0A\uD83D\uDE4F\uD83D\uDC95\uD83D\uDE2D\uD83D\uDE18\uD83D\uDC4D\uD83D\uDE05\uD83D\uDC4F\uD83D\uDE01\uD83D\uDD25\uD83E\uDD70\uD83D\uDC94\uD83D\uDC96\uD83D\uDC99\uD83D\uDE22\uD83E\uDD14\uD83D\uDE06\uD83D\uDE44\uD83D\uDCAA\uD83D\uDE09\u263A\uD83D\uDC4C\uD83E\uDD17\uD83D\uDC9C\uD83D\uDE14\uD83D\uDE0E\uD83D\uDE07\uD83C\uDF39\uD83E\uDD26\uD83C\uDF89\uD83D\uDC9E\u270C\u2728\uD83E\uDD37\uD83D\uDE31\uD83D\uDE0C\uD83C\uDF38\uD83D\uDE4C\uD83D\uDE0B\uD83D\uDC97\uD83D\uDC9A\uD83D\uDE0F\uD83D\uDC9B\uD83D\uDE42\uD83D\uDC93\uD83E\uDD29\uD83D\uDE04\uD83D\uDE00\uD83D\uDDA4\uD83D\uDE03\uD83D\uDCAF\uD83D\uDE48\uD83D\uDC47\uD83C\uDFB6\uD83D\uDE12\uD83E\uDD2D\u2763\uD83D\uDE1C\uD83D\uDC8B\uD83D\uDC40\uD83D\uDE2A\uD83D\uDE11\uD83D\uDCA5\uD83D\uDE4B\uD83D\uDE1E\uD83D\uDE29\uD83D\uDE21\uD83E\uDD2A\uD83D\uDC4A\uD83E\uDD73\uD83D\uDE25\uD83E\uDD24\uD83D\uDC49\uD83D\uDC83\uD83D\uDE33\u270B\uD83D\uDE1A\uD83D\uDE1D\uD83D\uDE34\uD83C\uDF1F\uD83D\uDE2C\uD83D\uDE43\uD83C\uDF40\uD83C\uDF37\uD83D\uDE3B\uD83D\uDE13\u2B50\u2705\uD83E\uDD7A\uD83C\uDF08\uD83D\uDE08\uD83E\uDD18\uD83D\uDCA6\u2714\uD83D\uDE23\uD83C\uDFC3\uD83D\uDC90\u2639\uD83C\uDF8A\uD83D\uDC98\uD83D\uDE20\u261D\uD83D\uDE15\uD83C\uDF3A\uD83C\uDF82\uD83C\uDF3B\uD83D\uDE10\uD83D\uDD95\uD83D\uDC9D\uD83D\uDE4A\uD83D\uDE39\uD83D\uDDE3\uD83D\uDCAB\uD83D\uDC80\uD83D\uDC51\uD83C\uDFB5\uD83E\uDD1E\uD83D\uDE1B\uD83D\uDD34\uD83D\uDE24\uD83C\uDF3C\uD83D\uDE2B\u26BD\uD83E\uDD19\u2615\uD83C\uDFC6\uD83E\uDD2B\uD83D\uDC48\uD83D\uDE2E\uD83D\uDE46\uD83C\uDF7B\uD83C\uDF43\uD83D\uDC36\uD83D\uDC81\uD83D\uDE32\uD83C\uDF3F\uD83E\uDDE1\uD83C\uDF81\u26A1\uD83C\uDF1E\uD83C\uDF88\u274C\u270A\uD83D\uDC4B\uD83D\uDE30\uD83E\uDD28\uD83D\uDE36\uD83E\uDD1D\uD83D\uDEB6\uD83D\uDCB0\uD83C\uDF53\uD83D\uDCA2\uD83E\uDD1F\uD83D\uDE41\uD83D\uDEA8\uD83D\uDCA8\uD83E\uDD2C\u2708\uD83C\uDF80\uD83C\uDF7A\uD83E\uDD13\uD83D\uDE19\uD83D\uDC9F\uD83C\uDF31\uD83D\uDE16\uD83D\uDC76\uD83E\uDD74\u25B6\u27A1\u2753\uD83D\uDC8E\uD83D\uDCB8\u2B07\uD83D\uDE28\uD83C\uDF1A\uD83E\uDD8B\uD83D\uDE37\uD83D\uDD7A\u26A0\uD83D\uDE45\uD83D\uDE1F\uD83D\uDE35\uD83D\uDC4E\uD83E\uDD32\uD83E\uDD20\uD83E\uDD27\uD83D\uDCCC\uD83D\uDD35\uD83D\uDC85\uD83E\uDDD0\uD83D\uDC3E\uD83C\uDF52\uD83D\uDE17\uD83E\uDD11\uD83C\uDF0A\uD83E\uDD2F\uD83D\uDC37\u260E\uD83D\uDCA7\uD83D\uDE2F\uD83D\uDC86\uD83D\uDC46\uD83C\uDFA4\uD83D\uDE47\uD83C\uDF51\u2744\uD83C\uDF34\uD83D\uDCA3\uD83D\uDC38\uD83D\uDC8C\uD83D\uDCCD\uD83E\uDD40\uD83E\uDD22\uD83D\uDC45\uD83D\uDCA1\uD83D\uDCA9\uD83D\uDC50\uD83D\uDCF8\uD83D\uDC7B\uD83E\uDD10\uD83E\uDD2E\uD83C\uDFBC\uD83E\uDD75\uD83D\uDEA9\uD83C\uDF4E\uD83C\uDF4A\uD83D\uDC7C\uD83D\uDC8D\uD83D\uDCE3\uD83E\uDD42')\nconst alphabetBytesToChars: string[] = (alphabet.reduce<string[]>((p, c, i) => { p[i] = c; return p }, ([])))\nconst alphabetCharsToBytes: number[] = (alphabet.reduce<number[]>((p, c, i) => {\n  const codePoint = c.codePointAt(0)\n  if (codePoint == null) {\n    throw new Error(`Invalid character: ${c}`)\n  }\n  p[codePoint] = i\n  return p\n}, ([])))\n\nfunction encode (data: Uint8Array): string {\n  return data.reduce((p, c) => {\n    p += alphabetBytesToChars[c]\n    return p\n  }, '')\n}\n\nfunction decode (str: string): Uint8Array {\n  const byts = []\n  for (const char of str) {\n    const codePoint = char.codePointAt(0)\n    if (codePoint == null) {\n      throw new Error(`Invalid character: ${char}`)\n    }\n    const byt = alphabetCharsToBytes[codePoint]\n    if (byt == null) {\n      throw new Error(`Non-base256emoji character: ${char}`)\n    }\n    byts.push(byt)\n  }\n  return new Uint8Array(byts)\n}\n\nexport const base256emoji = from({\n  prefix: '\uD83D\uDE80',\n  name: 'base256emoji',\n  encode,\n  decode\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base64 = rfc4648({\n  prefix: 'm',\n  name: 'base64',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bitsPerChar: 6\n})\n\nexport const base64pad = rfc4648({\n  prefix: 'M',\n  name: 'base64pad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  bitsPerChar: 6\n})\n\nexport const base64url = rfc4648({\n  prefix: 'u',\n  name: 'base64url',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bitsPerChar: 6\n})\n\nexport const base64urlpad = rfc4648({\n  prefix: 'U',\n  name: 'base64urlpad',\n  alphabet: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=',\n  bitsPerChar: 6\n})\n", "import { rfc4648 } from './base.js'\n\nexport const base8 = rfc4648({\n  prefix: '7',\n  name: 'base8',\n  alphabet: '01234567',\n  bitsPerChar: 3\n})\n", "import { fromString, toString } from '../bytes.js'\nimport { from } from './base.js'\n\nexport const identity = from({\n  prefix: '\\x00',\n  name: 'identity',\n  encode: (buf) => toString(buf),\n  decode: (str) => fromString(str)\n})\n", "import type { ArrayBufferView, ByteView } from './interface.js'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nexport const name = 'json'\nexport const code = 0x0200\n\nexport function encode <T> (node: T): ByteView<T> {\n  return textEncoder.encode(JSON.stringify(node))\n}\n\nexport function decode <T> (data: ByteView<T> | ArrayBufferView<T>): T {\n  return JSON.parse(textDecoder.decode(data))\n}\n", "/* global crypto */\n\nimport { from } from './hasher.js'\n\nfunction sha (name: AlgorithmIdentifier): (data: Uint8Array) => Promise<Uint8Array> {\n  return async data => new Uint8Array(await crypto.subtle.digest(name, data))\n}\n\nexport const sha256 = from({\n  name: 'sha2-256',\n  code: 0x12,\n  encode: sha('SHA-256')\n})\n\nexport const sha512 = from({\n  name: 'sha2-512',\n  code: 0x13,\n  encode: sha('SHA-512')\n})\n", "import * as Digest from './digest.js'\nimport type { MultihashHasher } from './interface.js'\n\ntype Await<T> = Promise<T> | T\n\nconst DEFAULT_MIN_DIGEST_LENGTH = 20\n\nexport interface HasherInit <Name extends string, Code extends number> {\n  name: Name\n  code: Code\n  encode(input: Uint8Array): Await<Uint8Array>\n\n  /**\n   * The minimum length a hash is allowed to be truncated to in bytes\n   *\n   * @default 20\n   */\n  minDigestLength?: number\n\n  /**\n   * The maximum length a hash is allowed to be truncated to in bytes. If not\n   * specified it will be inferred from the length of the digest.\n   */\n  maxDigestLength?: number\n}\n\nexport function from <Name extends string, Code extends number> ({ name, code, encode, minDigestLength, maxDigestLength }: HasherInit<Name, Code>): Hasher<Name, Code> {\n  return new Hasher(name, code, encode, minDigestLength, maxDigestLength)\n}\n\nexport interface DigestOptions {\n  /**\n   * Truncate the returned digest to this number of bytes.\n   *\n   * This may cause the digest method to throw/reject if the passed value is\n   * greater than the digest length or below a threshold under which the risk of\n   * hash collisions is significant.\n   *\n   * The actual value of this threshold can depend on the hashing algorithm in\n   * use.\n   */\n  truncate?: number\n}\n\n/**\n * Hasher represents a hashing algorithm implementation that produces as\n * `MultihashDigest`.\n */\nexport class Hasher<Name extends string, Code extends number> implements MultihashHasher<Code> {\n  readonly name: Name\n  readonly code: Code\n  readonly encode: (input: Uint8Array) => Await<Uint8Array>\n  readonly minDigestLength: number\n  readonly maxDigestLength?: number\n\n  constructor (name: Name, code: Code, encode: (input: Uint8Array) => Await<Uint8Array>, minDigestLength?: number, maxDigestLength?: number) {\n    this.name = name\n    this.code = code\n    this.encode = encode\n    this.minDigestLength = minDigestLength ?? DEFAULT_MIN_DIGEST_LENGTH\n    this.maxDigestLength = maxDigestLength\n  }\n\n  digest (input: Uint8Array, options?: DigestOptions): Await<Digest.Digest<Code, number>> {\n    if (options?.truncate != null) {\n      if (options.truncate < this.minDigestLength) {\n        throw new Error(`Invalid truncate option, must be greater than or equal to ${this.minDigestLength}`)\n      }\n\n      if (this.maxDigestLength != null && options.truncate > this.maxDigestLength) {\n        throw new Error(`Invalid truncate option, must be less than or equal to ${this.maxDigestLength}`)\n      }\n    }\n\n    if (input instanceof Uint8Array) {\n      const result = this.encode(input)\n\n      if (result instanceof Uint8Array) {\n        return createDigest(result, this.code, options?.truncate)\n      }\n\n      return result.then(digest => createDigest(digest, this.code, options?.truncate))\n    } else {\n      throw Error('Unknown type, must be binary type')\n      /* c8 ignore next 1 */\n    }\n  }\n}\n\n/**\n * Create a Digest from the passed uint8array and code, optionally truncating it\n * first.\n */\nfunction createDigest <Code extends number> (digest: Uint8Array, code: Code, truncate?: number): Digest.Digest<Code, number> {\n  if (truncate != null && truncate !== digest.byteLength) {\n    if (truncate > digest.byteLength) {\n      throw new Error(`Invalid truncate option, must be less than or equal to ${digest.byteLength}`)\n    }\n\n    digest = digest.subarray(0, truncate)\n  }\n\n  return Digest.create(code, digest)\n}\n", "import * as base10 from './bases/base10.js'\nimport * as base16 from './bases/base16.js'\nimport * as base2 from './bases/base2.js'\nimport * as base256emoji from './bases/base256emoji.js'\nimport * as base32 from './bases/base32.js'\nimport * as base36 from './bases/base36.js'\nimport * as base58 from './bases/base58.js'\nimport * as base64 from './bases/base64.js'\nimport * as base8 from './bases/base8.js'\nimport * as identityBase from './bases/identity.js'\nimport * as json from './codecs/json.js'\nimport * as raw from './codecs/raw.js'\nimport * as identity from './hashes/identity.js'\nimport * as sha2 from './hashes/sha2.js'\nimport { CID, hasher, digest, varint, bytes } from './index.js'\n\nexport const bases = { ...identityBase, ...base2, ...base8, ...base10, ...base16, ...base32, ...base36, ...base58, ...base64, ...base256emoji }\nexport const hashes = { ...sha2, ...identity }\nexport const codecs = { raw, json }\n\nexport { CID, hasher, digest, varint, bytes }\n", "import { bases } from 'multiformats/basics'\nimport type { MultibaseCodec } from 'multiformats'\nimport { allocUnsafe } from '#alloc'\n\nfunction createCodec (name: string, prefix: string, encode: (buf: Uint8Array) => string, decode: (str: string) => Uint8Array): MultibaseCodec<any> {\n  return {\n    name,\n    prefix,\n    encoder: {\n      name,\n      prefix,\n      encode\n    },\n    decoder: {\n      decode\n    }\n  }\n}\n\nconst string = createCodec('utf8', 'u', (buf) => {\n  const decoder = new TextDecoder('utf8')\n  return 'u' + decoder.decode(buf)\n}, (str) => {\n  const encoder = new TextEncoder()\n  return encoder.encode(str.substring(1))\n})\n\nconst ascii = createCodec('ascii', 'a', (buf) => {\n  let string = 'a'\n\n  for (let i = 0; i < buf.length; i++) {\n    string += String.fromCharCode(buf[i])\n  }\n  return string\n}, (str) => {\n  str = str.substring(1)\n  const buf = allocUnsafe(str.length)\n\n  for (let i = 0; i < str.length; i++) {\n    buf[i] = str.charCodeAt(i)\n  }\n\n  return buf\n})\n\nexport type SupportedEncodings = 'utf8' | 'utf-8' | 'hex' | 'latin1' | 'ascii' | 'binary' | keyof typeof bases\n\nconst BASES: Record<SupportedEncodings, MultibaseCodec<any>> = {\n  utf8: string,\n  'utf-8': string,\n  hex: bases.base16,\n  latin1: ascii,\n  ascii,\n  binary: ascii,\n\n  ...bases\n}\n\nexport default BASES\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Create a `Uint8Array` from the passed string\n *\n * Supports `utf8`, `utf-8`, `hex`, and any encoding supported by the multiformats module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function fromString (string: string, encoding: SupportedEncodings = 'utf8'): Uint8Array {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // add multibase prefix\n  return base.decoder.decode(`${base.prefix}${string}`) // eslint-disable-line @typescript-eslint/restrict-template-expressions\n}\n", "import bases, { type SupportedEncodings } from './util/bases.js'\n\nexport type { SupportedEncodings }\n\n/**\n * Turns a `Uint8Array` into a string.\n *\n * Supports `utf8`, `utf-8` and any encoding supported by the multibase module.\n *\n * Also `ascii` which is similar to node's 'binary' encoding.\n */\nexport function toString (array: Uint8Array, encoding: SupportedEncodings = 'utf8'): string {\n  const base = bases[encoding]\n\n  if (base == null) {\n    throw new Error(`Unsupported encoding \"${encoding}\"`)\n  }\n\n  // strip multibase prefix\n  return base.encoder.encode(array).substring(1)\n}\n", "import { Uint8ArrayList } from 'uint8arraylist'\n\ninterface Context {\n  offset: number\n}\n\nconst TAG_MASK = parseInt('11111', 2)\nconst LONG_LENGTH_MASK = parseInt('10000000', 2)\nconst LONG_LENGTH_BYTES_MASK = parseInt('01111111', 2)\n\ninterface Decoder {\n  (buf: Uint8Array, context: Context): any\n}\n\nconst decoders: Record<number, Decoder> = {\n  0x0: readSequence,\n  0x1: readSequence,\n  0x2: readInteger,\n  0x3: readBitString,\n  0x4: readOctetString,\n  0x5: readNull,\n  0x6: readObjectIdentifier,\n  0x10: readSequence,\n  0x16: readSequence,\n  0x30: readSequence\n}\n\nexport function decodeDer (buf: Uint8Array, context: Context = { offset: 0 }): any {\n  const tag = buf[context.offset] & TAG_MASK\n  context.offset++\n\n  if (decoders[tag] != null) {\n    return decoders[tag](buf, context)\n  }\n\n  throw new Error('No decoder for tag ' + tag)\n}\n\nfunction readLength (buf: Uint8Array, context: Context): number {\n  let length = 0\n\n  if ((buf[context.offset] & LONG_LENGTH_MASK) === LONG_LENGTH_MASK) {\n    // long length\n    const count = buf[context.offset] & LONG_LENGTH_BYTES_MASK\n    let str = '0x'\n    context.offset++\n\n    for (let i = 0; i < count; i++, context.offset++) {\n      str += buf[context.offset].toString(16).padStart(2, '0')\n    }\n\n    length = parseInt(str, 16)\n  } else {\n    length = buf[context.offset]\n    context.offset++\n  }\n\n  return length\n}\n\nfunction readSequence (buf: Uint8Array, context: Context): any[] {\n  readLength(buf, context)\n  const entries: any[] = []\n\n  while (true) {\n    if (context.offset >= buf.byteLength) {\n      break\n    }\n\n    const result = decodeDer(buf, context)\n\n    if (result === null) {\n      break\n    }\n\n    entries.push(result)\n  }\n\n  return entries\n}\n\nfunction readInteger (buf: Uint8Array, context: Context): Uint8Array {\n  const length = readLength(buf, context)\n  const start = context.offset\n  const end = context.offset + length\n\n  const vals: number[] = []\n\n  for (let i = start; i < end; i++) {\n    if (i === start && buf[i] === 0) {\n      continue\n    }\n\n    vals.push(buf[i])\n  }\n\n  context.offset += length\n\n  return Uint8Array.from(vals)\n}\n\nfunction readObjectIdentifier (buf: Uint8Array, context: Context): string {\n  const count = readLength(buf, context)\n  const finalOffset = context.offset + count\n\n  const byte = buf[context.offset]\n  context.offset++\n\n  let val1 = 0\n  let val2 = 0\n\n  if (byte < 40) {\n    val1 = 0\n    val2 = byte\n  } else if (byte < 80) {\n    val1 = 1\n    val2 = byte - 40\n  } else {\n    val1 = 2\n    val2 = byte - 80\n  }\n\n  let oid = `${val1}.${val2}`\n  let num: number[] = []\n\n  while (context.offset < finalOffset) {\n    const byte = buf[context.offset]\n    context.offset++\n\n    // remove msb\n    num.push(byte & 0b01111111)\n\n    if (byte < 128) {\n      num.reverse()\n\n      // reached the end of the encoding\n      let val = 0\n\n      for (let i = 0; i < num.length; i++) {\n        val += num[i] << (i * 7)\n      }\n\n      oid += `.${val}`\n      num = []\n    }\n  }\n\n  return oid\n}\n\nfunction readNull (buf: Uint8Array, context: Context): null {\n  context.offset++\n\n  return null\n}\n\nfunction readBitString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const unusedBits = buf[context.offset]\n  context.offset++\n  const bytes = buf.subarray(context.offset, context.offset + length - 1)\n  context.offset += length\n\n  if (unusedBits !== 0) {\n    // need to shift all bytes along by this many bits\n    throw new Error('Unused bits in bit string is unimplemented')\n  }\n\n  return bytes\n}\n\nfunction readOctetString (buf: Uint8Array, context: Context): any {\n  const length = readLength(buf, context)\n  const bytes = buf.subarray(context.offset, context.offset + length)\n  context.offset += length\n\n  return bytes\n}\n\nfunction encodeNumber (value: number): Uint8ArrayList {\n  let number = value.toString(16)\n\n  if (number.length % 2 === 1) {\n    number = '0' + number\n  }\n\n  const array = new Uint8ArrayList()\n\n  for (let i = 0; i < number.length; i += 2) {\n    array.append(Uint8Array.from([parseInt(`${number[i]}${number[i + 1]}`, 16)]))\n  }\n\n  return array\n}\n\nfunction encodeLength (bytes: { byteLength: number }): Uint8Array | Uint8ArrayList {\n  if (bytes.byteLength < 128) {\n    return Uint8Array.from([bytes.byteLength])\n  }\n\n  // long length\n  const length = encodeNumber(bytes.byteLength)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([\n      length.byteLength | LONG_LENGTH_MASK\n    ]),\n    length\n  )\n}\n\nexport function encodeInteger (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  const contents = new Uint8ArrayList()\n\n  const mask = 0b10000000\n  const positive = (value.subarray()[0] & mask) === mask\n\n  if (positive) {\n    contents.append(Uint8Array.from([0]))\n  }\n\n  contents.append(value)\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x02]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeBitString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  // unused bits is always 0 with full-byte-only values\n  const unusedBits = Uint8Array.from([0])\n\n  const contents = new Uint8ArrayList(\n    unusedBits,\n    value\n  )\n\n  return new Uint8ArrayList(\n    Uint8Array.from([0x03]),\n    encodeLength(contents),\n    contents\n  )\n}\n\nexport function encodeOctetString (value: Uint8Array | Uint8ArrayList): Uint8ArrayList {\n  return new Uint8ArrayList(\n    Uint8Array.from([0x04]),\n    encodeLength(value),\n    value\n  )\n}\n\nexport function encodeSequence (values: Array<Uint8Array | Uint8ArrayList>, tag = 0x30): Uint8ArrayList {\n  const output = new Uint8ArrayList()\n\n  for (const buf of values) {\n    output.append(\n      buf\n    )\n  }\n\n  return new Uint8ArrayList(\n    Uint8Array.from([tag]),\n    encodeLength(output),\n    output\n  )\n}\n", "import type { JWKKeyPair } from '../interface.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport type Curve = 'P-256' | 'P-384' | 'P-521'\n\nexport const ECDSA_P_256_OID = '1.2.840.10045.3.1.7'\nexport const ECDSA_P_384_OID = '1.3.132.0.34'\nexport const ECDSA_P_521_OID = '1.3.132.0.35'\n\nexport async function generateECDSAKey (curve: Curve = 'P-256'): Promise<JWKKeyPair> {\n  const keyPair = await crypto.subtle.generateKey({\n    name: 'ECDSA',\n    namedCurve: curve\n  }, true, ['sign', 'verify'])\n\n  return {\n    publicKey: await crypto.subtle.exportKey('jwk', keyPair.publicKey),\n    privateKey: await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n  }\n}\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<Uint8Array> {\n  const privateKey = await crypto.subtle.importKey('jwk', key, {\n    name: 'ECDSA',\n    namedCurve: key.crv ?? 'P-256'\n  }, false, ['sign'])\n  options?.signal?.throwIfAborted()\n\n  const signature = await crypto.subtle.sign({\n    name: 'ECDSA',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, privateKey, msg.subarray())\n  options?.signal?.throwIfAborted()\n\n  return new Uint8Array(signature, 0, signature.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<boolean> {\n  const publicKey = await crypto.subtle.importKey('jwk', key, {\n    name: 'ECDSA',\n    namedCurve: key.crv ?? 'P-256'\n  }, false, ['verify'])\n  options?.signal?.throwIfAborted()\n\n  const result = await crypto.subtle.verify({\n    name: 'ECDSA',\n    hash: {\n      name: 'SHA-256'\n    }\n  }, publicKey, sig, msg.subarray())\n  options?.signal?.throwIfAborted()\n\n  return result\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { decodeDer, encodeBitString, encodeInteger, encodeOctetString, encodeSequence } from '../rsa/der.js'\nimport { ECDSAPrivateKey as ECDSAPrivateKeyClass, ECDSAPublicKey as ECDSAPublicKeyClass } from './ecdsa.js'\nimport { generateECDSAKey } from './index.js'\nimport type { Curve } from '../ecdh/index.js'\nimport type { ECDSAPublicKey, ECDSAPrivateKey } from '@libp2p/interface'\n\n// 1.2.840.10045.3.1.7 prime256v1 (ANSI X9.62 named elliptic curve)\nconst OID_256 = Uint8Array.from([0x06, 0x08, 0x2A, 0x86, 0x48, 0xCE, 0x3D, 0x03, 0x01, 0x07])\n// 1.3.132.0.34 secp384r1 (SECG (Certicom) named elliptic curve)\nconst OID_384 = Uint8Array.from([0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x22])\n// 1.3.132.0.35 secp521r1 (SECG (Certicom) named elliptic curve)\nconst OID_521 = Uint8Array.from([0x06, 0x05, 0x2B, 0x81, 0x04, 0x00, 0x23])\n\nconst P_256_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-256'\n}\n\nconst P_384_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-384'\n}\n\nconst P_521_KEY_JWK = {\n  ext: true,\n  kty: 'EC',\n  crv: 'P-521'\n}\n\nconst P_256_KEY_LENGTH = 32\nconst P_384_KEY_LENGTH = 48\nconst P_521_KEY_LENGTH = 66\n\nexport function unmarshalECDSAPrivateKey (bytes: Uint8Array): ECDSAPrivateKey {\n  const message = decodeDer(bytes)\n\n  return pkiMessageToECDSAPrivateKey(message)\n}\n\nexport function pkiMessageToECDSAPrivateKey (message: any): ECDSAPrivateKey {\n  const privateKey = message[1]\n  const d = uint8ArrayToString(privateKey, 'base64url')\n  const coordinates: Uint8Array = message[2][1][0]\n  const offset = 1\n  let x: string\n  let y: string\n\n  if (privateKey.byteLength === P_256_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_256_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_256_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  if (privateKey.byteLength === P_384_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_384_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_384_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  if (privateKey.byteLength === P_521_KEY_LENGTH) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_521_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPrivateKeyClass({\n      ...P_521_KEY_JWK,\n      key_ops: ['sign'],\n      d,\n      x,\n      y\n    })\n  }\n\n  throw new InvalidParametersError(`Private key length was wrong length, got ${privateKey.byteLength}, expected 32, 48 or 66`)\n}\n\nexport function unmarshalECDSAPublicKey (bytes: Uint8Array): ECDSAPublicKey {\n  const message = decodeDer(bytes)\n\n  return pkiMessageToECDSAPublicKey(message)\n}\n\nexport function pkiMessageToECDSAPublicKey (message: any): ECDSAPublicKey {\n  const coordinates = message[1][1][0]\n  const offset = 1\n  let x: string\n  let y: string\n\n  if (coordinates.byteLength === ((P_256_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_256_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_256_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_256_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  if (coordinates.byteLength === ((P_384_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_384_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_384_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_384_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  if (coordinates.byteLength === ((P_521_KEY_LENGTH * 2) + 1)) {\n    x = uint8ArrayToString(coordinates.subarray(offset, offset + P_521_KEY_LENGTH), 'base64url')\n    y = uint8ArrayToString(coordinates.subarray(offset + P_521_KEY_LENGTH), 'base64url')\n\n    return new ECDSAPublicKeyClass({\n      ...P_521_KEY_JWK,\n      key_ops: ['verify'],\n      x,\n      y\n    })\n  }\n\n  throw new InvalidParametersError(`coordinates were wrong length, got ${coordinates.byteLength}, expected 65, 97 or 133`)\n}\n\nexport function privateKeyToPKIMessage (privateKey: JsonWebKey): Uint8Array {\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([1])), // header\n    encodeOctetString(uint8ArrayFromString(privateKey.d ?? '', 'base64url')), // body\n    encodeSequence([ // PKIProtection\n      getOID(privateKey.crv)\n    ], 0xA0),\n    encodeSequence([ // extraCerts\n      encodeBitString(\n        new Uint8ArrayList(\n          Uint8Array.from([0x04]),\n          uint8ArrayFromString(privateKey.x ?? '', 'base64url'),\n          uint8ArrayFromString(privateKey.y ?? '', 'base64url')\n        )\n      )\n    ], 0xA1)\n  ]).subarray()\n}\n\nexport function publicKeyToPKIMessage (publicKey: JsonWebKey): Uint8Array {\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([1])), // header\n    encodeSequence([ // PKIProtection\n      getOID(publicKey.crv)\n    ], 0xA0),\n    encodeSequence([ // extraCerts\n      encodeBitString(\n        new Uint8ArrayList(\n          Uint8Array.from([0x04]),\n          uint8ArrayFromString(publicKey.x ?? '', 'base64url'),\n          uint8ArrayFromString(publicKey.y ?? '', 'base64url')\n        )\n      )\n    ], 0xA1)\n  ]).subarray()\n}\n\nfunction getOID (curve?: string): Uint8Array {\n  if (curve === 'P-256') {\n    return OID_256\n  }\n\n  if (curve === 'P-384') {\n    return OID_384\n  }\n\n  if (curve === 'P-521') {\n    return OID_521\n  }\n\n  throw new InvalidParametersError(`Invalid curve ${curve}`)\n}\n\nexport async function generateECDSAKeyPair (curve: Curve = 'P-256'): Promise<ECDSAPrivateKey> {\n  const key = await generateECDSAKey(curve)\n\n  return new ECDSAPrivateKeyClass(key.privateKey)\n}\n\nexport function ensureECDSAKey (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { privateKeyToPKIMessage, publicKeyToPKIMessage } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { ECDSAPublicKey as ECDSAPublicKeyInterface, ECDSAPrivateKey as ECDSAPrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class ECDSAPublicKey implements ECDSAPublicKeyInterface {\n  public readonly type = 'ECDSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n\n  constructor (jwk: JsonWebKey) {\n    this.jwk = jwk\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = publicKeyToPKIMessage(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  async verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): Promise<boolean> {\n    return hashAndVerify(this.jwk, sig, data, options)\n  }\n}\n\nexport class ECDSAPrivateKey implements ECDSAPrivateKeyInterface {\n  public readonly type = 'ECDSA'\n  public readonly jwk: JsonWebKey\n  public readonly publicKey: ECDSAPublicKey\n  private _raw?: Uint8Array\n\n  constructor (jwk: JsonWebKey) {\n    this.jwk = jwk\n    this.publicKey = new ECDSAPublicKey({\n      crv: jwk.crv,\n      ext: jwk.ext,\n      key_ops: ['verify'],\n      kty: 'EC',\n      x: jwk.x,\n      y: jwk.y\n    })\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = privateKeyToPKIMessage(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  async sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<Uint8Array> {\n    return hashAndSign(this.jwk, message, options)\n  }\n}\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number, title: string = ''): void {\n  if (!Number.isSafeInteger(n) || n < 0) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(`${prefix}expected integer >= 0, got ${n}`);\n  }\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n/** Asserts something is hash */\nexport function ahash(h: CHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash must wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out, undefined, 'digestInto() output');\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('\"digestInto() output\" expected to be of length >=' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * Built-in doesn't validate input to be string: we do the check.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput, errorTitle = ''): Uint8Array {\n  if (typeof data === 'string') return utf8ToBytes(data);\n  return abytes(data, undefined, errorTitle);\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\n/** Merges default options and passed options. */\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options must be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Common interface for all hashes. */\nexport interface Hash<T> {\n  blockLen: number; // Bytes per block\n  outputLen: number; // Bytes in output\n  update(buf: Uint8Array): this;\n  digestInto(buf: Uint8Array): void;\n  digest(): Uint8Array;\n  destroy(): void;\n  _cloneInto(to?: T): T;\n  clone(): T;\n}\n\n/** PseudoRandom (number) Generator */\nexport interface PRG {\n  addEntropy(seed: Uint8Array): void;\n  randomBytes(length: number): Uint8Array;\n  clean(): void;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash constructor */\nexport type HasherCons<T, Opts = undefined> = Opts extends undefined ? () => T : (opts?: Opts) => T;\n/** Optional hash params. */\nexport type HashInfo = {\n  oid?: Uint8Array; // DER encoded OID in bytes\n};\n/** Hash function */\nexport type CHash<T extends Hash<T> = Hash<any>, Opts = undefined> = {\n  outputLen: number;\n  blockLen: number;\n} & HashInfo &\n  (Opts extends undefined\n    ? {\n        (msg: Uint8Array): Uint8Array;\n        create(): T;\n      }\n    : {\n        (msg: Uint8Array, opts?: Opts): Uint8Array;\n        create(opts?: Opts): T;\n      });\n/** XOF with output */\nexport type CHashXOF<T extends HashXOF<T> = HashXOF<any>, Opts = undefined> = CHash<T, Opts>;\n\n/** Creates function with outputLen, blockLen, create properties from a class constructor. */\nexport function createHasher<T extends Hash<T>, Opts = undefined>(\n  hashCons: HasherCons<T, Opts>,\n  info: HashInfo = {}\n): CHash<T, Opts> {\n  const hashC: any = (msg: Uint8Array, opts?: Opts) => hashCons(opts).update(msg).digest();\n  const tmp = hashCons(undefined);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: Opts) => hashCons(opts);\n  Object.assign(hashC, info);\n  return Object.freeze(hashC);\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  const cr = typeof globalThis === 'object' ? (globalThis as any).crypto : null;\n  if (typeof cr?.getRandomValues !== 'function')\n    throw new Error('crypto.getRandomValues must be defined');\n  return cr.getRandomValues(new Uint8Array(bytesLength));\n}\n\n/** Creates OID opts for NIST hashes, with prefix 06 09 60 86 48 01 65 03 04 02. */\nexport const oidNist = (suffix: number): Required<HashInfo> => ({\n  oid: Uint8Array.from([0x06, 0x09, 0x60, 0x86, 0x48, 0x01, 0x65, 0x03, 0x04, 0x02, suffix]),\n});\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { abytes, aexists, aoutput, clean, createView, type Hash } from './utils.ts';\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> implements Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Uint8Array): this {\n    aexists(this);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    view.setBigUint64(blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which must be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen must be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to as unknown as any;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://www.rfc-editor.org/rfc/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, oidNist, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n\n/** Internal 32-byte base SHA2 hash class. */\nabstract class SHA2_32B<T extends SHA2_32B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected abstract A: number;\n  protected abstract B: number;\n  protected abstract C: number;\n  protected abstract D: number;\n  protected abstract E: number;\n  protected abstract F: number;\n  protected abstract G: number;\n  protected abstract H: number;\n\n  constructor(outputLen: number) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** Internal SHA2-256 hash class. */\nexport class _SHA256 extends SHA2_32B<_SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n  constructor() {\n    super(32);\n  }\n}\n\n/** Internal SHA2-224 hash class. */\nexport class _SHA224 extends SHA2_32B<_SHA224> {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\n/** Internal 64-byte base SHA2 hash class. */\nabstract class SHA2_64B<T extends SHA2_64B<T>> extends HashMD<T> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected abstract Ah: number;\n  protected abstract Al: number;\n  protected abstract Bh: number;\n  protected abstract Bl: number;\n  protected abstract Ch: number;\n  protected abstract Cl: number;\n  protected abstract Dh: number;\n  protected abstract Dl: number;\n  protected abstract Eh: number;\n  protected abstract El: number;\n  protected abstract Fh: number;\n  protected abstract Fl: number;\n  protected abstract Gh: number;\n  protected abstract Gl: number;\n  protected abstract Hh: number;\n  protected abstract Hl: number;\n\n  constructor(outputLen: number) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\n/** Internal SHA2-512 hash class. */\nexport class _SHA512 extends SHA2_64B<_SHA512> {\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor() {\n    super(64);\n  }\n}\n\n/** Internal SHA2-384 hash class. */\nexport class _SHA384 extends SHA2_64B<_SHA384> {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\n/** Internal SHA2-512/224 hash class. */\nexport class _SHA512_224 extends SHA2_64B<_SHA512_224> {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\n/** Internal SHA2-512/256 hash class. */\nexport class _SHA512_256 extends SHA2_64B<_SHA512_256> {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634. In JS it's the fastest: even faster than Blake3. Some info:\n *\n * - Trying 2^128 hashes would get 50% chance of collision, using birthday attack.\n * - BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n * - Each sha256 hash is executing 2^18 bit operations.\n * - Good 2024 ASICs can do 200Th/sec with 3500 watts of power, corresponding to 2^36 hashes/joule.\n */\nexport const sha256: CHash<_SHA256> = /* @__PURE__ */ createHasher(\n  () => new _SHA256(),\n  /* @__PURE__ */ oidNist(0x01)\n);\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash<_SHA224> = /* @__PURE__ */ createHasher(\n  () => new _SHA224(),\n  /* @__PURE__ */ oidNist(0x04)\n);\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash<_SHA512> = /* @__PURE__ */ createHasher(\n  () => new _SHA512(),\n  /* @__PURE__ */ oidNist(0x03)\n);\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash<_SHA384> = /* @__PURE__ */ createHasher(\n  () => new _SHA384(),\n  /* @__PURE__ */ oidNist(0x02)\n);\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash<_SHA512_256> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_256(),\n  /* @__PURE__ */ oidNist(0x06)\n);\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash<_SHA512_224> = /* @__PURE__ */ createHasher(\n  () => new _SHA512_224(),\n  /* @__PURE__ */ oidNist(0x05)\n);\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  anumber,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\n\nexport type CHash = {\n  (message: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array) => Uint8Array;\nexport function abool(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nfunction abignumber(n: number | bigint) {\n  if (typeof n === 'bigint') {\n    if (!isPosBig(n)) throw new Error('positive bigint expected, got ' + n);\n  } else anumber(n);\n  return n;\n}\n\nexport function asafenumber(value: number, title: string = ''): void {\n  if (!Number.isSafeInteger(value)) {\n    const prefix = title && `\"${title}\" `;\n    throw new Error(prefix + 'expected safe integer, got type=' + typeof value);\n  }\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = abignumber(num).toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(copyBytes(abytes_(bytes)).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  anumber(len);\n  n = abignumber(n);\n  const res = hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n  if (res.length !== len) throw new Error('number too large');\n  return res;\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(abignumber(n)));\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as `TextEncoder` for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, message: Uint8Array) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  anumber(hashLen, 'hashLen');\n  anumber(qByteLen, 'qByteLen');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  const u8n = (len: number): Uint8Array => new Uint8Array(len); // creates Uint8Array\n  const NULL = Uint8Array.of();\n  const byte0 = Uint8Array.of(0x00);\n  const byte1 = Uint8Array.of(0x01);\n  const _maxDrbgIters = 1000;\n\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...msgs: Uint8Array[]) => hmacFn(k, concatBytes_(v, ...msgs)); // hmac(k)(v, ...values)\n  const reseed = (seed: Uint8Array = NULL) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(byte0, seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(byte1, seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= _maxDrbgIters) throw new Error('drbg: tried max amount of iterations');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\nexport function validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string> = {},\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  const iter = (f: typeof fields, isOpt: boolean) =>\n    Object.entries(f).forEach(([k, v]) => checkField(k, v, isOpt));\n  iter(fields, false);\n  iter(optFields, true);\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n\nexport interface CryptoKeys {\n  lengths: { seed?: number; public?: number; secret?: number };\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n}\n\n/** Generic interface for signatures. Has keygen, sign and verify. */\nexport interface Signer extends CryptoKeys {\n  // Interfaces are fun. We cannot just add new fields without copying old ones.\n  lengths: {\n    seed?: number;\n    public?: number;\n    secret?: number;\n    signRand?: number;\n    signature?: number;\n  };\n  sign: (msg: Uint8Array, secretKey: Uint8Array) => Uint8Array;\n  verify: (sig: Uint8Array, msg: Uint8Array, publicKey: Uint8Array) => boolean;\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes,\n  anumber,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from '../utils.ts';\n\n// Numbers aren't used in x25519 / x448 builds\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = /* @__PURE__ */ BigInt(1), _2n = /* @__PURE__ */ BigInt(2);\n// prettier-ignore\nconst _3n = /* @__PURE__ */ BigInt(3), _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5);\n// prettier-ignore\nconst _7n = /* @__PURE__ */ BigInt(7), _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9);\nconst _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i) \u2261 1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P \u2261 3 (mod 4)\n * 2. P \u2261 5 (mod 8)\n * 3. P \u2261 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P \u2261 3 (mod 4) => \u221An = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P \u2261 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P \u2261 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  BYTES: number;\n  BITS: number;\n  isLE: boolean;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) \u2261 1    if a is a square (mod p), quadratic residue\n * * (a | p) \u2261 -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) \u2261 0    if a \u2261 0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  isLE: boolean;\n  BITS: number;\n  sqrt: SqrtFn;\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n}>;\nclass _Field implements IField<bigint> {\n  readonly ORDER: bigint;\n  readonly BITS: number;\n  readonly BYTES: number;\n  readonly isLE: boolean;\n  readonly ZERO = _0n;\n  readonly ONE = _1n;\n  readonly _lengths?: number[];\n  private _sqrt: ReturnType<typeof FpSqrt> | undefined; // cached sqrt\n  private readonly _mod?: boolean;\n  constructor(ORDER: bigint, opts: FieldOpts = {}) {\n    if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    let _nbitLength: number | undefined = undefined;\n    this.isLE = false;\n    if (opts != null && typeof opts === 'object') {\n      if (typeof opts.BITS === 'number') _nbitLength = opts.BITS;\n      if (typeof opts.sqrt === 'function') this.sqrt = opts.sqrt;\n      if (typeof opts.isLE === 'boolean') this.isLE = opts.isLE;\n      if (opts.allowedLengths) this._lengths = opts.allowedLengths?.slice();\n      if (typeof opts.modFromBytes === 'boolean') this._mod = opts.modFromBytes;\n    }\n    const { nBitLength, nByteLength } = nLength(ORDER, _nbitLength);\n    if (nByteLength > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    this.ORDER = ORDER;\n    this.BITS = nBitLength;\n    this.BYTES = nByteLength;\n    this._sqrt = undefined;\n    Object.preventExtensions(this);\n  }\n\n  create(num: bigint) {\n    return mod(num, this.ORDER);\n  }\n  isValid(num: bigint) {\n    if (typeof num !== 'bigint')\n      throw new Error('invalid field element: expected bigint, got ' + typeof num);\n    return _0n <= num && num < this.ORDER; // 0 is valid element, but it's not invertible\n  }\n  is0(num: bigint) {\n    return num === _0n;\n  }\n  // is valid and invertible\n  isValidNot0(num: bigint) {\n    return !this.is0(num) && this.isValid(num);\n  }\n  isOdd(num: bigint) {\n    return (num & _1n) === _1n;\n  }\n  neg(num: bigint) {\n    return mod(-num, this.ORDER);\n  }\n  eql(lhs: bigint, rhs: bigint) {\n    return lhs === rhs;\n  }\n\n  sqr(num: bigint) {\n    return mod(num * num, this.ORDER);\n  }\n  add(lhs: bigint, rhs: bigint) {\n    return mod(lhs + rhs, this.ORDER);\n  }\n  sub(lhs: bigint, rhs: bigint) {\n    return mod(lhs - rhs, this.ORDER);\n  }\n  mul(lhs: bigint, rhs: bigint) {\n    return mod(lhs * rhs, this.ORDER);\n  }\n  pow(num: bigint, power: bigint): bigint {\n    return FpPow(this, num, power);\n  }\n  div(lhs: bigint, rhs: bigint) {\n    return mod(lhs * invert(rhs, this.ORDER), this.ORDER);\n  }\n\n  // Same as above, but doesn't normalize\n  sqrN(num: bigint) {\n    return num * num;\n  }\n  addN(lhs: bigint, rhs: bigint) {\n    return lhs + rhs;\n  }\n  subN(lhs: bigint, rhs: bigint) {\n    return lhs - rhs;\n  }\n  mulN(lhs: bigint, rhs: bigint) {\n    return lhs * rhs;\n  }\n\n  inv(num: bigint) {\n    return invert(num, this.ORDER);\n  }\n  sqrt(num: bigint): bigint {\n    // Caching _sqrt speeds up sqrt9mod16 by 5x and tonneli-shanks by 10%\n    if (!this._sqrt) this._sqrt = FpSqrt(this.ORDER);\n    return this._sqrt(this, num);\n  }\n  toBytes(num: bigint) {\n    return this.isLE ? numberToBytesLE(num, this.BYTES) : numberToBytesBE(num, this.BYTES);\n  }\n  fromBytes(bytes: Uint8Array, skipValidation = false) {\n    abytes(bytes);\n    const { _lengths: allowedLengths, BYTES, isLE, ORDER, _mod: modFromBytes } = this;\n    if (allowedLengths) {\n      if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n        throw new Error(\n          'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n        );\n      }\n      const padded = new Uint8Array(BYTES);\n      // isLE add 0 to right, !isLE to the left.\n      padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n      bytes = padded;\n    }\n    if (bytes.length !== BYTES)\n      throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n    let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    if (modFromBytes) scalar = mod(scalar, ORDER);\n    if (!skipValidation)\n      if (!this.isValid(scalar))\n        throw new Error('invalid field element: outside of range 0..ORDER');\n    // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n    // protocol may allow non-reduced scalar that reduced later or changed some other way.\n    return scalar;\n  }\n  // TODO: we don't need it here, move out to separate fn\n  invertBatch(lst: bigint[]): bigint[] {\n    return FpInvertBatch(this, lst);\n  }\n  // We can't move this out because Fp6, Fp12 implement it\n  // and it's unclear what to return in there.\n  cmov(a: bigint, b: bigint, condition: boolean) {\n    return condition ? b : a;\n  }\n}\n\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER: bigint, opts: FieldOpts = {}): Readonly<FpField> {\n  return new _Field(ORDER, opts);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.Point.Fn.ORDER)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  abytes(key);\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, type Signer } from '../utils.ts';\nimport { Field, FpInvertBatch, validateField, type IField } from './modular.ts';\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { Z?: never };\n\n// We can't \"abstract out\" coordinates (X, Y, Z; and T in Edwards): argument names of constructor\n// are not accessible. See Typescript gh-56093, gh-41594.\n//\n// We have to use recursive types, so it will return actual point, not constained `CurvePoint`.\n// If, at any point, P is `any`, it will erase all types and replace it\n// with `any`, because of recursion, `any implements CurvePoint`,\n// but we lose all constrains on methods.\n\n/** Base interface for all elliptic curve Points. */\nexport interface CurvePoint<F, P extends CurvePoint<F, P>> {\n  /** Affine x coordinate. Different from projective / extended X coordinate. */\n  x: F;\n  /** Affine y coordinate. Different from projective / extended Y coordinate. */\n  y: F;\n  Z?: F;\n  double(): P;\n  negate(): P;\n  add(other: P): P;\n  subtract(other: P): P;\n  equals(other: P): boolean;\n  multiply(scalar: bigint): P;\n  assertValidity(): void;\n  clearCofactor(): P;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  isSmallOrder(): boolean;\n  multiplyUnsafe(scalar: bigint): P;\n  /**\n   * Massively speeds up `p.multiply(n)` by using precompute tables (caching). See {@link wNAF}.\n   * @param isLazy calculate cache now. Default (true) ensures it's deferred to first `multiply()`\n   */\n  precompute(windowSize?: number, isLazy?: boolean): P;\n  /** Converts point to 2D xy affine coordinates */\n  toAffine(invertedZ?: F): AffinePoint<F>;\n  toBytes(): Uint8Array;\n  toHex(): string;\n}\n\n/** Base interface for all elliptic curve Point constructors. */\nexport interface CurvePointCons<P extends CurvePoint<any, P>> {\n  [Symbol.hasInstance]: (item: unknown) => boolean;\n  BASE: P;\n  ZERO: P;\n  /** Field for basic curve math */\n  Fp: IField<P_F<P>>;\n  /** Scalar field, for scalars in multiply and others */\n  Fn: IField<bigint>;\n  /** Creates point from x, y. Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<P_F<P>>): P;\n  fromBytes(bytes: Uint8Array): P;\n  fromHex(hex: string): P;\n}\n\n// Type inference helpers: PC - PointConstructor, P - Point, Fp - Field element\n// Short names, because we use them a lot in result types:\n// * we can't do 'P = GetCurvePoint<PC>': this is default value and doesn't constrain anything\n// * we can't do 'type X = GetCurvePoint<PC>': it won't be accesible for arguments/return types\n// * `CurvePointCons<P extends CurvePoint<any, P>>` constraints from interface definition\n//   won't propagate, if `PC extends CurvePointCons<any>`: the P would be 'any', which is incorrect\n// * PC could be super specific with super specific P, which implements CurvePoint<any, P>.\n//   this means we need to do stuff like\n//   `function test<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(`\n//   if we want type safety around P, otherwise PC_P<PC> will be any\n\n/** Returns Fp type from Point (P_F<P> == P.F) */\nexport type P_F<P extends CurvePoint<any, P>> = P extends CurvePoint<infer F, P> ? F : never;\n/** Returns Fp type from PointCons (PC_F<PC> == PC.P.F) */\nexport type PC_F<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['Fp']['ZERO'];\n/** Returns Point type from PointCons (PC_P<PC> == PC.P) */\nexport type PC_P<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['ZERO'];\n\n// Ugly hack to get proper type inference, because in typescript fails to infer resursively.\n// The hack allows to do up to 10 chained operations without applying type erasure.\n//\n// Types which won't work:\n// * `CurvePointCons<CurvePoint<any, any>>`, will return `any` after 1 operation\n// * `CurvePointCons<any>: WeierstrassPointCons<bigint> extends CurvePointCons<any> = false`\n// * `P extends CurvePoint, PC extends CurvePointCons<P>`\n//     * It can't infer P from PC alone\n//     * Too many relations between F, P & PC\n//     * It will infer P/F if `arg: CurvePointCons<F, P>`, but will fail if PC is generic\n//     * It will work correctly if there is an additional argument of type P\n//     * But generally, we don't want to parametrize `CurvePointCons` over `F`: it will complicate\n//       types, making them un-inferable\n// prettier-ignore\nexport type PC_ANY = CurvePointCons<\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any, any>\n  >>>>>>>>>\n>;\n\nexport interface CurveLengths {\n  secretKey?: number;\n  publicKey?: number;\n  publicKeyUncompressed?: number;\n  publicKeyHasPrefix?: boolean;\n  signature?: number;\n  seed?: number;\n}\n\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends { negate: () => T }>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[]\n): P[] {\n  const invertedZs = FpInvertBatch(\n    c.Fp,\n    points.map((p) => p.Z!)\n  );\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\ntype WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  // To disable precomputes:\n  // return 1;\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / \uD835\uDC4A) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF<PC extends PC_ANY> {\n  private readonly BASE: PC_P<PC>;\n  private readonly ZERO: PC_P<PC>;\n  private readonly Fn: PC['Fn'];\n  readonly bits: number;\n\n  // Parametrized with a given Point class (not individual point)\n  constructor(Point: PC, bits: number) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n\n  // non-const time multiplication ladder\n  _unsafeLadder(elm: PC_P<PC>, n: bigint, p: PC_P<PC> = this.ZERO): PC_P<PC> {\n    let d: PC_P<PC> = elm;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(\uD835\uDC4A\u22121) * (Math.ceil(\uD835\uDC5B / \uD835\uDC4A) + 1), where:\n   * - \uD835\uDC4A is the window size\n   * - \uD835\uDC5B is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  private precomputeWindow(point: PC_P<PC>, W: number): PC_P<PC>[] {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points: PC_P<PC>[] = [];\n    let p: PC_P<PC> = point;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      // i=1, bc we skip 0\n      for (let i = 1; i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  private wNAF(W: number, precomputes: PC_P<PC>[], n: bigint): { p: PC_P<PC>; f: PC_P<PC> } {\n    // Scalar should be smaller than field order\n    if (!this.Fn.isValid(n)) throw new Error('invalid scalar');\n    // Accumulators\n    let p = this.ZERO;\n    let f = this.BASE;\n    // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n    // there is negate now: it is possible that negated element from low value\n    // would be the same as high element, which will create carry into next window.\n    // It's not obvious how this can fail, but still worth investigating later.\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // bits are 0: add garbage to fake point\n        // Important part for const-time getPublicKey: add random \"noise\" point to f.\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        // bits are 1: add to result point\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    // Return both real and fake points: JIT won't eliminate f.\n    // At this point there is a way to F be infinity-point even if p is not,\n    // which makes it less const-time: around 1 bigint multiply.\n    return { p, f };\n  }\n\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  private wNAFUnsafe(\n    W: number,\n    precomputes: PC_P<PC>[],\n    n: bigint,\n    acc: PC_P<PC> = this.ZERO\n  ): PC_P<PC> {\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      if (n === _0n) break; // Early-exit, skip 0 value\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // Window bits are 0: skip processing.\n        // Move to next window.\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n\n  private getPrecomputes(W: number, point: PC_P<PC>, transform?: Mapper<PC_P<PC>>): PC_P<PC>[] {\n    // Calculate precomputes on a first run, reuse them after\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W) as PC_P<PC>[];\n      if (W !== 1) {\n        // Doing transform outside of if brings 15% perf hit\n        if (typeof transform === 'function') comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n\n  cached(\n    point: PC_P<PC>,\n    scalar: bigint,\n    transform?: Mapper<PC_P<PC>>\n  ): { p: PC_P<PC>; f: PC_P<PC> } {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n\n  unsafe(point: PC_P<PC>, scalar: bigint, transform?: Mapper<PC_P<PC>>, prev?: PC_P<PC>): PC_P<PC> {\n    const W = getW(point);\n    if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(P: PC_P<PC>, W: number): void {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n\n  hasCache(elm: PC_P<PC>): boolean {\n    return getW(elm) !== 1;\n  }\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  Point: PC,\n  point: P,\n  k1: bigint,\n  k2: bigint\n): { p1: P; p2: P } {\n  let acc = point;\n  let p1 = Point.ZERO;\n  let p2 = Point.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[],\n  scalars: bigint[]\n): P {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  const fieldN = c.Fn;\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as P;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[],\n  windowSize: number\n): (scalars: bigint[]) => P {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar \u00D7 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 \u00D7 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 \u00D7 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  const fieldN = c.Fn;\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: P) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): P => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\nexport type ValidCurveParams<T> = {\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b?: T;\n  d?: T;\n  Gx: T;\n  Gy: T;\n};\n\nfunction createField<T>(order: bigint, field?: IField<T>, isLE?: boolean): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE }) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n\n/** Validates CURVE opts and creates fields */\nexport function createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {},\n  FpFnLE?: boolean\n): FpFn<T> & { CURVE: ValidCurveParams<T> } {\n  if (FpFnLE === undefined) FpFnLE = type === 'edwards';\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\n\ntype KeygenFn = (\n  seed?: Uint8Array,\n  isCompressed?: boolean\n) => { secretKey: Uint8Array; publicKey: Uint8Array };\nexport function createKeygen(\n  randomSecretKey: Function,\n  getPublicKey: Signer['getPublicKey']\n): KeygenFn {\n  return function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  };\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abool,\n  abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  copyBytes,\n  hexToBytes,\n  isBytes,\n  memoized,\n  notImplemented,\n  validateObject,\n  randomBytes as wcRandomBytes,\n  type FHash,\n  type Signer,\n} from '../utils.ts';\nimport {\n  createCurveFields,\n  createKeygen,\n  normalizeZ,\n  wNAF,\n  type AffinePoint,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport { type IField } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPoint extends CurvePoint<bigint, EdwardsPoint> {\n  /** extended X coordinate. Different from affine x. */\n  readonly X: bigint;\n  /** extended Y coordinate. Different from affine y. */\n  readonly Y: bigint;\n  /** extended Z coordinate */\n  readonly Z: bigint;\n  /** extended T coordinate */\n  readonly T: bigint;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPointCons extends CurvePointCons<EdwardsPoint> {\n  new (X: bigint, Y: bigint, Z: bigint, T: bigint): EdwardsPoint;\n  CURVE(): EdwardsOpts;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): EdwardsPoint;\n  fromHex(hex: string, zip215?: boolean): EdwardsPoint;\n}\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: bigint;\n  d: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating \u221A(u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  FpFnLE: boolean;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash secret keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomSecretKey\n */\nexport type EdDSAOpts = Partial<{\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  domain: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash: FHash;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and secret keys.\n */\nexport interface EdDSA {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array) => Uint8Array;\n  sign: (\n    message: Uint8Array,\n    secretKey: Uint8Array,\n    options?: { context?: Uint8Array }\n  ) => Uint8Array;\n  verify: (\n    sig: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    options?: { context?: Uint8Array; zip215: boolean }\n  ) => boolean;\n  Point: EdwardsPointCons;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, zip215?: boolean) => boolean;\n\n    /**\n     * Converts ed public key to x public key.\n     *\n     * There is NO `fromMontgomery`:\n     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n     *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n     *\n     * @example\n     * ```js\n     * const someonesPub_ed = ed25519.getPublicKey(ed25519.utils.randomSecretKey());\n     * const someonesPub = ed25519.utils.toMontgomery(someonesPub);\n     * const aPriv = x25519.utils.randomSecretKey();\n     * const shared = x25519.getSharedSecret(aPriv, someonesPub)\n     * ```\n     */\n    toMontgomery: (publicKey: Uint8Array) => Uint8Array;\n    /**\n     * Converts ed secret key to x secret key.\n     * @example\n     * ```js\n     * const someonesPub = x25519.getPublicKey(x25519.utils.randomSecretKey());\n     * const aPriv_ed = ed25519.utils.randomSecretKey();\n     * const aPriv = ed25519.utils.toMontgomerySecret(aPriv_ed);\n     * const shared = x25519.getSharedSecret(aPriv, someonesPub)\n     * ```\n     */\n    toMontgomerySecret: (secretKey: Uint8Array) => Uint8Array;\n    getExtendedPublicKey: (key: Uint8Array) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: EdwardsPoint;\n      pointBytes: Uint8Array;\n    };\n  };\n  lengths: CurveLengths;\n}\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(params: EdwardsOpts, extraOpts: EdwardsExtraOpts = {}): EdwardsPointCons {\n  const validated = createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as EdwardsOpts;\n  const { h: cofactor } = CURVE;\n  validateObject(extraOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    extraOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2 should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aedpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('EdwardsPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(Z) as bigint); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax\u00B2 + y\u00B2 = 1 + dx\u00B2y\u00B2\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX\u00B2 + Y\u00B2)Z\u00B2 = Z\u2074 + dX\u00B2Y\u00B2\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X); // X\u00B2\n    const Y2 = modP(Y * Y); // Y\u00B2\n    const Z2 = modP(Z * Z); // Z\u00B2\n    const Z4 = modP(Z2 * Z2); // Z\u2074\n    const aX2 = modP(X2 * a); // aX\u00B2\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX\u00B2 + Y\u00B2)Z\u00B2\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z\u2074 + dX\u00B2Y\u00B2\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T) \u220B (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements EdwardsPoint {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: bigint;\n    readonly Y: bigint;\n    readonly Z: bigint;\n    readonly T: bigint;\n\n    constructor(X: bigint, Y: bigint, Z: bigint, T: bigint) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n\n    static CURVE(): EdwardsOpts {\n      return CURVE;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      const len = Fp.BYTES;\n      const { a, d } = CURVE;\n      bytes = copyBytes(abytes(bytes, len, 'point'));\n      abool(zip215, 'zip215');\n      const normed = copyBytes(bytes); // copy again, we'll manipulate it\n      const lastByte = bytes[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('point.y', y, _0n, max);\n\n      // Ed25519: x\u00B2 = (y\u00B2-1)/(dy\u00B2+1) mod p. Ed448: x\u00B2 = (y\u00B2-1)/(dy\u00B2-1) mod p. Generic case:\n      // ax\u00B2+y\u00B2=1+dx\u00B2y\u00B2 => y\u00B2-1=dx\u00B2y\u00B2-ax\u00B2 => y\u00B2-1=x\u00B2(dy\u00B2-a) => x\u00B2=(y\u00B2-1)/(dy\u00B2-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y\u00B2 - 1\n      const v = modP(d * y2 - a); // v = d y\u00B2 + 1.\n      let { isValid, value: x } = uvRatio(u, v); // \u221A(u/v)\n      if (!isValid) throw new Error('bad point: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('bad point: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n\n    static fromHex(hex: string, zip215 = false): Point {\n      return Point.fromBytes(hexToBytes(hex), zip215);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aedpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aedpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      // 1 <= scalar < L\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n      const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n      return normalizeZ(Point, [p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      // 0 <= scalar < L\n      if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n      if (scalar === _0n) return Point.ZERO;\n      if (this.is0() || scalar === _1n) return this;\n      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      // Fp.toBytes() allows non-canonical encoding of y (>= p).\n      const bytes = Fp.toBytes(y);\n      // Each y has 2 valid points: (x, y), (x,-y).\n      // When compressing, it's enough to store y and use the last byte to encode sign of x\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport abstract class PrimeEdwardsPoint<T extends PrimeEdwardsPoint<T>>\n  implements CurvePoint<bigint, T>\n{\n  static BASE: PrimeEdwardsPoint<any>;\n  static ZERO: PrimeEdwardsPoint<any>;\n  static Fp: IField<bigint>;\n  static Fn: IField<bigint>;\n\n  protected readonly ep: EdwardsPoint;\n\n  constructor(ep: EdwardsPoint) {\n    this.ep = ep;\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract toBytes(): Uint8Array;\n  abstract equals(other: T): boolean;\n\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes: Uint8Array): any {\n    notImplemented();\n  }\n\n  static fromHex(_hex: string): any {\n    notImplemented();\n  }\n\n  get x(): bigint {\n    return this.toAffine().x;\n  }\n  get y(): bigint {\n    return this.toAffine().y;\n  }\n\n  // Common implementations\n  clearCofactor(): T {\n    // no-op for prime-order groups\n    return this as any;\n  }\n\n  assertValidity(): void {\n    this.ep.assertValidity();\n  }\n\n  toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n    return this.ep.toAffine(invertedZ);\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  isTorsionFree(): boolean {\n    return true;\n  }\n\n  isSmallOrder(): boolean {\n    return false;\n  }\n\n  add(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n\n  subtract(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): T {\n    return this.init(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): T {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): T {\n    return this.init(this.ep.double());\n  }\n\n  negate(): T {\n    return this.init(this.ep.negate());\n  }\n\n  precompute(windowSize?: number, isLazy?: boolean): T {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n\n  // Helper methods\n  abstract is0(): boolean;\n  protected abstract assertSame(other: T): void;\n  protected abstract init(ep: EdwardsPoint): T;\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: EdwardsPointCons, cHash: FHash, eddsaOpts: EdDSAOpts = {}): EdDSA {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  validateObject(\n    eddsaOpts,\n    {},\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash } = eddsaOpts;\n  const { BASE, Fp, Fn } = Point;\n\n  const randomBytes = eddsaOpts.randomBytes || wcRandomBytes;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool(phflag, 'phflag');\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Uint8Array) {\n    const len = lengths.secretKey;\n    abytes(key, lengths.secretKey, 'secretKey');\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = abytes(cHash(key), 2 * len, 'hashedSecretKey');\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey: Uint8Array) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey: Uint8Array): Uint8Array {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Uint8Array = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, abytes(context, undefined, 'context'), !!prehash)));\n  }\n\n  /** Signs message with secret key. RFC8032 5.1.6 */\n  function sign(\n    msg: Uint8Array,\n    secretKey: Uint8Array,\n    options: { context?: Uint8Array } = {}\n  ): Uint8Array {\n    msg = abytes(msg, undefined, 'message');\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = BASE.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n    if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L\n    const rs = concatBytes(R, Fn.toBytes(s));\n    return abytes(rs, lengths.signature, 'result');\n  }\n\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts: { context?: Uint8Array; zip215?: boolean } = { zip215: true };\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(\n    sig: Uint8Array,\n    msg: Uint8Array,\n    publicKey: Uint8Array,\n    options = verifyOpts\n  ): boolean {\n    const { context, zip215 } = options;\n    const len = lengths.signature;\n    sig = abytes(sig, len, 'signature');\n    msg = abytes(msg, undefined, 'message');\n    publicKey = abytes(publicKey, lengths.publicKey, 'publicKey');\n    if (zip215 !== undefined) abool(zip215, 'zip215');\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = bytesToNumberLE(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size,\n  };\n  function randomSecretKey(seed = randomBytes(lengths.seed)): Uint8Array {\n    return abytes(seed, lengths.seed, 'seed');\n  }\n\n  function isValidSecretKey(key: Uint8Array): boolean {\n    return isBytes(key) && key.length === Fn.BYTES;\n  }\n\n  function isValidPublicKey(key: Uint8Array, zip215?: boolean): boolean {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(publicKey: Uint8Array): Uint8Array {\n      const { y } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n    toMontgomerySecret(secretKey: Uint8Array): Uint8Array {\n      const size = lengths.secretKey;\n      abytes(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n  };\n\n  return Object.freeze({\n    keygen: createKeygen(randomSecretKey, getPublicKey),\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths,\n  }) satisfies Signer;\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, hexToBytes } from '@noble/hashes/utils.js';\nimport { type AffinePoint } from './abstract/curve.ts';\nimport {\n  eddsa,\n  edwards,\n  PrimeEdwardsPoint,\n  type EdDSA,\n  type EdDSAOpts,\n  type EdwardsOpts,\n  type EdwardsPoint,\n  type EdwardsPointCons,\n} from './abstract/edwards.ts';\nimport {\n  _DST_scalar,\n  createHasher,\n  expand_message_xmd,\n  type H2CDSTOpts,\n  type H2CHasher,\n  type H2CHasherBase,\n} from './abstract/hash-to-curve.ts';\nimport {\n  FpInvertBatch,\n  FpSqrtEven,\n  isNegativeLE,\n  mod,\n  pow2,\n  type IField,\n} from './abstract/modular.ts';\nimport { montgomery, type MontgomeryECDH } from './abstract/montgomery.ts';\nimport { createORPF, type OPRF } from './abstract/oprf.ts';\nimport { asciiToBytes, bytesToNumberLE, equalBytes } from './utils.ts';\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\n// P = 2n**255n - 19n\nconst ed25519_CURVE_p = BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'\n);\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE: EdwardsOpts = /* @__PURE__ */ (() => ({\n  p: ed25519_CURVE_p,\n  n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n  h: _8n,\n  a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n  d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n  Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n  Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE_p;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ed25519_CURVE_p;\n  const v3 = mod(v * v * v, P); // v\u00B3\n  const v7 = mod(v3 * v3 * v, P); // v\u2077\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv\u00B3)(uv\u2077)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\u00B2\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx\u00B2 = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx\u00B2 = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx\u00B2 = -u\u221A(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\nconst ed25519_Point = /* @__PURE__ */ edwards(ed25519_CURVE, { uvRatio });\nconst Fp = /* @__PURE__ */ (() => ed25519_Point.Fp)();\nconst Fn = /* @__PURE__ */ (() => ed25519_Point.Fn)();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    asciiToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nfunction ed(opts: EdDSAOpts) {\n  return eddsa(ed25519_Point, sha512, Object.assign({ adjustScalarBytes }, opts));\n}\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * ```js\n * import { ed25519 } from '@noble/curves/ed25519.js';\n * const { secretKey, publicKey } = ed25519.keygen();\n * // const publicKey = ed25519.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = ed25519.sign(msg, secretKey);\n * const isValid = ed25519.verify(sig, msg, pub); // ZIP215\n * // RFC8032 / FIPS 186-5\n * const isValid2 = ed25519.verify(sig, msg, pub, { zip215: false });\n * ```\n */\nexport const ed25519: EdDSA = /* @__PURE__ */ ed({});\n/** Context version of ed25519 (ctx for domain separation). See {@link ed25519} */\nexport const ed25519ctx: EdDSA = /* @__PURE__ */ ed({ domain: ed25519_domain });\n/** Prehashed version of ed25519. See {@link ed25519} */\nexport const ed25519ph: EdDSA = /* @__PURE__ */ ed({ domain: ed25519_domain, prehash: sha512 });\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * ```js\n * import { x25519 } from '@noble/curves/ed25519.js';\n * const alice = x25519.keygen();\n * const bob = x25519.keygen();\n * const shared = x25519.getSharedSecret(alice.secretKey, bob.publicKey);\n * ```\n */\nexport const x25519: MontgomeryECDH = /* @__PURE__ */ (() => {\n  const P = ed25519_CURVE_p;\n  return montgomery({\n    P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n  });\n})();\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n/**\n * RFC 9380 method `map_to_curve_elligator2_curve25519`. Experimental name: may be renamed later.\n * @private\n */\n// prettier-ignore\nexport function _map_to_curve_elligator2_curve25519(u: bigint): {\n  xMn: bigint, xMd: bigint, yMn: bigint, yMd: bigint\n} {\n  const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd!(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = _map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher: H2CHasher<EdwardsPointCons> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519_Point,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: ed25519_CURVE_p,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\n\n// \u221A(-1) aka \u221A(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// \u221A(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / \u221A(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\u00B2\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\u00B2\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/\u221A(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) => Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): EdwardsPoint {\n  const { d } = ed25519_CURVE;\n  const P = ed25519_CURVE_p;\n  const mod = (n: bigint) => Fp.create(n);\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519_Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/EdwardsPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like EdwardsPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint<_RistrettoPoint> {\n  // Do NOT change syntax: the following gymnastics is done,\n  // because typescript strips comments, which makes bundlers disable tree-shaking.\n  // prettier-ignore\n  static BASE: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.BASE))();\n  // prettier-ignore\n  static ZERO: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519_Point.ZERO))();\n  // prettier-ignore\n  static Fp: IField<bigint> =\n    /* @__PURE__ */ (() => Fp)();\n  // prettier-ignore\n  static Fn: IField<bigint> =\n    /* @__PURE__ */ (() => Fn)();\n\n  constructor(ep: EdwardsPoint) {\n    super(ep);\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): _RistrettoPoint {\n    return new _RistrettoPoint(ed25519_Point.fromAffine(ap));\n  }\n\n  protected assertSame(other: _RistrettoPoint): void {\n    if (!(other instanceof _RistrettoPoint)) throw new Error('RistrettoPoint expected');\n  }\n\n  protected init(ep: EdwardsPoint): _RistrettoPoint {\n    return new _RistrettoPoint(ep);\n  }\n\n  static fromBytes(bytes: Uint8Array): _RistrettoPoint {\n    abytes(bytes, 32);\n    const { a, d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const s = bytes255ToNumberLE(bytes);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n      throw new Error('invalid ristretto255 encoding 1');\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n)\n      throw new Error('invalid ristretto255 encoding 2');\n    return new _RistrettoPoint(new ed25519_Point(x, y, _1n, t));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: string): _RistrettoPoint {\n    return _RistrettoPoint.fromBytes(hexToBytes(hex));\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toBytes(): Uint8Array {\n    let { X, Y, Z, T } = this.ep;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n    const u2 = mod(X * Y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * T); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(T * zInv, P)) {\n      let _x = mod(Y * SQRT_M1);\n      let _y = mod(X * SQRT_M1);\n      X = _x;\n      Y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(X * zInv, P)) Y = mod(-Y); // 9\n    let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return Fp.toBytes(s); // 11\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: _RistrettoPoint): boolean {\n    this.assertSame(other);\n    const { X: X1, Y: Y1 } = this.ep;\n    const { X: X2, Y: Y2 } = other.ep;\n    const mod = (n: bigint) => Fp.create(n);\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  is0(): boolean {\n    return this.equals(_RistrettoPoint.ZERO);\n  }\n}\n\nexport const ristretto255: {\n  Point: typeof _RistrettoPoint;\n} = { Point: _RistrettoPoint };\n\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher: H2CHasherBase<typeof _RistrettoPoint> = {\n  Point: _RistrettoPoint,\n  /**\n  * Spec: https://www.rfc-editor.org/rfc/rfc9380.html#name-hashing-to-ristretto255. Caveats:\n  * * There are no test vectors\n  * * encodeToCurve / mapToCurve is undefined\n  * * mapToCurve would be `calcElligatorRistrettoMap(scalars[0])`, not ristretto255_map!\n  * * hashToScalar is undefined too, so we just use OPRF implementation\n  * * We cannot re-use 'createHasher', because ristretto255_map is different algorithm/RFC\n    (os2ip -> bytes255ToNumberLE)\n  * * mapToCurve == calcElligatorRistrettoMap, hashToCurve == ristretto255_map\n  * * hashToScalar is undefined in RFC9380 for ristretto, we are using version from OPRF here, using bytes255ToNumblerLE will create different result if we use bytes255ToNumberLE as os2ip\n  * * current version is closest to spec.\n  */\n  hashToCurve(msg: Uint8Array, options?: H2CDSTOpts): _RistrettoPoint {\n    // == 'hash_to_ristretto255'\n    const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n    const xmd = expand_message_xmd(msg, DST, 64, sha512);\n    // NOTE: RFC 9380 incorrectly calls this function 'ristretto255_map', in RFC 9496 map was function inside (per point)\n    // That also lead to confustion that ristretto255_map is mapToCurve (it is not! it is old hashToCurve)\n    return ristretto255_hasher.deriveToCurve!(xmd);\n  },\n  hashToScalar(msg: Uint8Array, options: H2CDSTOpts = { DST: _DST_scalar }) {\n    const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n    return Fn.create(bytesToNumberLE(xmd));\n  },\n  /**\n   * HashToCurve-like construction based on RFC 9496 (Element Derivation).\n   * Converts 64 uniform random bytes into a curve point.\n   *\n   * WARNING: This represents an older hash-to-curve construction, preceding the finalization of RFC 9380.\n   * It was later reused as a component in the newer `hash_to_ristretto255` function defined in RFC 9380.\n   */\n  deriveToCurve(bytes: Uint8Array): _RistrettoPoint {\n    // https://www.rfc-editor.org/rfc/rfc9496.html#name-element-derivation\n    abytes(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n  },\n};\n\n/** ristretto255 OPRF, defined in RFC 9497. */\nexport const ristretto255_oprf: OPRF = /* @__PURE__ */ (() =>\n  createORPF({\n    name: 'ristretto255-SHA512',\n    Point: _RistrettoPoint,\n    hash: sha512,\n    hashToGroup: ristretto255_hasher.hashToCurve,\n    hashToScalar: ristretto255_hasher.hashToScalar,\n  }))();\n\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * \u27E8T\u27E9 = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n", "/**\n * Signing a message failed\n */\nexport class SigningError extends Error {\n  constructor (message = 'An error occurred while signing a message') {\n    super(message)\n    this.name = 'SigningError'\n  }\n}\n\n/**\n * Verifying a message signature failed\n */\nexport class VerificationError extends Error {\n  constructor (message = 'An error occurred while verifying a message') {\n    super(message)\n    this.name = 'VerificationError'\n  }\n}\n\n/**\n * WebCrypto was not available in the current context\n */\nexport class WebCryptoMissingError extends Error {\n  constructor (message = 'Missing Web Crypto API') {\n    super(message)\n    this.name = 'WebCryptoMissingError'\n  }\n}\n", "/* eslint-env browser */\n\nimport { WebCryptoMissingError } from '../errors.js'\n\n// Check native crypto exists and is enabled (In insecure context `self.crypto`\n// exists but `self.crypto.subtle` does not).\nexport default {\n  get (win = globalThis) {\n    const nativeCrypto = win.crypto\n\n    if (nativeCrypto?.subtle == null) {\n      throw new WebCryptoMissingError(\n        'Missing Web Crypto API. ' +\n        'The most likely cause of this error is that this page is being accessed ' +\n        'from an insecure context (i.e. not HTTPS). For more information and ' +\n        'possible resolutions see ' +\n        'https://github.com/libp2p/js-libp2p/blob/main/packages/crypto/README.md#web-crypto-api'\n      )\n    }\n\n    return nativeCrypto\n  }\n}\n", "import webcrypto from './webcrypto.js'\n\nexport default webcrypto\n", "import { ed25519 as ed } from '@noble/curves/ed25519.js'\nimport { toString as uint8arrayToString } from 'uint8arrays/to-string'\nimport crypto from '../../webcrypto/index.js'\nimport type { Uint8ArrayKeyPair } from '../interface.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 32\nconst PRIVATE_KEY_BYTE_LENGTH = 64 // private key is actually 32 bytes but for historical reasons we concat private and public keys\nconst KEYS_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\n// memoize support result to skip additional awaits every time we use an ed key\nlet ed25519Supported: boolean | undefined\nconst webCryptoEd25519SupportedPromise = (async () => {\n  try {\n    await crypto.get().subtle.generateKey({ name: 'Ed25519' }, true, ['sign', 'verify'])\n    return true\n  } catch {\n    return false\n  }\n})()\n\nexport function generateKey (): Uint8ArrayKeyPair {\n  // the actual private key (32 bytes)\n  const privateKeyRaw = ed.utils.randomSecretKey()\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  // concatenated the public key to the private key\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nexport function generateKeyFromSeed (seed: Uint8Array): Uint8ArrayKeyPair {\n  if (seed.length !== KEYS_BYTE_LENGTH) {\n    throw new TypeError('\"seed\" must be 32 bytes in length.')\n  } else if (!(seed instanceof Uint8Array)) {\n    throw new TypeError('\"seed\" must be a node.js Buffer, or Uint8Array.')\n  }\n\n  // based on node forges algorithm, the seed is used directly as private key\n  const privateKeyRaw = seed\n  const publicKey = ed.getPublicKey(privateKeyRaw)\n\n  const privateKey = concatKeys(privateKeyRaw, publicKey)\n\n  return {\n    privateKey,\n    publicKey\n  }\n}\n\nasync function hashAndSignWebCrypto (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n  let privateKeyRaw: Uint8Array\n  if (privateKey.length === PRIVATE_KEY_BYTE_LENGTH) {\n    privateKeyRaw = privateKey.subarray(0, 32)\n  } else {\n    privateKeyRaw = privateKey\n  }\n\n  const jwk: JsonWebKey = {\n    crv: 'Ed25519',\n    kty: 'OKP',\n    x: uint8arrayToString(privateKey.subarray(32), 'base64url'),\n    d: uint8arrayToString(privateKeyRaw, 'base64url'),\n    ext: true,\n    key_ops: ['sign']\n  }\n\n  const key = await crypto.get().subtle.importKey('jwk', jwk, { name: 'Ed25519' }, true, ['sign'])\n  const sig = await crypto.get().subtle.sign({ name: 'Ed25519' }, key, msg instanceof Uint8Array ? msg : msg.subarray())\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport function hashAndSignNoble (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Uint8Array {\n  const privateKeyRaw = privateKey.subarray(0, KEYS_BYTE_LENGTH)\n\n  return ed.sign(msg instanceof Uint8Array ? msg : msg.subarray(), privateKeyRaw)\n}\n\nexport async function hashAndSign (privateKey: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<Uint8Array> {\n  if (ed25519Supported == null) {\n    ed25519Supported = await webCryptoEd25519SupportedPromise\n  }\n\n  if (ed25519Supported) {\n    return hashAndSignWebCrypto(privateKey, msg)\n  }\n\n  return hashAndSignNoble(privateKey, msg)\n}\n\nasync function hashAndVerifyWebCrypto (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<boolean> {\n  if (publicKey.buffer instanceof ArrayBuffer) {\n    const key = await crypto.get().subtle.importKey('raw', publicKey.buffer, { name: 'Ed25519' }, false, ['verify'])\n    const isValid = await crypto.get().subtle.verify({ name: 'Ed25519' }, key, sig, msg instanceof Uint8Array ? msg : msg.subarray())\n    return isValid\n  }\n\n  throw new TypeError('WebCrypto does not support SharedArrayBuffer for Ed25519 keys')\n}\n\nexport function hashAndVerifyNoble (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): boolean {\n  return ed.verify(sig, msg instanceof Uint8Array ? msg : msg.subarray(), publicKey)\n}\n\nexport async function hashAndVerify (publicKey: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList): Promise<boolean> {\n  if (ed25519Supported == null) {\n    ed25519Supported = await webCryptoEd25519SupportedPromise\n  }\n\n  if (ed25519Supported) {\n    return hashAndVerifyWebCrypto(publicKey, sig, msg)\n  }\n\n  return hashAndVerifyNoble(publicKey, sig, msg)\n}\n\nfunction concatKeys (privateKeyRaw: Uint8Array, publicKey: Uint8Array): Uint8Array {\n  const privateKey = new Uint8Array(PRIVATE_KEY_BYTE_LENGTH)\n  for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {\n    privateKey[i] = privateKeyRaw[i]\n    privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i]\n  }\n  return privateKey\n}\n", "import { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\n\nexport function base64urlToBuffer (str: string, len?: number): Uint8Array {\n  let buf = uint8ArrayFromString(str, 'base64urlpad')\n\n  if (len != null) {\n    if (buf.length > len) {\n      throw new Error('byte array longer than desired length')\n    }\n\n    buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf])\n  }\n\n  return buf\n}\n\nexport function isPromise <T = unknown> (thing: any): thing is Promise<T> {\n  if (thing == null) {\n    return false\n  }\n\n  return typeof thing.then === 'function' &&\n    typeof thing.catch === 'function' &&\n    typeof thing.finally === 'function'\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { isPromise } from '../../util.ts'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { ensureEd25519Key } from './utils.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey as Ed25519PublicKeyInterface, Ed25519PrivateKey as Ed25519PrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Ed25519PublicKey implements Ed25519PublicKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.publicKeyLength)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean> {\n    options?.signal?.throwIfAborted()\n    const result = crypto.hashAndVerify(this.raw, sig, data)\n\n    if (isPromise<boolean>(result)) {\n      return result.then(res => {\n        options?.signal?.throwIfAborted()\n        return res\n      })\n    }\n\n    return result\n  }\n}\n\nexport class Ed25519PrivateKey implements Ed25519PrivateKeyInterface {\n  public readonly type = 'Ed25519'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Ed25519PublicKey\n\n  // key       - 64 byte Uint8Array containing private key\n  // publicKey - 32 byte Uint8Array containing public key\n  constructor (key: Uint8Array, publicKey: Uint8Array) {\n    this.raw = ensureEd25519Key(key, crypto.privateKeyLength)\n    this.publicKey = new Ed25519PublicKey(publicKey)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n    options?.signal?.throwIfAborted()\n    const sig = crypto.hashAndSign(this.raw, message)\n\n    if (isPromise<Uint8Array>(sig)) {\n      return sig.then(res => {\n        options?.signal?.throwIfAborted()\n        return res\n      })\n    }\n\n    options?.signal?.throwIfAborted()\n    return sig\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { Ed25519PublicKey as Ed25519PublicKeyClass, Ed25519PrivateKey as Ed25519PrivateKeyClass } from './ed25519.js'\nimport * as crypto from './index.js'\nimport type { Ed25519PublicKey, Ed25519PrivateKey } from '@libp2p/interface'\n\nexport function unmarshalEd25519PrivateKey (bytes: Uint8Array): Ed25519PrivateKey {\n  // Try the old, redundant public key version\n  if (bytes.length > crypto.privateKeyLength) {\n    bytes = ensureEd25519Key(bytes, crypto.privateKeyLength + crypto.publicKeyLength)\n    const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n    const publicKeyBytes = bytes.subarray(crypto.privateKeyLength, bytes.length)\n    return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n  }\n\n  bytes = ensureEd25519Key(bytes, crypto.privateKeyLength)\n  const privateKeyBytes = bytes.subarray(0, crypto.privateKeyLength)\n  const publicKeyBytes = bytes.subarray(crypto.publicKeyLength)\n  return new Ed25519PrivateKeyClass(privateKeyBytes, publicKeyBytes)\n}\n\nexport function unmarshalEd25519PublicKey (bytes: Uint8Array): Ed25519PublicKey {\n  bytes = ensureEd25519Key(bytes, crypto.publicKeyLength)\n  return new Ed25519PublicKeyClass(bytes)\n}\n\nexport async function generateEd25519KeyPair (): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKey()\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport async function generateEd25519KeyPairFromSeed (seed: Uint8Array): Promise<Ed25519PrivateKey> {\n  const { privateKey, publicKey } = crypto.generateKeyFromSeed(seed)\n  return new Ed25519PrivateKeyClass(privateKey, publicKey)\n}\n\nexport function ensureEd25519Key (key: Uint8Array, length: number): Uint8Array {\n  key = Uint8Array.from(key ?? [])\n  if (key.length !== length) {\n    throw new InvalidParametersError(`Key must be a Uint8Array of length ${length}, got ${key.length}`)\n  }\n  return key\n}\n", "/* eslint-disable no-fallthrough */\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst N1 = Math.pow(2, 7)\nconst N2 = Math.pow(2, 14)\nconst N3 = Math.pow(2, 21)\nconst N4 = Math.pow(2, 28)\nconst N5 = Math.pow(2, 35)\nconst N6 = Math.pow(2, 42)\nconst N7 = Math.pow(2, 49)\n\n/** Most significant bit of a byte */\nconst MSB = 0x80\n/** Rest of the bits in a byte */\nconst REST = 0x7f\n\nexport function encodingLength (value: number): number {\n  if (value < N1) {\n    return 1\n  }\n\n  if (value < N2) {\n    return 2\n  }\n\n  if (value < N3) {\n    return 3\n  }\n\n  if (value < N4) {\n    return 4\n  }\n\n  if (value < N5) {\n    return 5\n  }\n\n  if (value < N6) {\n    return 6\n  }\n\n  if (value < N7) {\n    return 7\n  }\n\n  if (Number.MAX_SAFE_INTEGER != null && value > Number.MAX_SAFE_INTEGER) {\n    throw new RangeError('Could not encode varint')\n  }\n\n  return 8\n}\n\nexport function encodeUint8Array (value: number, buf: Uint8Array, offset: number = 0): Uint8Array {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 7: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 6: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 5: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value /= 128\n    }\n    case 4: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 3: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 2: {\n      buf[offset++] = (value & 0xFF) | MSB\n      value >>>= 7\n    }\n    case 1: {\n      buf[offset++] = (value & 0xFF)\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function encodeUint8ArrayList (value: number, buf: Uint8ArrayList, offset: number = 0): Uint8ArrayList {\n  switch (encodingLength(value)) {\n    case 8: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 7: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 6: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 5: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value /= 128\n    }\n    case 4: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 3: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 2: {\n      buf.set(offset++, (value & 0xFF) | MSB)\n      value >>>= 7\n    }\n    case 1: {\n      buf.set(offset++, (value & 0xFF))\n      value >>>= 7\n      break\n    }\n    default: throw new Error('unreachable')\n  }\n  return buf\n}\n\nexport function decodeUint8Array (buf: Uint8Array, offset: number): number {\n  let b = buf[offset]\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 1]\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 2]\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 3]\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 4]\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 5]\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 6]\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf[offset + 7]\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function decodeUint8ArrayList (buf: Uint8ArrayList, offset: number): number {\n  let b = buf.get(offset)\n  let res = 0\n\n  res += b & REST\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 1)\n  res += (b & REST) << 7\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 2)\n  res += (b & REST) << 14\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 3)\n  res += (b & REST) << 21\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 4)\n  res += (b & REST) * N4\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 5)\n  res += (b & REST) * N5\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 6)\n  res += (b & REST) * N6\n  if (b < MSB) {\n    return res\n  }\n\n  b = buf.get(offset + 7)\n  res += (b & REST) * N7\n  if (b < MSB) {\n    return res\n  }\n\n  throw new RangeError('Could not decode varint')\n}\n\nexport function encode (value: number): Uint8Array\nexport function encode (value: number, buf: Uint8Array, offset?: number): Uint8Array\nexport function encode (value: number, buf: Uint8ArrayList, offset?: number): Uint8ArrayList\nexport function encode <T extends Uint8Array | Uint8ArrayList = Uint8Array> (value: number, buf?: T, offset: number = 0): T {\n  if (buf == null) {\n    buf = allocUnsafe(encodingLength(value)) as T\n  }\n  if (buf instanceof Uint8Array) {\n    return encodeUint8Array(value, buf, offset) as T\n  } else {\n    return encodeUint8ArrayList(value, buf, offset) as T\n  }\n}\n\nexport function decode (buf: Uint8ArrayList | Uint8Array, offset: number = 0): number {\n  if (buf instanceof Uint8Array) {\n    return decodeUint8Array(buf, offset)\n  } else {\n    return decodeUint8ArrayList(buf, offset)\n  }\n}\n", "const f32 = new Float32Array([-0])\nconst f8b = new Uint8Array(f32.buffer)\n\n/**\n * Writes a 32 bit float to a buffer using little endian byte order\n */\nexport function writeFloatLE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[0]\n  buf[pos + 1] = f8b[1]\n  buf[pos + 2] = f8b[2]\n  buf[pos + 3] = f8b[3]\n}\n\n/**\n * Writes a 32 bit float to a buffer using big endian byte order\n */\nexport function writeFloatBE (val: number, buf: Uint8Array, pos: number): void {\n  f32[0] = val\n  buf[pos] = f8b[3]\n  buf[pos + 1] = f8b[2]\n  buf[pos + 2] = f8b[1]\n  buf[pos + 3] = f8b[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using little endian byte order\n */\nexport function readFloatLE (buf: Uint8Array, pos: number): number {\n  f8b[0] = buf[pos]\n  f8b[1] = buf[pos + 1]\n  f8b[2] = buf[pos + 2]\n  f8b[3] = buf[pos + 3]\n  return f32[0]\n}\n\n/**\n * Reads a 32 bit float from a buffer using big endian byte order\n */\nexport function readFloatBE (buf: Uint8Array, pos: number): number {\n  f8b[3] = buf[pos]\n  f8b[2] = buf[pos + 1]\n  f8b[1] = buf[pos + 2]\n  f8b[0] = buf[pos + 3]\n  return f32[0]\n}\n\nconst f64 = new Float64Array([-0])\nconst d8b = new Uint8Array(f64.buffer)\n\n/**\n * Writes a 64 bit double to a buffer using little endian byte order\n */\nexport function writeDoubleLE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[0]\n  buf[pos + 1] = d8b[1]\n  buf[pos + 2] = d8b[2]\n  buf[pos + 3] = d8b[3]\n  buf[pos + 4] = d8b[4]\n  buf[pos + 5] = d8b[5]\n  buf[pos + 6] = d8b[6]\n  buf[pos + 7] = d8b[7]\n}\n\n/**\n * Writes a 64 bit double to a buffer using big endian byte order\n */\nexport function writeDoubleBE (val: number, buf: Uint8Array, pos: number): void {\n  f64[0] = val\n  buf[pos] = d8b[7]\n  buf[pos + 1] = d8b[6]\n  buf[pos + 2] = d8b[5]\n  buf[pos + 3] = d8b[4]\n  buf[pos + 4] = d8b[3]\n  buf[pos + 5] = d8b[2]\n  buf[pos + 6] = d8b[1]\n  buf[pos + 7] = d8b[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using little endian byte order\n */\nexport function readDoubleLE (buf: Uint8Array, pos: number): number {\n  d8b[0] = buf[pos]\n  d8b[1] = buf[pos + 1]\n  d8b[2] = buf[pos + 2]\n  d8b[3] = buf[pos + 3]\n  d8b[4] = buf[pos + 4]\n  d8b[5] = buf[pos + 5]\n  d8b[6] = buf[pos + 6]\n  d8b[7] = buf[pos + 7]\n  return f64[0]\n}\n\n/**\n * Reads a 64 bit double from a buffer using big endian byte order\n */\nexport function readDoubleBE (buf: Uint8Array, pos: number): number {\n  d8b[7] = buf[pos]\n  d8b[6] = buf[pos + 1]\n  d8b[5] = buf[pos + 2]\n  d8b[4] = buf[pos + 3]\n  d8b[3] = buf[pos + 4]\n  d8b[2] = buf[pos + 5]\n  d8b[1] = buf[pos + 6]\n  d8b[0] = buf[pos + 7]\n  return f64[0]\n}\n", "// the largest BigInt we can safely downcast to a Number\nconst MAX_SAFE_NUMBER_INTEGER = BigInt(Number.MAX_SAFE_INTEGER)\nconst MIN_SAFE_NUMBER_INTEGER = BigInt(Number.MIN_SAFE_INTEGER)\n\n/**\n * Constructs new long bits.\n *\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @function Object() { [native code] }\n * @param {number} lo - Low 32 bits, unsigned\n * @param {number} hi - High 32 bits, unsigned\n */\nexport class LongBits {\n  public lo: number\n  public hi: number\n\n  constructor (lo: number, hi: number) {\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits\n     */\n    this.lo = lo | 0\n\n    /**\n     * High bits\n     */\n    this.hi = hi | 0\n  }\n\n  /**\n   * Converts this long bits to a possibly unsafe JavaScript number\n   */\n  toNumber (unsigned: boolean = false): number {\n    if (!unsigned && (this.hi >>> 31) > 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(lo + hi * 4294967296)\n    }\n    return this.lo + this.hi * 4294967296\n  }\n\n  /**\n   * Converts this long bits to a bigint\n   */\n  toBigInt (unsigned: boolean = false): bigint {\n    if (unsigned) {\n      return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n    }\n\n    if ((this.hi >>> 31) !== 0) {\n      const lo = ~this.lo + 1 >>> 0\n      let hi = ~this.hi >>> 0\n      if (lo === 0) {\n        hi = hi + 1 >>> 0\n      }\n      return -(BigInt(lo) + (BigInt(hi) << 32n))\n    }\n\n    return BigInt(this.lo >>> 0) + (BigInt(this.hi >>> 0) << 32n)\n  }\n\n  /**\n   * Converts this long bits to a string\n   */\n  toString (unsigned: boolean = false): string {\n    return this.toBigInt(unsigned).toString()\n  }\n\n  /**\n   * Zig-zag encodes this long bits\n   */\n  zzEncode (): this {\n    const mask = this.hi >> 31\n    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0\n    this.lo = (this.lo << 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Zig-zag decodes this long bits\n   */\n  zzDecode (): this {\n    const mask = -(this.lo & 1)\n    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0\n    this.hi = (this.hi >>> 1 ^ mask) >>> 0\n    return this\n  }\n\n  /**\n   * Calculates the length of this longbits when encoded as a varint.\n   */\n  length (): number {\n    const part0 = this.lo\n    const part1 = (this.lo >>> 28 | this.hi << 4) >>> 0\n    const part2 = this.hi >>> 24\n    return part2 === 0\n      ? part1 === 0\n        ? part0 < 16384\n          ? part0 < 128 ? 1 : 2\n          : part0 < 2097152 ? 3 : 4\n        : part1 < 16384\n          ? part1 < 128 ? 5 : 6\n          : part1 < 2097152 ? 7 : 8\n      : part2 < 128 ? 9 : 10\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromBigInt (value: bigint): LongBits {\n    if (value === 0n) {\n      return zero\n    }\n\n    if (value < MAX_SAFE_NUMBER_INTEGER && value > MIN_SAFE_NUMBER_INTEGER) {\n      return this.fromNumber(Number(value))\n    }\n\n    const negative = value < 0n\n\n    if (negative) {\n      value = -value\n    }\n\n    let hi = value >> 32n\n    let lo = value - (hi << 32n)\n\n    if (negative) {\n      hi = ~hi | 0n\n      lo = ~lo | 0n\n\n      if (++lo > TWO_32) {\n        lo = 0n\n        if (++hi > TWO_32) { hi = 0n }\n      }\n    }\n\n    return new LongBits(Number(lo), Number(hi))\n  }\n\n  /**\n   * Constructs new long bits from the specified number\n   */\n  static fromNumber (value: number): LongBits {\n    if (value === 0) { return zero }\n    const sign = value < 0\n    if (sign) { value = -value }\n    let lo = value >>> 0\n    let hi = (value - lo) / 4294967296 >>> 0\n    if (sign) {\n      hi = ~hi >>> 0\n      lo = ~lo >>> 0\n      if (++lo > 4294967295) {\n        lo = 0\n        if (++hi > 4294967295) { hi = 0 }\n      }\n    }\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Constructs new long bits from a number, long or string\n   */\n  static from (value: bigint | number | string | { low: number, high: number }): LongBits {\n    if (typeof value === 'number') {\n      return LongBits.fromNumber(value)\n    }\n    if (typeof value === 'bigint') {\n      return LongBits.fromBigInt(value)\n    }\n    if (typeof value === 'string') {\n      return LongBits.fromBigInt(BigInt(value))\n    }\n    return value.low != null || value.high != null ? new LongBits(value.low >>> 0, value.high >>> 0) : zero\n  }\n}\n\nconst zero = new LongBits(0, 0)\nzero.toBigInt = function () { return 0n }\nzero.zzEncode = zero.zzDecode = function () { return this }\nzero.length = function () { return 1 }\n\nconst TWO_32 = 4294967296n\n", "/**\n * Calculates the UTF8 byte length of a string\n */\nexport function length (string: string): number {\n  let len = 0\n  let c = 0\n  for (let i = 0; i < string.length; ++i) {\n    c = string.charCodeAt(i)\n\n    if (c < 128) {\n      len += 1\n    } else if (c < 2048) {\n      len += 2\n    } else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i\n      len += 4\n    } else {\n      len += 3\n    }\n  }\n\n  return len\n}\n\n/**\n * Reads UTF8 bytes as a string\n */\nexport function read (buffer: Uint8Array, start: number, end: number): string {\n  const len = end - start\n\n  if (len < 1) {\n    return ''\n  }\n\n  let parts: string[] | undefined\n  const chunk: number[] = []\n  let i = 0 // char offset\n  let t: number // temporary\n\n  while (start < end) {\n    t = buffer[start++]\n\n    if (t < 128) {\n      chunk[i++] = t\n    } else if (t > 191 && t < 224) {\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63\n    } else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000\n      chunk[i++] = 0xD800 + (t >> 10)\n      chunk[i++] = 0xDC00 + (t & 1023)\n    } else {\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63\n    }\n\n    if (i > 8191) {\n      (parts ?? (parts = [])).push(String.fromCharCode.apply(String, chunk))\n      i = 0\n    }\n  }\n\n  if (parts != null) {\n    if (i > 0) {\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)))\n    }\n\n    return parts.join('')\n  }\n\n  return String.fromCharCode.apply(String, chunk.slice(0, i))\n}\n\n/**\n * Writes a string as UTF8 bytes\n */\nexport function write (string: string, buffer: Uint8Array, offset: number): number {\n  const start = offset\n  let c1 // character 1\n  let c2 // character 2\n\n  for (let i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i)\n\n    if (c1 < 128) {\n      buffer[offset++] = c1\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192\n      buffer[offset++] = c1 & 63 | 128\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF)\n      ++i\n      buffer[offset++] = c1 >> 18 | 240\n      buffer[offset++] = c1 >> 12 & 63 | 128\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    } else {\n      buffer[offset++] = c1 >> 12 | 224\n      buffer[offset++] = c1 >> 6 & 63 | 128\n      buffer[offset++] = c1 & 63 | 128\n    }\n  }\n\n  return offset - start\n}\n", "import { decodeUint8Array, encodingLength } from 'uint8-varint'\nimport { readFloatLE, readDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport * as utf8 from './utf8.js'\nimport type { Reader } from '../index.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\n/* istanbul ignore next */\nfunction indexOutOfRange (reader: Reader, writeLength?: number): RangeError {\n  return RangeError(`index out of range: ${reader.pos} + ${writeLength ?? 1} > ${reader.len}`)\n}\n\nfunction readFixed32End (buf: Uint8Array, end: number): number { // note that this uses `end`, not `pos`\n  return (buf[end - 4] |\n        buf[end - 3] << 8 |\n        buf[end - 2] << 16 |\n        buf[end - 1] << 24) >>> 0\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n */\nexport class Uint8ArrayReader implements Reader {\n  public buf: Uint8Array\n  public pos: number\n  public len: number\n\n  public _slice = Uint8Array.prototype.subarray\n\n  constructor (buffer: Uint8Array) {\n    /**\n     * Read buffer\n     */\n    this.buf = buffer\n\n    /**\n     * Read buffer position\n     */\n    this.pos = 0\n\n    /**\n     * Read buffer length\n     */\n    this.len = buffer.length\n  }\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32 (): number {\n    let value = 4294967295\n\n    value = (this.buf[this.pos] & 127) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 7) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n    value = (value | (this.buf[this.pos] & 15) << 28) >>> 0; if (this.buf[this.pos++] < 128) { return value }\n\n    if ((this.pos += 5) > this.len) {\n      this.pos = this.len\n      throw indexOutOfRange(this, 10)\n    }\n\n    return value\n  }\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32 (): number {\n    return this.uint32() | 0\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32 (): number {\n    const value = this.uint32()\n    return value >>> 1 ^ -(value & 1) | 0\n  }\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool (): boolean {\n    return this.uint32() !== 0\n  }\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32 (): number {\n    if (this.pos + 4 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const res = readFixed32End(this.buf, this.pos += 4)\n\n    return res\n  }\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32 (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const res = readFixed32End(this.buf, this.pos += 4) | 0\n\n    return res\n  }\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float (): number {\n    if (this.pos + 4 > this.len) {\n      throw indexOutOfRange(this, 4)\n    }\n\n    const value = readFloatLE(this.buf, this.pos)\n    this.pos += 4\n    return value\n  }\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double (): number {\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len) { throw indexOutOfRange(this, 4) }\n\n    const value = readDoubleLE(this.buf, this.pos)\n    this.pos += 8\n    return value\n  }\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes (): Uint8Array {\n    const length = this.uint32()\n    const start = this.pos\n    const end = this.pos + length\n\n    /* istanbul ignore if */\n    if (end > this.len) {\n      throw indexOutOfRange(this, length)\n    }\n\n    this.pos += length\n\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n      ? new Uint8Array(0)\n      : this.buf.subarray(start, end)\n  }\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string (): string {\n    const bytes = this.bytes()\n    return utf8.read(bytes, 0, bytes.length)\n  }\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varint\n   */\n  skip (length?: number): this {\n    if (typeof length === 'number') {\n      /* istanbul ignore if */\n      if (this.pos + length > this.len) { throw indexOutOfRange(this, length) }\n      this.pos += length\n    } else {\n      do {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n      } while ((this.buf[this.pos++] & 128) !== 0)\n    }\n    return this\n  }\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType (wireType: number): this {\n    switch (wireType) {\n      case 0:\n        this.skip()\n        break\n      case 1:\n        this.skip(8)\n        break\n      case 2:\n        this.skip(this.uint32())\n        break\n      case 3:\n        while ((wireType = this.uint32() & 7) !== 4) {\n          this.skipType(wireType)\n        }\n        break\n      case 5:\n        this.skip(4)\n        break\n\n        /* istanbul ignore next */\n      default:\n        throw Error(`invalid wire type ${wireType} at offset ${this.pos}`)\n    }\n    return this\n  }\n\n  private readLongVarint (): LongBits {\n    // tends to deopt with local vars for octet etc.\n    const bits = new LongBits(0, 0)\n    let i = 0\n    if (this.len - this.pos > 4) { // fast route (lo)\n      for (; i < 4; ++i) {\n        // 1st..4th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 5th\n      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0\n      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0\n      if (this.buf[this.pos++] < 128) { return bits }\n      i = 0\n    } else {\n      for (; i < 3; ++i) {\n        /* istanbul ignore if */\n        if (this.pos >= this.len) { throw indexOutOfRange(this) }\n        // 1st..3th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n      // 4th\n      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0\n      return bits\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n      for (; i < 5; ++i) {\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    } else {\n      for (; i < 5; ++i) {\n        if (this.pos >= this.len) {\n          throw indexOutOfRange(this)\n        }\n\n        // 6th..10th\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0\n        if (this.buf[this.pos++] < 128) { return bits }\n      }\n    }\n\n    throw Error('invalid varint encoding')\n  }\n\n  private readFixed64 (): LongBits {\n    if (this.pos + 8 > this.len) {\n      throw indexOutOfRange(this, 8)\n    }\n\n    const lo = readFixed32End(this.buf, this.pos += 4)\n    const hi = readFixed32End(this.buf, this.pos += 4)\n\n    return new LongBits(lo, hi)\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64 (): bigint {\n    return this.readLongVarint().toBigInt()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  int64Number (): number {\n    return this.readLongVarint().toNumber()\n  }\n\n  /**\n   * Reads a varint as a signed 64 bit value returned as a string\n   */\n  int64String (): string {\n    return this.readLongVarint().toString()\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64 (): bigint {\n    return this.readLongVarint().toBigInt(true)\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a possibly unsafe\n   * JavaScript number\n   */\n  uint64Number (): number {\n    const value = decodeUint8Array(this.buf, this.pos)\n    this.pos += encodingLength(value)\n    return value\n  }\n\n  /**\n   * Reads a varint as an unsigned 64 bit value returned as a string\n   */\n  uint64String (): string {\n    return this.readLongVarint().toString(true)\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64 (): bigint {\n    return this.readLongVarint().zzDecode().toBigInt()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * possibly unsafe JavaScript number\n   */\n  sint64Number (): number {\n    return this.readLongVarint().zzDecode().toNumber()\n  }\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value returned as a\n   * string\n   */\n  sint64String (): string {\n    return this.readLongVarint().zzDecode().toString()\n  }\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a possibly unsafe JavaScript number\n   */\n  fixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads fixed 64 bits returned as a string\n   */\n  fixed64String (): string {\n    return this.readFixed64().toString()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64 (): bigint {\n    return this.readFixed64().toBigInt()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a possibly unsafe\n   * JavaScript number\n   */\n  sfixed64Number (): number {\n    return this.readFixed64().toNumber()\n  }\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits returned as a string\n   */\n  sfixed64String (): string {\n    return this.readFixed64().toString()\n  }\n}\n\nexport function createReader (buf: Uint8Array | Uint8ArrayList): Reader {\n  return new Uint8ArrayReader(buf instanceof Uint8Array ? buf : buf.subarray())\n}\n", "import { createReader } from './utils/reader.js'\nimport type { Codec, DecodeOptions } from './codec.js'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport function decodeMessage <T> (buf: Uint8Array | Uint8ArrayList, codec: Pick<Codec<T>, 'decode'>, opts?: DecodeOptions<T>): T {\n  const reader = createReader(buf)\n\n  return codec.decode(reader, undefined, opts)\n}\n", "import { allocUnsafe } from 'uint8arrays/alloc'\n\n/**\n * A general purpose buffer pool\n */\nexport default function pool (size?: number): (size: number) => Uint8Array {\n  const SIZE = size ?? 8192\n  const MAX = SIZE >>> 1\n  let slab: Uint8Array\n  let offset = SIZE\n  return function poolAlloc (size: number) {\n    if (size < 1 || size > MAX) {\n      return allocUnsafe(size)\n    }\n\n    if (offset + size > SIZE) {\n      slab = allocUnsafe(SIZE)\n      offset = 0\n    }\n\n    const buf = slab.subarray(offset, offset += size)\n\n    if ((offset & 7) !== 0) {\n      // align to 32 bit\n      offset = (offset | 7) + 1\n    }\n\n    return buf\n  }\n}\n", "import { encodeUint8Array, encodingLength } from 'uint8-varint'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { writeFloatLE, writeDoubleLE } from './float.js'\nimport { LongBits } from './longbits.js'\nimport pool from './pool.js'\nimport * as utf8 from './utf8.js'\nimport type { Writer } from '../index.js'\n\ninterface WriterOperation<T> {\n  (val: T, buf: Uint8Array, pos: number): any\n}\n\n/**\n * Constructs a new writer operation instance.\n *\n * @classdesc Scheduled writer operation\n */\nclass Op<T> {\n  /**\n   * Function to call\n   */\n  public fn: WriterOperation<T>\n\n  /**\n   * Value byte length\n   */\n  public len: number\n\n  /**\n   * Next operation\n   */\n  public next?: Op<any>\n\n  /**\n   * Value to write\n   */\n  public val: T\n\n  constructor (fn: WriterOperation<T>, len: number, val: T) {\n    this.fn = fn\n    this.len = len\n    this.next = undefined\n    this.val = val // type varies\n  }\n}\n\n/* istanbul ignore next */\nfunction noop (): void {}\n\n/**\n * Constructs a new writer state instance\n */\nclass State {\n  /**\n   * Current head\n   */\n  public head: Op<any>\n\n  /**\n   * Current tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Current buffer length\n   */\n  public len: number\n\n  /**\n   * Next state\n   */\n  public next?: State\n\n  constructor (writer: Uint8ArrayWriter) {\n    this.head = writer.head\n    this.tail = writer.tail\n    this.len = writer.len\n    this.next = writer.states\n  }\n}\n\nconst bufferPool = pool()\n\n/**\n * Allocates a buffer of the specified size\n */\nfunction alloc (size: number): Uint8Array {\n  if (globalThis.Buffer != null) {\n    return allocUnsafe(size)\n  }\n\n  return bufferPool(size)\n}\n\n/**\n * When a value is written, the writer calculates its byte length and puts it into a linked\n * list of operations to perform when finish() is called. This both allows us to allocate\n * buffers of the exact required size and reduces the amount of work we have to do compared\n * to first calculating over objects and then encoding over objects. In our case, the encoding\n * part is just a linked list walk calling operations with already prepared values.\n */\nclass Uint8ArrayWriter implements Writer {\n  /**\n   * Current length\n   */\n  public len: number\n\n  /**\n   * Operations head\n   */\n  public head: Op<any>\n\n  /**\n   * Operations tail\n   */\n  public tail: Op<any>\n\n  /**\n   * Linked forked states\n   */\n  public states?: any\n\n  constructor () {\n    this.len = 0\n    this.head = new Op(noop, 0, 0)\n    this.tail = this.head\n    this.states = null\n  }\n\n  /**\n   * Pushes a new operation to the queue\n   */\n  _push (fn: WriterOperation<any>, len: number, val: any): this {\n    this.tail = this.tail.next = new Op(fn, len, val)\n    this.len += len\n\n    return this\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32 (value: number): this {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n      (value = value >>> 0) <\n                128\n        ? 1\n        : value < 16384\n          ? 2\n          : value < 2097152\n            ? 3\n            : value < 268435456\n              ? 4\n              : 5,\n      value)).len\n    return this\n  }\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32 (value: number): this {\n    return value < 0\n      ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n      : this.uint32(value)\n  }\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32 (value: number): this {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number (value: number): this {\n    return this._push(encodeUint8Array, encodingLength(value), value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String (value: string): this {\n    return this.uint64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64 (value: bigint): this {\n    return this.uint64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number (value: number): this {\n    return this.uint64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String (value: string): this {\n    return this.uint64String(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number (value: number): this {\n    const bits = LongBits.fromNumber(value).zzEncode()\n    return this._push(writeVarint64, bits.length(), bits)\n  }\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String (value: string): this {\n    return this.sint64(BigInt(value))\n  }\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool (value: boolean): this {\n    return this._push(writeByte, 1, value ? 1 : 0)\n  }\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32 (value: number): this {\n    return this._push(writeFixed32, 4, value >>> 0)\n  }\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32 (value: number): this {\n    return this.fixed32(value)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64 (value: bigint): this {\n    const bits = LongBits.fromBigInt(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number (value: number): this {\n    const bits = LongBits.fromNumber(value)\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi)\n  }\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String (value: string): this {\n    return this.fixed64(BigInt(value))\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64 (value: bigint): this {\n    return this.fixed64(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number (value: number): this {\n    return this.fixed64Number(value)\n  }\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String (value: string): this {\n    return this.fixed64String(value)\n  }\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float (value: number): this {\n    return this._push(writeFloatLE, 4, value)\n  }\n\n  /**\n   * Writes a double (64 bit float).\n   *\n   * @function\n   * @param {number} value - Value to write\n   * @returns {Writer} `this`\n   */\n  double (value: number): this {\n    return this._push(writeDoubleLE, 8, value)\n  }\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes (value: Uint8Array): this {\n    const len = value.length >>> 0\n\n    if (len === 0) {\n      return this._push(writeByte, 1, 0)\n    }\n\n    return this.uint32(len)._push(writeBytes, len, value)\n  }\n\n  /**\n   * Writes a string\n   */\n  string (value: string): this {\n    const len = utf8.length(value)\n    return len !== 0\n      ? this.uint32(len)._push(utf8.write, len, value)\n      : this._push(writeByte, 1, 0)\n  }\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork (): this {\n    this.states = new State(this)\n    this.head = this.tail = new Op(noop, 0, 0)\n    this.len = 0\n    return this\n  }\n\n  /**\n   * Resets this instance to the last state\n   */\n  reset (): this {\n    if (this.states != null) {\n      this.head = this.states.head\n      this.tail = this.states.tail\n      this.len = this.states.len\n      this.states = this.states.next\n    } else {\n      this.head = this.tail = new Op(noop, 0, 0)\n      this.len = 0\n    }\n    return this\n  }\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim (): this {\n    const head = this.head\n    const tail = this.tail\n    const len = this.len\n    this.reset().uint32(len)\n    if (len !== 0) {\n      this.tail.next = head.next // skip noop\n      this.tail = tail\n      this.len += len\n    }\n    return this\n  }\n\n  /**\n   * Finishes the write operation\n   */\n  finish (): Uint8Array {\n    let head = this.head.next // skip noop\n    const buf = alloc(this.len)\n    let pos = 0\n    while (head != null) {\n      head.fn(head.val, buf, pos)\n      pos += head.len\n      head = head.next\n    }\n    // this.head = this.tail = null;\n    return buf\n  }\n}\n\nfunction writeByte (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n}\n\nfunction writeVarint32 (val: number, buf: Uint8Array, pos: number): void {\n  while (val > 127) {\n    buf[pos++] = val & 127 | 128\n    val >>>= 7\n  }\n  buf[pos] = val\n}\n\n/**\n * Constructs a new varint writer operation instance.\n *\n * @classdesc Scheduled varint writer operation\n */\nclass VarintOp extends Op<number> {\n  public next?: Op<any>\n\n  constructor (len: number, val: number) {\n    super(writeVarint32, len, val)\n    this.next = undefined\n  }\n}\n\nfunction writeVarint64 (val: LongBits, buf: Uint8Array, pos: number): void {\n  while (val.hi !== 0) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0\n    val.hi >>>= 7\n  }\n  while (val.lo > 127) {\n    buf[pos++] = val.lo & 127 | 128\n    val.lo = val.lo >>> 7\n  }\n  buf[pos++] = val.lo\n}\n\nfunction writeFixed32 (val: number, buf: Uint8Array, pos: number): void {\n  buf[pos] = val & 255\n  buf[pos + 1] = val >>> 8 & 255\n  buf[pos + 2] = val >>> 16 & 255\n  buf[pos + 3] = val >>> 24\n}\n\nfunction writeBytes (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos)\n}\n\nif (globalThis.Buffer != null) {\n  Uint8ArrayWriter.prototype.bytes = function (value: Uint8Array) {\n    const len = value.length >>> 0\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeBytesBuffer, len, value)\n    }\n\n    return this\n  }\n\n  Uint8ArrayWriter.prototype.string = function (value: string) {\n    const len = globalThis.Buffer.byteLength(value)\n\n    this.uint32(len)\n\n    if (len > 0) {\n      this._push(writeStringBuffer, len, value)\n    }\n\n    return this\n  }\n}\n\nfunction writeBytesBuffer (val: Uint8Array, buf: Uint8Array, pos: number): void {\n  buf.set(val, pos) // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n  // also works for plain array values\n}\n\nfunction writeStringBuffer (val: string, buf: Uint8Array, pos: number): void {\n  if (val.length < 40) {\n    // plain js is faster for short strings (probably due to redundant assertions)\n    utf8.write(val, buf, pos)\n    // @ts-expect-error buf isn't a Uint8Array?\n  } else if (buf.utf8Write != null) {\n    // @ts-expect-error buf isn't a Uint8Array?\n    buf.utf8Write(val, pos)\n  } else {\n    buf.set(uint8ArrayFromString(val), pos)\n  }\n}\n\n/**\n * Creates a new writer\n */\nexport function createWriter (): Writer {\n  return new Uint8ArrayWriter()\n}\n", "import { createWriter } from './utils/writer.js'\nimport type { Codec } from './codec.js'\n\nexport function encodeMessage <T> (message: Partial<T>, codec: Pick<Codec<T>, 'encode'>): Uint8Array {\n  const w = createWriter()\n\n  codec.encode(message, w, {\n    lengthDelimited: false\n  })\n\n  return w.finish()\n}\n", "import type { Writer, Reader } from './index.js'\n\n// https://developers.google.com/protocol-buffers/docs/encoding#structure\nexport enum CODEC_TYPES {\n  VARINT = 0,\n  BIT64,\n  LENGTH_DELIMITED,\n  START_GROUP,\n  END_GROUP,\n  BIT32\n}\n\nexport interface EncodeOptions {\n  lengthDelimited?: boolean\n  writeDefaults?: boolean\n}\n\nexport interface EncodeFunction<T> {\n  (value: Partial<T>, writer: Writer, opts?: EncodeOptions): void\n}\n\n// protobuf types that contain multiple values\ntype CollectionTypes = any[] | Map<any, any>\n\n// protobuf types that are not collections or messages\ntype PrimitiveTypes = boolean | number | string | bigint | Uint8Array\n\n// recursive array/map field length limits\ntype CollectionLimits <T> = {\n  [K in keyof T]: T[K] extends CollectionTypes ? number :\n    T[K] extends PrimitiveTypes ? never : Limits<T[K]>\n}\n\n// recursive array member array/map field length limits\ntype ArrayElementLimits <T> = {\n  [K in keyof T as `${string & K}$`]: T[K] extends Array<infer ElementType> ?\n      (ElementType extends PrimitiveTypes ? never : Limits<ElementType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// recursive map value array/map field length limits\ntype MapValueLimits <T> = {\n  [K in keyof T as `${string & K}$value`]: T[K] extends Map<any, infer MapValueType> ?\n      (MapValueType extends PrimitiveTypes ? never : Limits<MapValueType>) :\n      (T[K] extends PrimitiveTypes ? never : Limits<T[K]>)\n}\n\n// union of collection and array elements\ntype Limits<T> = Partial<CollectionLimits<T> & ArrayElementLimits<T> & MapValueLimits<T>>\n\nexport interface DecodeOptions<T> {\n  /**\n   * Runtime-specified limits for lengths of repeated/map fields\n   */\n  limits?: Limits<T>\n}\n\nexport interface DecodeFunction<T> {\n  (reader: Reader, length?: number, opts?: DecodeOptions<T>): T\n}\n\nexport interface Codec<T> {\n  name: string\n  type: CODEC_TYPES\n  encode: EncodeFunction<T>\n  decode: DecodeFunction<T>\n}\n\nexport function createCodec <T> (name: string, type: CODEC_TYPES, encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return {\n    name,\n    type,\n    encode,\n    decode\n  }\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { DecodeFunction, EncodeFunction, Codec } from '../codec.js'\n\nexport function enumeration <T> (v: any): Codec<T> {\n  function findValue (val: string | number): number {\n    // Use the reverse mapping to look up the enum key for the stored value\n    // https://www.typescriptlang.org/docs/handbook/enums.html#reverse-mappings\n    if (v[val.toString()] == null) {\n      throw new Error('Invalid enum value')\n    }\n\n    return v[val]\n  }\n\n  const encode: EncodeFunction<number | string> = function enumEncode (val, writer) {\n    const enumValue = findValue(val)\n\n    writer.int32(enumValue)\n  }\n\n  const decode: DecodeFunction<number | string> = function enumDecode (reader) {\n    const val = reader.int32()\n\n    return findValue(val)\n  }\n\n  // @ts-expect-error yeah yeah\n  return createCodec('enum', CODEC_TYPES.VARINT, encode, decode)\n}\n", "import { createCodec, CODEC_TYPES } from '../codec.js'\nimport type { EncodeFunction, DecodeFunction, Codec } from '../codec.js'\n\nexport interface Factory<A, T> {\n  new (obj: A): T\n}\n\nexport function message <T> (encode: EncodeFunction<T>, decode: DecodeFunction<T>): Codec<T> {\n  return createCodec('message', CODEC_TYPES.LENGTH_DELIMITED, encode, decode)\n}\n", "/**\n * @packageDocumentation\n *\n * This module contains serialization/deserialization code used when encoding/decoding protobufs.\n *\n * It should be declared as a dependency of your project:\n *\n * ```console\n * npm i protons-runtime\n * ```\n */\n\nimport type { Codec } from './codec.js'\n\nexport interface FieldDef {\n  name: string\n  codec: Codec<any>\n  optional?: true\n  repeats?: true\n  packed?: true\n}\n\nexport {\n  decodeMessage\n} from './decode.js'\n\nexport {\n  encodeMessage\n} from './encode.js'\n\nexport { enumeration } from './codecs/enum.js'\nexport { message } from './codecs/message.js'\nexport { createReader as reader } from './utils/reader.js'\nexport { createWriter as writer } from './utils/writer.js'\nexport type { Codec, EncodeOptions, DecodeOptions } from './codec.js'\n\nexport interface Writer {\n  /**\n   * Current length\n   */\n  len: number\n\n  /**\n   * Writes an unsigned 32 bit value as a varint\n   */\n  uint32(value: number): this\n\n  /**\n   * Writes a signed 32 bit value as a varint`\n   */\n  int32(value: number): this\n\n  /**\n   * Writes a 32 bit value as a varint, zig-zag encoded\n   */\n  sint32(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64(value: bigint): this\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64Number(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as a varint\n   */\n  uint64String(value: string): this\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64(value: bigint): this\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64Number(value: number): this\n\n  /**\n   * Writes a signed 64 bit value as a varint\n   */\n  int64String(value: string): this\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64(value: bigint): this\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64Number(value: number): this\n\n  /**\n   * Writes a signed 64 bit value as a varint, zig-zag encoded\n   */\n  sint64String(value: string): this\n\n  /**\n   * Writes a boolish value as a varint\n   */\n  bool(value: boolean): this\n\n  /**\n   * Writes an unsigned 32 bit value as fixed 32 bits\n   */\n  fixed32(value: number): this\n\n  /**\n   * Writes a signed 32 bit value as fixed 32 bits\n   */\n  sfixed32(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64(value: bigint): this\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64Number(value: number): this\n\n  /**\n   * Writes an unsigned 64 bit value as fixed 64 bits\n   */\n  fixed64String(value: string): this\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64(value: bigint): this\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64Number(value: number): this\n\n  /**\n   * Writes a signed 64 bit value as fixed 64 bits\n   */\n  sfixed64String(value: string): this\n\n  /**\n   * Writes a float (32 bit)\n   */\n  float(value: number): this\n\n  /**\n   * Writes a double (64 bit float)\n   */\n  double(value: number): this\n\n  /**\n   * Writes a sequence of bytes\n   */\n  bytes(value: Uint8Array): this\n\n  /**\n   * Writes a string\n   */\n  string(value: string): this\n\n  /**\n   * Forks this writer's state by pushing it to a stack.\n   * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n   */\n  fork(): this\n\n  /**\n   * Resets this instance to the last state.\n   */\n  reset(): this\n\n  /**\n   * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n   */\n  ldelim(): this\n\n  /**\n   * Finishes the write operation\n   */\n  finish(): Uint8Array\n}\n\nexport interface Reader {\n  /**\n   * Read buffer\n   */\n  buf: Uint8Array\n\n  /**\n   * Read buffer position\n   */\n  pos: number\n\n  /**\n   * Read buffer length\n   */\n  len: number\n\n  /**\n   * Reads a varint as an unsigned 32 bit value\n   */\n  uint32(): number\n\n  /**\n   * Reads a varint as a signed 32 bit value\n   */\n  int32(): number\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 32 bit value\n   */\n  sint32(): number\n\n  /**\n   * Reads a varint as a boolean\n   */\n  bool(): boolean\n\n  /**\n   * Reads fixed 32 bits as an unsigned 32 bit integer\n   */\n  fixed32(): number\n\n  /**\n   * Reads fixed 32 bits as a signed 32 bit integer\n   */\n  sfixed32(): number\n\n  /**\n   * Reads a float (32 bit) as a number\n   */\n  float(): number\n\n  /**\n   * Reads a double (64 bit float) as a number\n   */\n  double(): number\n\n  /**\n   * Reads a sequence of bytes preceded by its length as a varint\n   */\n  bytes(): Uint8Array\n\n  /**\n   * Reads a string preceded by its byte length as a varint\n   */\n  string(): string\n\n  /**\n   * Skips the specified number of bytes if specified, otherwise skips a varints`\n   */\n  skip(length?: number): void\n\n  /**\n   * Skips the next element of the specified wire type\n   */\n  skipType(wireType: number): void\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64(): bigint\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64Number(): number\n\n  /**\n   * Reads a varint as a signed 64 bit value\n   */\n  int64String(): string\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64(): bigint\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64Number(): number\n\n  /**\n   * Reads a varint as an unsigned 64 bit value\n   */\n  uint64String(): string\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64(): bigint\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64Number(): number\n\n  /**\n   * Reads a zig-zag encoded varint as a signed 64 bit value\n   */\n  sint64String(): string\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64(): bigint\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64Number(): number\n\n  /**\n   * Reads fixed 64 bits\n   */\n  fixed64String(): string\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64(): bigint\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64Number(): number\n\n  /**\n   * Reads zig-zag encoded fixed 64 bits\n   */\n  sfixed64String(): string\n}\n\n/**\n * This will be removed in a future release\n *\n * @deprecated\n */\nexport class CodeError extends Error {\n  public code: string\n\n  constructor (message: string, code: string) {\n    super(message)\n\n    this.code = code\n  }\n}\n\n/**\n * Thrown when a repeated field has too many elements\n */\nexport class MaxLengthError extends Error {\n  /**\n   * This will be removed in a future release\n   *\n   * @deprecated use the `.name` property instead\n   */\n  public code = 'ERR_MAX_LENGTH'\n  public name = 'MaxLengthError'\n}\n\n/**\n * Thrown when a map has too many elements\n */\nexport class MaxSizeError extends Error {\n  /**\n   * This will be removed in a future release\n   *\n   * @deprecated use the `.name` property instead\n   */\n  public code = 'ERR_MAX_SIZE'\n  public name = 'MaxSizeError'\n}\n\nexport class ParseError extends Error {\n  /**\n   * This will be removed in a future release\n   *\n   * @deprecated use the `.name` property instead\n   */\n  public code = 'ERR_PARSE_ERROR'\n  public name = 'ParseError'\n}\n\nexport class NoMessagesFoundError extends Error {\n  /**\n   * This will be removed in a future release\n   *\n   * @deprecated use the `.name` property instead\n   */\n  public code = 'ERR_NO_MESSAGES_FOUND'\n  public name = 'NoMessagesFoundError'\n}\n", "import { decodeMessage, encodeMessage, enumeration, message } from 'protons-runtime'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport enum KeyType {\n  RSA = 'RSA',\n  Ed25519 = 'Ed25519',\n  secp256k1 = 'secp256k1',\n  ECDSA = 'ECDSA'\n}\n\nenum __KeyTypeValues {\n  RSA = 0,\n  Ed25519 = 1,\n  secp256k1 = 2,\n  ECDSA = 3\n}\n\nexport namespace KeyType {\n  export const codec = (): Codec<KeyType> => {\n    return enumeration<KeyType>(__KeyTypeValues)\n  }\n}\nexport interface PublicKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PublicKey {\n  let _codec: Codec<PublicKey>\n\n  export const codec = (): Codec<PublicKey> => {\n    if (_codec == null) {\n      _codec = message<PublicKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PublicKey>): Uint8Array => {\n    return encodeMessage(obj, PublicKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PublicKey>): PublicKey => {\n    return decodeMessage(buf, PublicKey.codec(), opts)\n  }\n}\n\nexport interface PrivateKey {\n  Type?: KeyType\n  Data?: Uint8Array\n}\n\nexport namespace PrivateKey {\n  let _codec: Codec<PrivateKey>\n\n  export const codec = (): Codec<PrivateKey> => {\n    if (_codec == null) {\n      _codec = message<PrivateKey>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.Type != null) {\n          w.uint32(8)\n          KeyType.codec().encode(obj.Type, w)\n        }\n\n        if (obj.Data != null) {\n          w.uint32(18)\n          w.bytes(obj.Data)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {}\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              obj.Type = KeyType.codec().decode(reader)\n              break\n            }\n            case 2: {\n              obj.Data = reader.bytes()\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<PrivateKey>): Uint8Array => {\n    return encodeMessage(obj, PrivateKey.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PrivateKey>): PrivateKey => {\n    return decodeMessage(buf, PrivateKey.codec(), opts)\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { randomBytes as randB } from '@noble/hashes/utils.js'\n\n/**\n * Generates a Uint8Array with length `number` populated by random bytes\n */\nexport default function randomBytes (length: number): Uint8Array {\n  if (isNaN(length) || length <= 0) {\n    throw new InvalidParametersError('random bytes length must be a Number bigger than 0')\n  }\n  return randB(length)\n}\n", "import { InvalidParametersError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { sha256 } from '@noble/hashes/sha2.js'\nimport { create } from 'multiformats/hashes/digest'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport * as pb from '../keys.js'\nimport { decodeDer, encodeBitString, encodeInteger, encodeSequence } from './der.js'\nimport { RSAPrivateKey as RSAPrivateKeyClass, RSAPublicKey as RSAPublicKeyClass } from './rsa.js'\nimport { generateRSAKey, rsaKeySize } from './index.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { RSAPrivateKey, RSAPublicKey } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport const MAX_RSA_KEY_SIZE = 8192\nconst SHA2_256_CODE = 0x12\nconst MAX_RSA_JWK_SIZE = 1062\n\nconst RSA_ALGORITHM_IDENTIFIER = Uint8Array.from([\n  0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00\n])\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1ToJwk (bytes: Uint8Array): JsonWebKey {\n  const message = decodeDer(bytes)\n\n  return pkcs1MessageToJwk(message)\n}\n\n/**\n * Convert a PKCS#1 in ASN1 DER format to a JWK private key\n */\nexport function pkcs1MessageToJwk (message: any): JsonWebKey {\n  return {\n    n: uint8ArrayToString(message[1], 'base64url'),\n    e: uint8ArrayToString(message[2], 'base64url'),\n    d: uint8ArrayToString(message[3], 'base64url'),\n    p: uint8ArrayToString(message[4], 'base64url'),\n    q: uint8ArrayToString(message[5], 'base64url'),\n    dp: uint8ArrayToString(message[6], 'base64url'),\n    dq: uint8ArrayToString(message[7], 'base64url'),\n    qi: uint8ArrayToString(message[8], 'base64url'),\n    kty: 'RSA'\n  }\n}\n\n/**\n * Convert a JWK private key into PKCS#1 in ASN1 DER format\n */\nexport function jwkToPkcs1 (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null || jwk.d == null || jwk.p == null || jwk.q == null || jwk.dp == null || jwk.dq == null || jwk.qi == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  return encodeSequence([\n    encodeInteger(Uint8Array.from([0])),\n    encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.e, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.d, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.p, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.q, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dp, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.dq, 'base64url')),\n    encodeInteger(uint8ArrayFromString(jwk.qi, 'base64url'))\n  ]).subarray()\n}\n\n/**\n * Convert a PKIX in ASN1 DER format to a JWK public key\n */\nexport function pkixToJwk (bytes: Uint8Array): JsonWebKey {\n  const message = decodeDer(bytes, {\n    offset: 0\n  })\n\n  return pkixMessageToJwk(message)\n}\n\nexport function pkixMessageToJwk (message: any): JsonWebKey {\n  const keys = decodeDer(message[1], {\n    offset: 0\n  })\n\n  // this looks fragile but DER is a canonical format so we are safe to have\n  // deeply property chains like this\n  return {\n    kty: 'RSA',\n    n: uint8ArrayToString(\n      keys[0],\n      'base64url'\n    ),\n    e: uint8ArrayToString(\n      keys[1],\n      'base64url'\n    )\n  }\n}\n\n/**\n * Convert a JWK public key to PKIX in ASN1 DER format\n */\nexport function jwkToPkix (jwk: JsonWebKey): Uint8Array {\n  if (jwk.n == null || jwk.e == null) {\n    throw new InvalidParametersError('JWK was missing components')\n  }\n\n  const subjectPublicKeyInfo = encodeSequence([\n    RSA_ALGORITHM_IDENTIFIER,\n    encodeBitString(\n      encodeSequence([\n        encodeInteger(uint8ArrayFromString(jwk.n, 'base64url')),\n        encodeInteger(uint8ArrayFromString(jwk.e, 'base64url'))\n      ])\n    )\n  ])\n\n  return subjectPublicKeyInfo.subarray()\n}\n\n/**\n * Turn PKCS#1 DER bytes into a PrivateKey\n */\nexport function pkcs1ToRSAPrivateKey (bytes: Uint8Array): RSAPrivateKey {\n  const message = decodeDer(bytes)\n\n  return pkcs1MessageToRSAPrivateKey(message)\n}\n\n/**\n * Turn PKCS#1 DER bytes into a PrivateKey\n */\nexport function pkcs1MessageToRSAPrivateKey (message: any): RSAPrivateKey {\n  const jwk = pkcs1MessageToJwk(message)\n\n  return jwkToRSAPrivateKey(jwk)\n}\n\n/**\n * Turn a PKIX message into a PublicKey\n */\nexport function pkixToRSAPublicKey (bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  if (bytes.byteLength >= MAX_RSA_JWK_SIZE) {\n    throw new InvalidPublicKeyError('Key size is too large')\n  }\n\n  const message = decodeDer(bytes, {\n    offset: 0\n  })\n\n  return pkixMessageToRSAPublicKey(message, bytes, digest)\n}\n\nexport function pkixMessageToRSAPublicKey (message: any, bytes: Uint8Array, digest?: Digest<18, number>): RSAPublicKey {\n  const jwk = pkixMessageToJwk(message)\n\n  if (digest == null) {\n    const hash = sha256(pb.PublicKey.encode({\n      Type: pb.KeyType.RSA,\n      Data: bytes\n    }))\n    digest = create(SHA2_256_CODE, hash)\n  }\n\n  return new RSAPublicKeyClass(jwk, digest)\n}\n\nexport function jwkToRSAPrivateKey (jwk: JsonWebKey): RSAPrivateKey {\n  if (rsaKeySize(jwk) > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = jwkToJWKKeyPair(jwk)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\nexport async function generateRSAKeyPair (bits: number): Promise<RSAPrivateKey> {\n  if (bits > MAX_RSA_KEY_SIZE) {\n    throw new InvalidParametersError('Key size is too large')\n  }\n\n  const keys = await generateRSAKey(bits)\n  const hash = sha256(pb.PublicKey.encode({\n    Type: pb.KeyType.RSA,\n    Data: jwkToPkix(keys.publicKey)\n  }))\n  const digest = create(SHA2_256_CODE, hash)\n\n  return new RSAPrivateKeyClass(keys.privateKey, new RSAPublicKeyClass(keys.publicKey, digest))\n}\n\n/**\n * Takes a jwk key and returns a JWK KeyPair\n */\nexport function jwkToJWKKeyPair (key: JsonWebKey): JWKKeyPair {\n  if (key == null) {\n    throw new InvalidParametersError('Missing key parameter')\n  }\n\n  return {\n    privateKey: key,\n    publicKey: {\n      kty: key.kty,\n      n: key.n,\n      e: key.e\n    }\n  }\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { hashAndSign, utils, hashAndVerify } from './index.js'\nimport type { RSAPublicKey as RSAPublicKeyInterface, RSAPrivateKey as RSAPrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class RSAPublicKey implements RSAPublicKeyInterface {\n  public readonly type = 'RSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n  private readonly _multihash: Digest<18, number>\n\n  constructor (jwk: JsonWebKey, digest: Digest<18, number>) {\n    this.jwk = jwk\n    this._multihash = digest\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = utils.jwkToPkix(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  toMultihash (): Digest<18, number> {\n    return this._multihash\n  }\n\n  toCID (): CID<unknown, 114, 18, 1> {\n    return CID.createV1(114, this._multihash)\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean | Promise<boolean> {\n    return hashAndVerify(this.jwk, sig, data, options)\n  }\n}\n\nexport class RSAPrivateKey implements RSAPrivateKeyInterface {\n  public readonly type = 'RSA'\n  public readonly jwk: JsonWebKey\n  private _raw?: Uint8Array\n  public readonly publicKey: RSAPublicKey\n\n  constructor (jwk: JsonWebKey, publicKey: RSAPublicKey) {\n    this.jwk = jwk\n    this.publicKey = publicKey\n  }\n\n  get raw (): Uint8Array {\n    if (this._raw == null) {\n      this._raw = utils.jwkToPkcs1(this.jwk)\n    }\n\n    return this._raw\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this.jwk, message, options)\n  }\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport randomBytes from '../../random-bytes.js'\nimport webcrypto from '../../webcrypto/index.js'\nimport * as utils from './utils.js'\nimport type { JWKKeyPair } from '../interface.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport const RSAES_PKCS1_V1_5_OID = '1.2.840.113549.1.1.1'\nexport { utils }\n\nexport async function generateRSAKey (bits: number, options?: AbortOptions): Promise<JWKKeyPair> {\n  const pair = await webcrypto.get().subtle.generateKey(\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      modulusLength: bits,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: { name: 'SHA-256' }\n    },\n    true,\n    ['sign', 'verify']\n  )\n  options?.signal?.throwIfAborted()\n\n  const keys = await exportKey(pair, options)\n\n  return {\n    privateKey: keys[0],\n    publicKey: keys[1]\n  }\n}\n\nexport { randomBytes as getRandomValues }\n\nexport async function hashAndSign (key: JsonWebKey, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<Uint8Array> {\n  const privateKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['sign']\n  )\n  options?.signal?.throwIfAborted()\n\n  const sig = await webcrypto.get().subtle.sign(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    privateKey,\n    msg instanceof Uint8Array ? msg : msg.subarray()\n  )\n  options?.signal?.throwIfAborted()\n\n  return new Uint8Array(sig, 0, sig.byteLength)\n}\n\nexport async function hashAndVerify (key: JsonWebKey, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<boolean> {\n  const publicKey = await webcrypto.get().subtle.importKey(\n    'jwk',\n    key,\n    {\n      name: 'RSASSA-PKCS1-v1_5',\n      hash: { name: 'SHA-256' }\n    },\n    false,\n    ['verify']\n  )\n  options?.signal?.throwIfAborted()\n\n  const result = await webcrypto.get().subtle.verify(\n    { name: 'RSASSA-PKCS1-v1_5' },\n    publicKey,\n    sig,\n    msg instanceof Uint8Array ? msg : msg.subarray()\n  )\n  options?.signal?.throwIfAborted()\n\n  return result\n}\n\nasync function exportKey (pair: CryptoKeyPair, options?: AbortOptions): Promise<[JsonWebKey, JsonWebKey]> {\n  if (pair.privateKey == null || pair.publicKey == null) {\n    throw new InvalidParametersError('Private and public key are required')\n  }\n\n  const result = await Promise.all([\n    webcrypto.get().subtle.exportKey('jwk', pair.privateKey),\n    webcrypto.get().subtle.exportKey('jwk', pair.publicKey)\n  ])\n  options?.signal?.throwIfAborted()\n\n  return result\n}\n\nexport function rsaKeySize (jwk: JsonWebKey): number {\n  if (jwk.kty !== 'RSA') {\n    throw new InvalidParametersError('invalid key type')\n  } else if (jwk.n == null) {\n    throw new InvalidParametersError('invalid key modulus')\n  }\n  const bytes = uint8ArrayFromString(jwk.n, 'base64url')\n  return bytes.length * 8\n}\n", "/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash, clean, type CHash, type Hash } from './utils.ts';\n\n/** Internal class for HMAC. */\nexport class _HMAC<T extends Hash<T>> implements Hash<_HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, key: Uint8Array) {\n    ahash(hash);\n    abytes(key, undefined, 'key');\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    clean(pad);\n  }\n  update(buf: Uint8Array): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen, 'output');\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: _HMAC<T>): _HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  clone(): _HMAC<T> {\n    return this._cloneInto();\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array;\n  create(hash: CHash, key: Uint8Array): _HMAC<any>;\n} = (hash: CHash, key: Uint8Array, message: Uint8Array): Uint8Array =>\n  new _HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Uint8Array) => new _HMAC<any>(hash, key);\n", "/**\n * Short Weierstrass curve methods. The formula is: y\u00B2 = x\u00B3 + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac as nobleHmac } from '@noble/hashes/hmac.js';\nimport { ahash } from '@noble/hashes/utils.js';\nimport {\n  abool,\n  abytes,\n  aInRange,\n  bitLen,\n  bitMask,\n  bytesToHex,\n  bytesToNumberBE,\n  concatBytes,\n  createHmacDrbg,\n  hexToBytes,\n  isBytes,\n  memoized,\n  numberToHexUnpadded,\n  validateObject,\n  randomBytes as wcRandomBytes,\n  type CHash,\n  type Signer,\n} from '../utils.ts';\nimport {\n  createCurveFields,\n  createKeygen,\n  mulEndoUnsafe,\n  negateCt,\n  normalizeZ,\n  wNAF,\n  type AffinePoint,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport {\n  FpInvertBatch,\n  getMinHashLength,\n  mapHashToField,\n  validateField,\n  type IField,\n} from './modular.ts';\n\nexport type { AffinePoint };\n\ntype EndoBasis = [[bigint, bigint], [bigint, bigint]];\n/**\n * When Weierstrass curve has `a=0`, it becomes Koblitz curve.\n * Koblitz curves allow using **efficiently-computable GLV endomorphism \u03C8**.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n *\n * Endomorphism consists of beta, lambda and splitScalar:\n *\n * 1. GLV endomorphism \u03C8 transforms a point: `P = (x, y) \u21A6 \u03C8(P) = (\u03B2\u00B7x mod p, y)`\n * 2. GLV scalar decomposition transforms a scalar: `k \u2261 k\u2081 + k\u2082\u00B7\u03BB (mod n)`\n * 3. Then these are combined: `k\u00B7P = k\u2081\u00B7P + k\u2082\u00B7\u03C8(P)`\n * 4. Two 128-bit point-by-scalar multiplications + one point addition is faster than\n *    one 256-bit multiplication.\n *\n * where\n * * beta: \u03B2 \u2208 F\u209A with \u03B2\u00B3 = 1, \u03B2 \u2260 1\n * * lambda: \u03BB \u2208 F\u2099 with \u03BB\u00B3 = 1, \u03BB \u2260 1\n * * splitScalar decomposes k \u21A6 k\u2081, k\u2082, by using reduced basis vectors.\n *   Gauss lattice reduction calculates them from initial basis vectors `(n, 0), (-\u03BB, 0)`\n *\n * Check out `test/misc/endomorphism.js` and\n * [gist](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n */\nexport type EndomorphismOpts = {\n  beta: bigint;\n  basises?: EndoBasis;\n  splitScalar?: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num: bigint, den: bigint) => (num + (num >= 0 ? den : -den) / _2n) / den;\n\nexport type ScalarEndoParts = { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n\n/**\n * Splits scalar for GLV endomorphism.\n */\nexport function _splitEndoScalar(k: bigint, basis: EndoBasis, n: bigint): ScalarEndoParts {\n  // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n  // Since part can be negative, we need to do this on point.\n  // TODO: verifyScalar function which consumes lambda\n  const [[a1, b1], [a2, b2]] = basis;\n  const c1 = divNearest(b2 * k, n);\n  const c2 = divNearest(-b1 * k, n);\n  // |k1|/|k2| is < sqrt(N), but can be negative.\n  // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n  let k1 = k - c1 * a1 - c2 * a2;\n  let k2 = -c1 * b1 - c2 * b2;\n  const k1neg = k1 < _0n;\n  const k2neg = k2 < _0n;\n  if (k1neg) k1 = -k1;\n  if (k2neg) k2 = -k2;\n  // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n  // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n  const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n; // Half bits of N\n  if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n    throw new Error('splitScalar (endomorphism): failed, k=' + k);\n  }\n  return { k1neg, k1, k2neg, k2 };\n}\n\n/**\n * Option to enable hedged signatures with improved security.\n *\n * * Randomly generated k is bad, because broken CSPRNG would leak private keys.\n * * Deterministic k (RFC6979) is better; but is suspectible to fault attacks.\n *\n * We allow using technique described in RFC6979 3.6: additional k', a.k.a. adding randomness\n * to deterministic sig. If CSPRNG is broken & randomness is weak, it would STILL be as secure\n * as ordinary sig without ExtraEntropy.\n *\n * * `true` means \"fetch data, from CSPRNG, incorporate it into k generation\"\n * * `false` means \"disable extra entropy, use purely deterministic k\"\n * * `Uint8Array` passed means \"incorporate following data into k generation\"\n *\n * https://paulmillr.com/posts/deterministic-signatures/\n */\nexport type ECDSAExtraEntropy = boolean | Uint8Array;\n/**\n * - `compact` is the default format\n * - `recovered` is the same as compact, but with an extra byte indicating recovery byte\n * - `der` is ASN.1 DER encoding\n */\nexport type ECDSASignatureFormat = 'compact' | 'recovered' | 'der';\n/**\n * - `prehash`: (default: true) indicates whether to do sha256(message).\n *   When a custom hash is used, it must be set to `false`.\n */\nexport type ECDSARecoverOpts = {\n  prehash?: boolean;\n};\n/**\n * - `prehash`: (default: true) indicates whether to do sha256(message).\n *   When a custom hash is used, it must be set to `false`.\n * - `lowS`: (default: true) prohibits signatures which have (sig.s >= CURVE.n/2n).\n *   Compatible with BTC/ETH. Setting `lowS: false` allows to create malleable signatures,\n *   which is default openssl behavior.\n *   Non-malleable signatures can still be successfully verified in openssl.\n * - `format`: (default: 'compact') 'compact' or 'recovered' with recovery byte\n */\nexport type ECDSAVerifyOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASignatureFormat;\n};\n/**\n * - `prehash`: (default: true) indicates whether to do sha256(message).\n *   When a custom hash is used, it must be set to `false`.\n * - `lowS`: (default: true) prohibits signatures which have (sig.s >= CURVE.n/2n).\n *   Compatible with BTC/ETH. Setting `lowS: false` allows to create malleable signatures,\n *   which is default openssl behavior.\n *   Non-malleable signatures can still be successfully verified in openssl.\n * - `format`: (default: 'compact') 'compact' or 'recovered' with recovery byte\n * - `extraEntropy`: (default: false) creates sigs with increased security, see {@link ECDSAExtraEntropy}\n */\nexport type ECDSASignOpts = {\n  prehash?: boolean;\n  lowS?: boolean;\n  format?: ECDSASignatureFormat;\n  extraEntropy?: ECDSAExtraEntropy;\n};\n\nfunction validateSigFormat(format: string): ECDSASignatureFormat {\n  if (!['compact', 'recovered', 'der'].includes(format))\n    throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n  return format as ECDSASignatureFormat;\n}\n\nfunction validateSigOpts<T extends ECDSASignOpts, D extends Required<ECDSASignOpts>>(\n  opts: T,\n  def: D\n): Required<ECDSASignOpts> {\n  const optsn: ECDSASignOpts = {};\n  for (let optName of Object.keys(def)) {\n    // @ts-ignore\n    optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n  }\n  abool(optsn.lowS!, 'lowS');\n  abool(optsn.prehash!, 'prehash');\n  if (optsn.format !== undefined) validateSigFormat(optsn.format);\n  return optsn as Required<ECDSASignOpts>;\n}\n\n/** Instance methods for 3D XYZ projective points. */\nexport interface WeierstrassPoint<T> extends CurvePoint<T, WeierstrassPoint<T>> {\n  /** projective X coordinate. Different from affine x. */\n  readonly X: T;\n  /** projective Y coordinate. Different from affine y. */\n  readonly Y: T;\n  /** projective z coordinate */\n  readonly Z: T;\n  /** affine x coordinate. Different from projective X. */\n  get x(): T;\n  /** affine y coordinate. Different from projective Y. */\n  get y(): T;\n  /** Encodes point using IEEE P1363 (DER) encoding. First byte is 2/3/4. Default = isCompressed. */\n  toBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n}\n\n/** Static methods for 3D XYZ projective points. */\nexport interface WeierstrassPointCons<T> extends CurvePointCons<WeierstrassPoint<T>> {\n  /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  new (X: T, Y: T, Z: T): WeierstrassPoint<T>;\n  CURVE(): WeierstrassOpts<T>;\n}\n\n/**\n * Weierstrass curve options.\n *\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor, usually 1. h*n is group order; n is subgroup order\n * * a: formula param, must be in field of p\n * * b: formula param, must be in field of p\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type WeierstrassOpts<T> = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b: T;\n  Gx: T;\n  Gy: T;\n}>;\n\n// When a cofactor != 1, there can be an effective methods to:\n// 1. Determine whether a point is torsion-free\n// 2. Clear torsion component\nexport type WeierstrassExtraOpts<T> = Partial<{\n  Fp: IField<T>;\n  Fn: IField<bigint>;\n  allowInfinityPoint: boolean;\n  endo: EndomorphismOpts;\n  isTorsionFree: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => boolean;\n  clearCofactor: (c: WeierstrassPointCons<T>, point: WeierstrassPoint<T>) => WeierstrassPoint<T>;\n  fromBytes: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes: (\n    c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ) => Uint8Array;\n}>;\n\n/**\n * Options for ECDSA signatures over a Weierstrass curve.\n *\n * * lowS: (default: true) whether produced / verified signatures occupy low half of ecdsaOpts.p. Prevents malleability.\n * * hmac: (default: noble-hashes hmac) function, would be used to init hmac-drbg for k generation.\n * * randomBytes: (default: webcrypto os-level CSPRNG) custom method for fetching secure randomness.\n * * bits2int, bits2int_modN: used in sigs, sometimes overridden by curves\n */\nexport type ECDSAOpts = Partial<{\n  lowS: boolean;\n  hmac: (key: Uint8Array, message: Uint8Array) => Uint8Array;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  bits2int: (bytes: Uint8Array) => bigint;\n  bits2int_modN: (bytes: Uint8Array) => bigint;\n}>;\n\n/**\n * Elliptic Curve Diffie-Hellman interface.\n * Provides keygen, secret-to-public conversion, calculating shared secrets.\n */\nexport interface ECDH {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Uint8Array, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (\n    secretKeyA: Uint8Array,\n    publicKeyB: Uint8Array,\n    isCompressed?: boolean\n  ) => Uint8Array;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, isCompressed?: boolean) => boolean;\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n  };\n  lengths: CurveLengths;\n}\n\n/**\n * ECDSA interface.\n * Only supported for prime fields, not Fp2 (extension fields).\n */\nexport interface ECDSA extends ECDH {\n  sign: (message: Uint8Array, secretKey: Uint8Array, opts?: ECDSASignOpts) => Uint8Array;\n  verify: (\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts?: ECDSAVerifyOpts\n  ) => boolean;\n  recoverPublicKey(signature: Uint8Array, message: Uint8Array, opts?: ECDSARecoverOpts): Uint8Array;\n  Signature: ECDSASignatureCons;\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    },\n  },\n  toSig(bytes: Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = abytes(bytes, undefined, 'signature');\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * See {@link WeierstrassOpts}.\n *\n * @example\n```js\nconst opts = {\n  p: 0xfffffffffffffffffffffffffffffffeffffac73n,\n  n: 0x100000000000000000001b8fa16dfab9aca16b6b3n,\n  h: 1n,\n  a: 0n,\n  b: 7n,\n  Gx: 0x3b4c382ce37aa192a4019e763036f4f5dd4d7ebbn,\n  Gy: 0x938cf935318fdced6bc28286531733c3f03c4feen,\n};\nconst secp160k1_Point = weierstrass(opts);\n```\n */\nexport function weierstrass<T>(\n  params: WeierstrassOpts<T>,\n  extraOpts: WeierstrassExtraOpts<T> = {}\n): WeierstrassPointCons<T> {\n  const validated = createCurveFields('weierstrass', params, extraOpts);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as WeierstrassOpts<T>;\n  const { h: cofactor, n: CURVE_ORDER } = CURVE;\n  validateObject(\n    extraOpts,\n    {},\n    {\n      allowInfinityPoint: 'boolean',\n      clearCofactor: 'function',\n      isTorsionFree: 'function',\n      fromBytes: 'function',\n      toBytes: 'function',\n      endo: 'object',\n    }\n  );\n\n  const { endo } = extraOpts;\n  if (endo) {\n    // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n    if (!Fp.is0(CURVE.a) || typeof endo.beta !== 'bigint' || !Array.isArray(endo.basises)) {\n      throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n    }\n  }\n\n  const lengths = getWLengths(Fp, Fn);\n\n  function assertCompressionIsSupported() {\n    if (!Fp.isOdd) throw new Error('compression is not supported: Field does not have .isOdd()');\n  }\n\n  // Implements IEEE P1363 point encoding\n  function pointToBytes(\n    _c: WeierstrassPointCons<T>,\n    point: WeierstrassPoint<T>,\n    isCompressed: boolean\n  ): Uint8Array {\n    const { x, y } = point.toAffine();\n    const bx = Fp.toBytes(x);\n    abool(isCompressed, 'isCompressed');\n    if (isCompressed) {\n      assertCompressionIsSupported();\n      const hasEvenY = !Fp.isOdd!(y);\n      return concatBytes(pprefix(hasEvenY), bx);\n    } else {\n      return concatBytes(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n    }\n  }\n  function pointFromBytes(bytes: Uint8Array) {\n    abytes(bytes, undefined, 'Point');\n    const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n    const length = bytes.length;\n    const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // No actual validation is done here: use .assertValidity()\n    if (length === comp && (head === 0x02 || head === 0x03)) {\n      const x = Fp.fromBytes(tail);\n      if (!Fp.isValid(x)) throw new Error('bad point: is not on curve, wrong x');\n      const y2 = weierstrassEquation(x); // y\u00B2 = x\u00B3 + ax + b\n      let y: T;\n      try {\n        y = Fp.sqrt(y2); // y = y\u00B2 ^ (p+1)/4\n      } catch (sqrtError) {\n        const err = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n        throw new Error('bad point: is not on curve, sqrt error' + err);\n      }\n      assertCompressionIsSupported();\n      const evenY = Fp.isOdd!(y);\n      const evenH = (head & 1) === 1; // ECDSA-specific\n      if (evenH !== evenY) y = Fp.neg(y);\n      return { x, y };\n    } else if (length === uncomp && head === 0x04) {\n      // TODO: more checks\n      const L = Fp.BYTES;\n      const x = Fp.fromBytes(tail.subarray(0, L));\n      const y = Fp.fromBytes(tail.subarray(L, L * 2));\n      if (!isValidXY(x, y)) throw new Error('bad point: is not on curve');\n      return { x, y };\n    } else {\n      throw new Error(\n        `bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`\n      );\n    }\n  }\n\n  const encodePoint = extraOpts.toBytes || pointToBytes;\n  const decodePoint = extraOpts.fromBytes || pointFromBytes;\n  function weierstrassEquation(x: T): T {\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x\u00B2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x\u00B3 + a * x + b\n  }\n\n  // TODO: move top-level\n  /** Checks whether equation holds for given x, y: y\u00B2 == x\u00B3 + ax + b */\n  function isValidXY(x: T, y: T): boolean {\n    const left = Fp.sqr(y); // y\u00B2\n    const right = weierstrassEquation(x); // x\u00B3 + ax + b\n    return Fp.eql(left, right);\n  }\n\n  // Validate whether the passed curve params are valid.\n  // Test 1: equation y\u00B2 = x\u00B3 + ax + b should work for generator point.\n  if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error('bad curve params: generator point');\n\n  // Test 2: discriminant \u0394 part should be non-zero: 4a\u00B3 + 27b\u00B2 != 0.\n  // Guarantees curve is genus-1, smooth (non-singular).\n  const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n  const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n  if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error('bad curve params: a or b');\n\n  /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */\n  function acoord(title: string, n: T, banZero = false) {\n    if (!Fp.isValid(n) || (banZero && Fp.is0(n))) throw new Error(`bad point coordinate ${title}`);\n    return n;\n  }\n\n  function aprjpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('Weierstrass Point expected');\n  }\n\n  function splitEndoScalarN(k: bigint) {\n    if (!endo || !endo.basises) throw new Error('no endo');\n    return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (X, Y, Z) \u220B (x=X/Z, y=Y/Z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { X, Y, Z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(Z, Fp.ONE)) return { x: X, y: Y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n    const x = Fp.mul(X, iz);\n    const y = Fp.mul(Y, iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not field elements');\n    if (!isValidXY(x, y)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  function finishEndo(\n    endoBeta: EndomorphismOpts['beta'],\n    k1p: Point,\n    k2p: Point,\n    k1neg: boolean,\n    k2neg: boolean\n  ) {\n    k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n    k1p = negateCt(k1neg, k1p);\n    k2p = negateCt(k2neg, k2p);\n    return k1p.add(k2p);\n  }\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) \u220B (x=X/Z, y=Y/Z).\n   * Default Point works in 2d / affine coordinates: (x, y).\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements WeierstrassPoint<T> {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: T;\n    readonly Y: T;\n    readonly Z: T;\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    constructor(X: T, Y: T, Z: T) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y, true);\n      this.Z = acoord('z', Z);\n      Object.freeze(this);\n    }\n\n    static CURVE(): WeierstrassOpts<T> {\n      return CURVE;\n    }\n\n    /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n      if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    static fromBytes(bytes: Uint8Array): Point {\n      const P = Point.fromAffine(decodePoint(abytes(bytes, undefined, 'point')));\n      P.assertValidity();\n      return P;\n    }\n\n    static fromHex(hex: string): Point {\n      return Point.fromBytes(hexToBytes(hex));\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     *\n     * @param windowSize\n     * @param isLazy true will defer table computation until the first multiplication\n     * @returns\n     */\n    precompute(windowSize: number = 8, isLazy = true): Point {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_3n); // random number\n      return this;\n    }\n\n    // TODO: return `this`\n    /** A point on curve is valid if it conforms to equation. */\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n      return !Fp.isOdd(y);\n    }\n\n    /** Compare one point to another. */\n    equals(other: Point): boolean {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n    negate(): Point {\n      return new Point(this.X, Fp.neg(this.Y), this.Z);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      aprjpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo } = extraOpts;\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: out of range'); // 0 is invalid\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      const mul = (n: bigint) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n      /** See docs for {@link EndomorphismOpts} */\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n        const { p: k1p, f: k1f } = mul(k1);\n        const { p: k2p, f: k2f } = mul(k2);\n        fake = k1f.add(k2f);\n        point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n      } else {\n        const { p, f } = mul(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return normalizeZ(Point, [point, fake])[0];\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed secret key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo } = extraOpts;\n      const p = this as Point;\n      if (!Fn.isValid(sc)) throw new Error('invalid scalar: out of range'); // 0 is valid\n      if (sc === _0n || p.is0()) return Point.ZERO; // 0\n      if (sc === _1n) return p; // 1\n      if (wnaf.hasCache(this)) return this.multiply(sc); // precomputes\n      // We don't have method for double scalar multiplication (aP + bQ):\n      // Even with using Strauss-Shamir trick, it's 35% slower than na\u00EFve mul+add.\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n        const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n        return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n      } else {\n        return wnaf.unsafe(p, sc);\n      }\n    }\n\n    /**\n     * Converts Projective point to affine (x, y) coordinates.\n     * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n     */\n    toAffine(invertedZ?: T): AffinePoint<T> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    /**\n     * Checks whether Point is free of torsion elements (is in prime subgroup).\n     * Always torsion-free for cofactor=1 curves.\n     */\n    isTorsionFree(): boolean {\n      const { isTorsionFree } = extraOpts;\n      if (cofactor === _1n) return true;\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      return wnaf.unsafe(this, CURVE_ORDER).is0();\n    }\n\n    clearCofactor(): Point {\n      const { clearCofactor } = extraOpts;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    isSmallOrder(): boolean {\n      // can we use this.clearCofactor()?\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    toBytes(isCompressed = true): Uint8Array {\n      abool(isCompressed, 'isCompressed');\n      this.assertValidity();\n      return encodePoint(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      return bytesToHex(this.toBytes(isCompressed));\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n  }\n  const bits = Fn.BITS;\n  const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/** Methods of ECDSA signature instance. */\nexport interface ECDSASignature {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  addRecoveryBit(recovery: number): ECDSASignature & { readonly recovery: number };\n  hasHighS(): boolean;\n  recoverPublicKey(messageHash: Uint8Array): WeierstrassPoint<bigint>;\n  toBytes(format?: string): Uint8Array;\n  toHex(format?: string): string;\n}\n/** Methods of ECDSA signature constructor. */\nexport type ECDSASignatureCons = {\n  new (r: bigint, s: bigint, recovery?: number): ECDSASignature;\n  fromBytes(bytes: Uint8Array, format?: ECDSASignatureFormat): ECDSASignature;\n  fromHex(hex: string, format?: ECDSASignatureFormat): ECDSASignature;\n};\n\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY: boolean): Uint8Array {\n  return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  const { A, B, Z } = opts;\n  if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n  if (!Fp.isOdd) throw new Error('Field does not have .isOdd()');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n\nfunction getWLengths<T>(Fp: IField<T>, Fn: IField<bigint>) {\n  return {\n    secretKey: Fn.BYTES,\n    publicKey: 1 + Fp.BYTES,\n    publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n    publicKeyHasPrefix: true,\n    signature: 2 * Fn.BYTES,\n  };\n}\n\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */\nexport function ecdh(\n  Point: WeierstrassPointCons<bigint>,\n  ecdhOpts: { randomBytes?: (bytesLength?: number) => Uint8Array } = {}\n): ECDH {\n  const { Fn } = Point;\n  const randomBytes_ = ecdhOpts.randomBytes || wcRandomBytes;\n  const lengths = Object.assign(getWLengths(Point.Fp, Fn), { seed: getMinHashLength(Fn.ORDER) });\n\n  function isValidSecretKey(secretKey: Uint8Array) {\n    try {\n      const num = Fn.fromBytes(secretKey);\n      return Fn.isValidNot0(num);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  function isValidPublicKey(publicKey: Uint8Array, isCompressed?: boolean): boolean {\n    const { publicKey: comp, publicKeyUncompressed } = lengths;\n    try {\n      const l = publicKey.length;\n      if (isCompressed === true && l !== comp) return false;\n      if (isCompressed === false && l !== publicKeyUncompressed) return false;\n      return !!Point.fromBytes(publicKey);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Produces cryptographically secure secret key from random of size\n   * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n   */\n  function randomSecretKey(seed = randomBytes_(lengths.seed)): Uint8Array {\n    return mapHashToField(abytes(seed, lengths.seed, 'seed'), Fn.ORDER);\n  }\n\n  /**\n   * Computes public key for a secret key. Checks for validity of the secret key.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(secretKey: Uint8Array, isCompressed = true): Uint8Array {\n    return Point.BASE.multiply(Fn.fromBytes(secretKey)).toBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: Uint8Array): boolean | undefined {\n    const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n    if (!isBytes(item)) return undefined;\n    if (('_lengths' in Fn && Fn._lengths) || secretKey === publicKey) return undefined;\n    const l = abytes(item, undefined, 'key').length;\n    return l === publicKey || l === publicKeyUncompressed;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from secret key A and public key B.\n   * Checks: 1) secret key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(\n    secretKeyA: Uint8Array,\n    publicKeyB: Uint8Array,\n    isCompressed = true\n  ): Uint8Array {\n    if (isProbPub(secretKeyA) === true) throw new Error('first arg must be private key');\n    if (isProbPub(publicKeyB) === false) throw new Error('second arg must be public key');\n    const s = Fn.fromBytes(secretKeyA);\n    const b = Point.fromBytes(publicKeyB); // checks for being on-curve\n    return b.multiply(s).toBytes(isCompressed);\n  }\n\n  const utils = {\n    isValidSecretKey,\n    isValidPublicKey,\n    randomSecretKey,\n  };\n  const keygen = createKeygen(randomSecretKey, getPublicKey);\n\n  return Object.freeze({ getPublicKey, getSharedSecret, keygen, Point, utils, lengths });\n}\n\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n *\n * @param Point created using {@link weierstrass} function\n * @param hash used for 1) message prehash-ing 2) k generation in `sign`, using hmac_drbg(hash)\n * @param ecdsaOpts rarely needed, see {@link ECDSAOpts}\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */\nexport function ecdsa(\n  Point: WeierstrassPointCons<bigint>,\n  hash: CHash,\n  ecdsaOpts: ECDSAOpts = {}\n): ECDSA {\n  ahash(hash);\n  validateObject(\n    ecdsaOpts,\n    {},\n    {\n      hmac: 'function',\n      lowS: 'boolean',\n      randomBytes: 'function',\n      bits2int: 'function',\n      bits2int_modN: 'function',\n    }\n  );\n  ecdsaOpts = Object.assign({}, ecdsaOpts);\n  const randomBytes = ecdsaOpts.randomBytes || wcRandomBytes;\n  const hmac = ecdsaOpts.hmac || ((key, msg) => nobleHmac(hash, key, msg));\n\n  const { Fp, Fn } = Point;\n  const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n  const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n  const defaultSigOpts: Required<ECDSASignOpts> = {\n    prehash: true,\n    lowS: typeof ecdsaOpts.lowS === 'boolean' ? ecdsaOpts.lowS : true,\n    format: 'compact' as ECDSASignatureFormat,\n    extraEntropy: false,\n  };\n  const hasLargeCofactor = CURVE_ORDER * _2n < Fp.ORDER; // Won't CURVE().h > 2n be more effective?\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function validateRS(title: string, num: bigint): bigint {\n    if (!Fn.isValidNot0(num))\n      throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n    return num;\n  }\n  function assertSmallCofactor(): void {\n    // ECDSA recovery is hard for cofactor > 1 curves.\n    // In sign, `r = q.x mod n`, and here we recover q.x from r.\n    // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n    // However, for cofactor>1, r+n may not get q.x:\n    // r+n*i would need to be done instead where i is unknown.\n    // To easily get i, we either need to:\n    // a. increase amount of valid recid values (4, 5...); OR\n    // b. prohibit non-prime-order signatures (recid > 1).\n    if (hasLargeCofactor)\n      throw new Error('\"recovered\" sig type is not supported for cofactor >2 curves');\n  }\n  function validateSigLength(bytes: Uint8Array, format: ECDSASignatureFormat) {\n    validateSigFormat(format);\n    const size = lengths.signature!;\n    const sizer = format === 'compact' ? size : format === 'recovered' ? size + 1 : undefined;\n    return abytes(bytes, sizer);\n  }\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n   */\n  class Signature implements ECDSASignature {\n    readonly r: bigint;\n    readonly s: bigint;\n    readonly recovery?: number;\n\n    constructor(r: bigint, s: bigint, recovery?: number) {\n      this.r = validateRS('r', r); // r in [1..N-1];\n      this.s = validateRS('s', s); // s in [1..N-1];\n      if (recovery != null) {\n        assertSmallCofactor();\n        if (![0, 1, 2, 3].includes(recovery)) throw new Error('invalid recovery id');\n        this.recovery = recovery;\n      }\n      Object.freeze(this);\n    }\n\n    static fromBytes(\n      bytes: Uint8Array,\n      format: ECDSASignatureFormat = defaultSigOpts.format\n    ): Signature {\n      validateSigLength(bytes, format);\n      let recid: number | undefined;\n      if (format === 'der') {\n        const { r, s } = DER.toSig(abytes(bytes));\n        return new Signature(r, s);\n      }\n      if (format === 'recovered') {\n        recid = bytes[0];\n        format = 'compact';\n        bytes = bytes.subarray(1);\n      }\n      const L = lengths.signature! / 2;\n      const r = bytes.subarray(0, L);\n      const s = bytes.subarray(L, L * 2);\n      return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n    }\n\n    static fromHex(hex: string, format?: ECDSASignatureFormat) {\n      return this.fromBytes(hexToBytes(hex), format);\n    }\n\n    private assertRecovery(): number {\n      const { recovery } = this;\n      if (recovery == null) throw new Error('invalid recovery id: must be present');\n      return recovery;\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(messageHash: Uint8Array): WeierstrassPoint<bigint> {\n      const { r, s } = this;\n      const recovery = this.assertRecovery();\n      const radj = recovery === 2 || recovery === 3 ? r + CURVE_ORDER : r;\n      if (!Fp.isValid(radj)) throw new Error('invalid recovery id: sig.r+curve.n != R.x');\n      const x = Fp.toBytes(radj);\n      const R = Point.fromBytes(concatBytes(pprefix((recovery & 1) === 0), x));\n      const ir = Fn.inv(radj); // r^-1\n      const h = bits2int_modN(abytes(messageHash, undefined, 'msgHash')); // Truncate hash\n      const u1 = Fn.create(-h * ir); // -hr^-1\n      const u2 = Fn.create(s * ir); // sr^-1\n      // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n      const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n      if (Q.is0()) throw new Error('invalid recovery: point at infinify');\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    toBytes(format: ECDSASignatureFormat = defaultSigOpts.format) {\n      validateSigFormat(format);\n      if (format === 'der') return hexToBytes(DER.hexFromSig(this));\n      const { r, s } = this;\n      const rb = Fn.toBytes(r);\n      const sb = Fn.toBytes(s);\n      if (format === 'recovered') {\n        assertSmallCofactor();\n        return concatBytes(Uint8Array.of(this.assertRecovery()), rb, sb);\n      }\n      return concatBytes(rb, sb);\n    }\n\n    toHex(format?: ECDSASignatureFormat) {\n      return bytesToHex(this.toBytes(format));\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    ecdsaOpts.bits2int ||\n    function bits2int_def(bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\", for protection against DoS\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    ecdsaOpts.bits2int_modN ||\n    function bits2int_modN_def(bytes: Uint8Array): bigint {\n      return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // Pads output with zero as per spec\n  const ORDER_MASK = bitMask(fnBits);\n  /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */\n  function int2octets(num: bigint): Uint8Array {\n    // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n    aInRange('num < 2^' + fnBits, num, _0n, ORDER_MASK);\n    return Fn.toBytes(num);\n  }\n\n  function validateMsgAndHash(message: Uint8Array, prehash: boolean) {\n    abytes(message, undefined, 'message');\n    return prehash ? abytes(hash(message), undefined, 'prehashed message') : message;\n  }\n\n  /**\n   * Steps A, D of RFC6979 3.2.\n   * Creates RFC6979 seed; converts msg/privKey to numbers.\n   * Used only in sign, not in verify.\n   *\n   * Warning: we cannot assume here that message has same amount of bytes as curve order,\n   * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n   */\n  function prepSig(message: Uint8Array, secretKey: Uint8Array, opts: ECDSASignOpts) {\n    const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(message);\n    const d = Fn.fromBytes(secretKey); // validate secret key, convert to bigint\n    if (!Fn.isValidNot0(d)) throw new Error('invalid private key');\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (extraEntropy != null && extraEntropy !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      // gen random bytes OR pass as-is\n      const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n      seedArgs.push(abytes(e, undefined, 'extraEntropy')); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    // To transform k => Signature:\n    // q = k\u22C5G\n    // r = q.x mod n\n    // s = k^-1(m + rd) mod n\n    // Can use scalar blinding b^-1(bm + bdr) where b \u2208 [1,q\u22121] according to\n    // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n    // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n    function k2sig(kBytes: Uint8Array): Signature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      // Important: all mod() calls here must be done over N\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n      const ik = Fn.inv(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = k\u22C5G\n      const r = Fn.create(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      const s = Fn.create(ik * Fn.create(m + r * d)); // s = k^-1(m + rd) mod n\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3 when q.x>n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = Fn.neg(s); // if lowS was passed, ensure s is always in the bottom half of N\n        recovery ^= 1;\n      }\n      return new Signature(r, normS, hasLargeCofactor ? undefined : recovery);\n    }\n    return { seed, k2sig };\n  }\n\n  /**\n   * Signs message hash with a secret key.\n   *\n   * ```\n   * sign(m, d) where\n   *   k = rfc6979_hmac_drbg(m, d)\n   *   (x, y) = G \u00D7 k\n   *   r = x mod n\n   *   s = (m + dr) / k mod n\n   * ```\n   */\n  function sign(message: Uint8Array, secretKey: Uint8Array, opts: ECDSASignOpts = {}): Uint8Array {\n    const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n    const drbg = createHmacDrbg<Signature>(hash.outputLen, Fn.BYTES, hmac);\n    const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    return sig.toBytes(opts.format);\n  }\n\n  /**\n   * Verifies a signature against message and public key.\n   * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n   * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   u1 = hs^-1 mod n\n   *   u2 = rs^-1 mod n\n   *   R = u1\u22C5G + u2\u22C5P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Uint8Array,\n    message: Uint8Array,\n    publicKey: Uint8Array,\n    opts: ECDSAVerifyOpts = {}\n  ): boolean {\n    const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n    publicKey = abytes(publicKey, undefined, 'publicKey');\n    message = validateMsgAndHash(message, prehash);\n    if (!isBytes(signature as any)) {\n      const end = signature instanceof Signature ? ', use sig.toBytes()' : '';\n      throw new Error('verify expects Uint8Array signature' + end);\n    }\n    validateSigLength(signature, format); // execute this twice because we want loud error\n    try {\n      const sig = Signature.fromBytes(signature, format);\n      const P = Point.fromBytes(publicKey);\n      if (lowS && sig.hasHighS()) return false;\n      const { r, s } = sig;\n      const h = bits2int_modN(message); // mod n, not mod p\n      const is = Fn.inv(s); // s^-1 mod n\n      const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n      const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n      const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1\u22C5G + u2\u22C5P\n      if (R.is0()) return false;\n      const v = Fn.create(R.x); // v = r.x mod n\n      return v === r;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function recoverPublicKey(\n    signature: Uint8Array,\n    message: Uint8Array,\n    opts: ECDSARecoverOpts = {}\n  ): Uint8Array {\n    const { prehash } = validateSigOpts(opts, defaultSigOpts);\n    message = validateMsgAndHash(message, prehash);\n    return Signature.fromBytes(signature, 'recovered').recoverPublicKey(message).toBytes();\n  }\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    getSharedSecret,\n    utils,\n    lengths,\n    Point,\n    sign,\n    verify,\n    recoverPublicKey,\n    Signature,\n    hash,\n  }) satisfies Signer;\n}\n", "/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism \u03C8,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha2.js';\nimport { randomBytes } from '@noble/hashes/utils.js';\nimport { createKeygen, type CurveLengths } from './abstract/curve.ts';\nimport { createHasher, type H2CHasher, isogenyMap } from './abstract/hash-to-curve.ts';\nimport { Field, mapHashToField, pow2 } from './abstract/modular.ts';\nimport {\n  type ECDSA,\n  ecdsa,\n  type EndomorphismOpts,\n  mapToCurveSimpleSWU,\n  type WeierstrassPoint as PointType,\n  weierstrass,\n  type WeierstrassOpts,\n  type WeierstrassPointCons,\n} from './abstract/weierstrass.ts';\nimport { abytes, asciiToBytes, bytesToNumberBE, concatBytes } from './utils.ts';\n\n// Seems like generator was produced from some seed:\n// `Pointk1.BASE.multiply(Pointk1.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE: WeierstrassOpts<bigint> = {\n  p: BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n  n: BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141'),\n  h: BigInt(1),\n  a: BigInt(0),\n  b: BigInt(7),\n  Gx: BigInt('0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n  Gy: BigInt('0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8'),\n};\n\nconst secp256k1_ENDO: EndomorphismOpts = {\n  beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n  basises: [\n    [BigInt('0x3086d221a7d46bcde86c90e49284eb15'), -BigInt('0xe4437ed6010e88286f547fa90abfe4c3')],\n    [BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8'), BigInt('0x3086d221a7d46bcde86c90e49284eb15')],\n  ],\n};\n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _2n = /* @__PURE__ */ BigInt(2);\n\n/**\n * \u221An = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1_CURVE.p;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\nconst Pointk1 = /* @__PURE__ */ weierstrass(secp256k1_CURVE, {\n  Fp: Fpk1,\n  endo: secp256k1_ENDO,\n});\n\n/**\n * secp256k1 curve: ECDSA and ECDH methods.\n *\n * Uses sha256 to hash messages. To use a different hash,\n * pass `{ prehash: false }` to sign / verify.\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * // const publicKey = secp256k1.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello noble');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey);\n * // const sigKeccak = secp256k1.sign(keccak256(msg), secretKey, { prehash: false });\n * ```\n */\nexport const secp256k1: ECDSA = /* @__PURE__ */ ecdsa(Pointk1, sha256);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(asciiToBytes(tag));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toBytes(true).slice(1);\nconst hasEven = (y: bigint) => y % _2n === _0n;\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: Uint8Array) {\n  const { Fn, BASE } = Pointk1;\n  const d_ = Fn.fromBytes(priv);\n  const p = BASE.multiply(d_); // P = d'\u22C5G; 0 < d' < n check is done inside\n  const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n  return { scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  const Fp = Fpk1;\n  if (!Fp.isValidNot0(x)) throw new Error('invalid x: Fail if x \u2265 p');\n  const xx = Fp.create(x * x);\n  const c = Fp.create(xx * x + BigInt(7)); // Let c = x\u00B3 + 7 mod p.\n  let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n  // Return the unique point P such that x(P) = x and\n  // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  if (!hasEven(y)) y = Fp.neg(y);\n  const p = Pointk1.fromAffine({ x, y });\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return Pointk1.Fn.create(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(secretKey: Uint8Array): Uint8Array {\n  return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'\u2265n. Ret bytes(d'\u22C5G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Uint8Array,\n  secretKey: Uint8Array,\n  auxRand: Uint8Array = randomBytes(32)\n): Uint8Array {\n  const { Fn } = Pointk1;\n  const m = abytes(message, undefined, 'message');\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n  const a = abytes(auxRand, 32, 'auxRand'); // Auxiliary random data a: a 32-byte array\n  const t = Fn.toBytes(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'\u22C5G\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Uint8Array, message: Uint8Array, publicKey: Uint8Array): boolean {\n  const { Fp, Fn, BASE } = Pointk1;\n  const sig = abytes(signature, 64, 'signature');\n  const m = abytes(message, undefined, 'message');\n  const pub = abytes(publicKey, 32, 'publicKey');\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r \u2265 p.\n    if (!Fp.isValidNot0(r)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s \u2265 n.\n    if (!Fn.isValidNot0(s)) return false;\n\n    const e = challenge(Fn.toBytes(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    // R = s\u22C5G - e\u22C5P, where -eP == (n-e)P\n    const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n    const { x, y } = R.toAffine();\n    // Fail if is_infinite(R) / not has_even_y(R) / x(R) \u2260 r.\n    if (R.is0() || !hasEven(y) || x !== r) return false;\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  Point: WeierstrassPointCons<bigint>;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    lift_x: typeof lift_x;\n    taggedHash: typeof taggedHash;\n  };\n  lengths: CurveLengths;\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1.js';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => {\n  const size = 32;\n  const seedLength = 48;\n  const randomSecretKey = (seed = randomBytes(seedLength)): Uint8Array => {\n    return mapHashToField(seed, secp256k1_CURVE.n);\n  };\n  return {\n    keygen: createKeygen(randomSecretKey, schnorrGetPublicKey),\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    Point: Pointk1,\n    utils: {\n      randomSecretKey,\n      taggedHash,\n      lift_x,\n      pointToBytes,\n    },\n    lengths: {\n      secretKey: size,\n      publicKey: size,\n      publicKeyHasPrefix: false,\n      signature: size * 2,\n      seed: seedLength,\n    },\n  };\n})();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\n\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */\nexport const secp256k1_hasher: H2CHasher<WeierstrassPointCons<bigint>> = /* @__PURE__ */ (() =>\n  createHasher(\n    Pointk1,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\n", "import { secp256k1 as secp } from '@noble/curves/secp256k1.js'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { SigningError, VerificationError } from '../../errors.js'\nimport { isPromise } from '../../util.js'\nimport type { AbortOptions } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nconst PUBLIC_KEY_BYTE_LENGTH = 33\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PUBLIC_KEY_BYTE_LENGTH as publicKeyLength }\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\n/**\n * Hash and sign message with private key\n */\nexport function hashAndSign (key: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p\n      .then(({ digest }) => {\n        options?.signal?.throwIfAborted()\n        return secp.sign(digest, key, {\n          prehash: false,\n          format: 'der'\n        })\n      })\n      .catch(err => {\n        if (err.name === 'AbortError') {\n          throw err\n        }\n\n        throw new SigningError(String(err))\n      })\n  }\n\n  try {\n    return secp.sign(p.digest, key, {\n      prehash: false,\n      format: 'der'\n    })\n  } catch (err) {\n    throw new SigningError(String(err))\n  }\n}\n\n/**\n * Hash message and verify signature with public key\n */\nexport function hashAndVerify (key: Uint8Array, sig: Uint8Array, msg: Uint8Array | Uint8ArrayList, options?: AbortOptions): boolean | Promise<boolean> {\n  const p = sha256.digest(msg instanceof Uint8Array ? msg : msg.subarray())\n\n  if (isPromise(p)) {\n    return p\n      .then(({ digest }) => {\n        options?.signal?.throwIfAborted()\n        return secp.verify(sig, digest, key, {\n          prehash: false,\n          format: 'der'\n        })\n      })\n      .catch(err => {\n        if (err.name === 'AbortError') {\n          throw err\n        }\n\n        throw new VerificationError(String(err))\n      })\n  }\n\n  try {\n    options?.signal?.throwIfAborted()\n    return secp.verify(sig, p.digest, key, {\n      prehash: false,\n      format: 'der'\n    })\n  } catch (err) {\n    throw new VerificationError(String(err))\n  }\n}\n", "import { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { publicKeyToProtobuf } from '../index.js'\nimport { validateSecp256k1PublicKey, compressSecp256k1PublicKey, computeSecp256k1PublicKey, validateSecp256k1PrivateKey } from './utils.js'\nimport { hashAndVerify, hashAndSign } from './index.js'\nimport type { Secp256k1PublicKey as Secp256k1PublicKeyInterface, Secp256k1PrivateKey as Secp256k1PrivateKeyInterface, AbortOptions } from '@libp2p/interface'\nimport type { Digest } from 'multiformats/hashes/digest'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport class Secp256k1PublicKey implements Secp256k1PublicKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly _key: Uint8Array\n\n  constructor (key: Uint8Array) {\n    this._key = validateSecp256k1PublicKey(key)\n    this.raw = compressSecp256k1PublicKey(this._key)\n  }\n\n  toMultihash (): Digest<0x0, number> {\n    return identity.digest(publicKeyToProtobuf(this))\n  }\n\n  toCID (): CID<unknown, 114, 0x0, 1> {\n    return CID.createV1(114, this.toMultihash())\n  }\n\n  toString (): string {\n    return base58btc.encode(this.toMultihash().bytes).substring(1)\n  }\n\n  equals (key: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  verify (data: Uint8Array | Uint8ArrayList, sig: Uint8Array, options?: AbortOptions): boolean {\n    return hashAndVerify(this._key, sig, data, options)\n  }\n}\n\nexport class Secp256k1PrivateKey implements Secp256k1PrivateKeyInterface {\n  public readonly type = 'secp256k1'\n  public readonly raw: Uint8Array\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (key: Uint8Array, publicKey?: Uint8Array) {\n    this.raw = validateSecp256k1PrivateKey(key)\n    this.publicKey = new Secp256k1PublicKey(publicKey ?? computeSecp256k1PublicKey(key))\n  }\n\n  equals (key?: any): boolean {\n    if (key == null || !(key.raw instanceof Uint8Array)) {\n      return false\n    }\n\n    return uint8ArrayEquals(this.raw, key.raw)\n  }\n\n  sign (message: Uint8Array | Uint8ArrayList, options?: AbortOptions): Uint8Array | Promise<Uint8Array> {\n    return hashAndSign(this.raw, message, options)\n  }\n}\n", "import { InvalidPrivateKeyError, InvalidPublicKeyError } from '@libp2p/interface'\nimport { secp256k1 as secp } from '@noble/curves/secp256k1.js'\nimport { Secp256k1PublicKey as Secp256k1PublicKeyClass, Secp256k1PrivateKey as Secp256k1PrivateKeyClass } from './secp256k1.js'\nimport type { Secp256k1PublicKey, Secp256k1PrivateKey } from '@libp2p/interface'\n\nconst PRIVATE_KEY_BYTE_LENGTH = 32\n\nexport { PRIVATE_KEY_BYTE_LENGTH as privateKeyLength }\n\nexport function unmarshalSecp256k1PrivateKey (bytes: Uint8Array): Secp256k1PrivateKey {\n  return new Secp256k1PrivateKeyClass(bytes)\n}\n\nexport function unmarshalSecp256k1PublicKey (bytes: Uint8Array): Secp256k1PublicKey {\n  return new Secp256k1PublicKeyClass(bytes)\n}\n\nexport async function generateSecp256k1KeyPair (): Promise<Secp256k1PrivateKey> {\n  const privateKeyBytes = generateSecp256k1PrivateKey()\n  return new Secp256k1PrivateKeyClass(privateKeyBytes)\n}\n\nexport function compressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  return secp.Point.fromBytes(key).toBytes()\n}\n\nexport function decompressSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  return secp.Point.fromBytes(key).toBytes(false)\n}\n\nexport function validateSecp256k1PrivateKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.getPublicKey(key, true)\n\n    return key\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function validateSecp256k1PublicKey (key: Uint8Array): Uint8Array {\n  try {\n    secp.Point.fromBytes(key)\n\n    return key\n  } catch (err) {\n    throw new InvalidPublicKeyError(String(err))\n  }\n}\n\nexport function computeSecp256k1PublicKey (privateKey: Uint8Array): Uint8Array {\n  try {\n    return secp.getPublicKey(privateKey, true)\n  } catch (err) {\n    throw new InvalidPrivateKeyError(String(err))\n  }\n}\n\nexport function generateSecp256k1PrivateKey (): Uint8Array {\n  return secp.utils.randomSecretKey()\n}\n", "/**\n * @packageDocumentation\n *\n * ## Supported Key Types\n *\n * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.\n *\n * For encryption / decryption support, RSA keys should be used.\n */\n\nimport { InvalidParametersError, UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { ECDSAPrivateKey as ECDSAPrivateKeyClass } from './ecdsa/ecdsa.js'\nimport { ECDSA_P_256_OID, ECDSA_P_384_OID, ECDSA_P_521_OID } from './ecdsa/index.js'\nimport { generateECDSAKeyPair, pkiMessageToECDSAPrivateKey, pkiMessageToECDSAPublicKey, unmarshalECDSAPrivateKey, unmarshalECDSAPublicKey } from './ecdsa/utils.js'\nimport { privateKeyLength as ed25519PrivateKeyLength, publicKeyLength as ed25519PublicKeyLength } from './ed25519/index.js'\nimport { generateEd25519KeyPair, generateEd25519KeyPairFromSeed, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey } from './ed25519/utils.js'\nimport * as pb from './keys.js'\nimport { decodeDer } from './rsa/der.js'\nimport { RSAES_PKCS1_V1_5_OID } from './rsa/index.js'\nimport { pkcs1ToRSAPrivateKey, pkixToRSAPublicKey, generateRSAKeyPair, pkcs1MessageToRSAPrivateKey, pkixMessageToRSAPublicKey, jwkToRSAPrivateKey } from './rsa/utils.js'\nimport { privateKeyLength as secp256k1PrivateKeyLength, publicKeyLength as secp256k1PublicKeyLength } from './secp256k1/index.js'\nimport { generateSecp256k1KeyPair, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey } from './secp256k1/utils.js'\nimport type { Curve } from './ecdsa/index.js'\nimport type { PrivateKey, PublicKey, KeyType, RSAPrivateKey, Secp256k1PrivateKey, Ed25519PrivateKey, Secp256k1PublicKey, Ed25519PublicKey, ECDSAPrivateKey, ECDSAPublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats'\nimport type { Digest } from 'multiformats/hashes/digest'\n\nexport { generateEphemeralKeyPair } from './ecdh/index.js'\nexport type { Curve } from './ecdh/index.js'\nexport type { ECDHKey, EnhancedKey, EnhancedKeyPair, ECDHKeyPair } from './interface.js'\nexport { keyStretcher } from './key-stretcher.js'\n\n/**\n * Generates a keypair of the given type and bitsize\n */\nexport async function generateKeyPair (type: 'Ed25519'): Promise<Ed25519PrivateKey>\nexport async function generateKeyPair (type: 'secp256k1'): Promise<Secp256k1PrivateKey>\nexport async function generateKeyPair (type: 'ECDSA', curve?: Curve): Promise<ECDSAPrivateKey>\nexport async function generateKeyPair (type: 'RSA', bits?: number): Promise<RSAPrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number): Promise<PrivateKey>\nexport async function generateKeyPair (type: KeyType, bits?: number | string): Promise<unknown> {\n  if (type === 'Ed25519') {\n    return generateEd25519KeyPair()\n  }\n\n  if (type === 'secp256k1') {\n    return generateSecp256k1KeyPair()\n  }\n\n  if (type === 'RSA') {\n    return generateRSAKeyPair(toBits(bits))\n  }\n\n  if (type === 'ECDSA') {\n    return generateECDSAKeyPair(toCurve(bits))\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\n/**\n * Generates a keypair of the given type from the passed seed.  Currently only\n * supports Ed25519 keys.\n *\n * Seed is a 32 byte uint8array\n */\nexport async function generateKeyPairFromSeed (type: 'Ed25519', seed: Uint8Array): Promise<Ed25519PrivateKey>\nexport async function generateKeyPairFromSeed <T extends KeyType> (type: T, seed: Uint8Array, bits?: number): Promise<never>\nexport async function generateKeyPairFromSeed (type: string, seed: Uint8Array): Promise<unknown> {\n  if (type !== 'Ed25519') {\n    throw new UnsupportedKeyTypeError('Seed key derivation only supported for Ed25519 keys')\n  }\n\n  return generateEd25519KeyPairFromSeed(seed)\n}\n\n/**\n * Converts a protobuf serialized public key into its representative object.\n *\n * For RSA public keys optionally pass the multihash digest of the public key if\n * it is known. If the digest is omitted it will be calculated which can be\n * expensive.\n *\n * For other key types the digest option is ignored.\n */\nexport function publicKeyFromProtobuf (buf: Uint8Array, digest?: Digest<18, number>): PublicKey {\n  const { Type, Data } = pb.PublicKey.decode(buf)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.RSA:\n      return pkixToRSAPublicKey(data, digest)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a public key from the raw key bytes\n */\nexport function publicKeyFromRaw (buf: Uint8Array): PublicKey {\n  if (buf.byteLength === ed25519PublicKeyLength) {\n    return unmarshalEd25519PublicKey(buf)\n  } else if (buf.byteLength === secp256k1PublicKeyLength) {\n    return unmarshalSecp256k1PublicKey(buf)\n  }\n\n  const message = decodeDer(buf)\n  const ecdsaOid = message[1]?.[0]\n\n  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {\n    return pkiMessageToECDSAPublicKey(message)\n  }\n\n  if (message[0]?.[0] === RSAES_PKCS1_V1_5_OID) {\n    return pkixMessageToRSAPublicKey(message, buf)\n  }\n\n  throw new InvalidParametersError('Could not extract public key from raw bytes')\n}\n\n/**\n * Creates a public key from an identity multihash which contains a protobuf\n * encoded Ed25519 or secp256k1 public key.\n *\n * RSA keys are not supported as in practice we they are not stored in identity\n * multihash since the hash would be very large.\n */\nexport function publicKeyFromMultihash (digest: MultihashDigest<0x0>): Ed25519PublicKey | Secp256k1PublicKey | ECDSAPublicKey {\n  const { Type, Data } = pb.PublicKey.decode(digest.digest)\n  const data = Data ?? new Uint8Array()\n\n  switch (Type) {\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PublicKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PublicKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPublicKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Converts a public key object into a protobuf serialized public key\n */\nexport function publicKeyToProtobuf (key: PublicKey): Uint8Array {\n  return pb.PublicKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\n/**\n * Converts a protobuf serialized private key into its representative object\n */\nexport function privateKeyFromProtobuf (buf: Uint8Array): Ed25519PrivateKey | Secp256k1PrivateKey | RSAPrivateKey | ECDSAPrivateKey {\n  const decoded = pb.PrivateKey.decode(buf)\n  const data = decoded.Data ?? new Uint8Array()\n\n  switch (decoded.Type) {\n    case pb.KeyType.RSA:\n      return pkcs1ToRSAPrivateKey(data)\n    case pb.KeyType.Ed25519:\n      return unmarshalEd25519PrivateKey(data)\n    case pb.KeyType.secp256k1:\n      return unmarshalSecp256k1PrivateKey(data)\n    case pb.KeyType.ECDSA:\n      return unmarshalECDSAPrivateKey(data)\n    default:\n      throw new UnsupportedKeyTypeError()\n  }\n}\n\n/**\n * Creates a private key from the raw key bytes. For Ed25519 keys this requires\n * the public key to be appended to the private key otherwise we can't\n * differentiate between Ed25519 and secp256k1 keys as they are the same length.\n */\nexport function privateKeyFromRaw (buf: Uint8Array): PrivateKey {\n  if (buf.byteLength === ed25519PrivateKeyLength) {\n    return unmarshalEd25519PrivateKey(buf)\n  } else if (buf.byteLength === secp256k1PrivateKeyLength) {\n    return unmarshalSecp256k1PrivateKey(buf)\n  }\n\n  const message = decodeDer(buf)\n  const ecdsaOid = message[2]?.[0]\n\n  if (ecdsaOid === ECDSA_P_256_OID || ecdsaOid === ECDSA_P_384_OID || ecdsaOid === ECDSA_P_521_OID) {\n    return pkiMessageToECDSAPrivateKey(message)\n  }\n\n  if (message.length > 8) {\n    return pkcs1MessageToRSAPrivateKey(message)\n  }\n\n  throw new InvalidParametersError('Could not extract private key from raw bytes')\n}\n\n/**\n * Converts a private key object into a protobuf serialized private key\n */\nexport function privateKeyToProtobuf (key: PrivateKey): Uint8Array {\n  return pb.PrivateKey.encode({\n    Type: pb.KeyType[key.type],\n    Data: key.raw\n  })\n}\n\nfunction toBits (bits: any): number {\n  if (bits == null) {\n    return 2048\n  }\n\n  return parseInt(bits, 10)\n}\n\nfunction toCurve (curve: any): Curve {\n  if (curve === 'P-256' || curve == null) {\n    return 'P-256'\n  }\n\n  if (curve === 'P-384') {\n    return 'P-384'\n  }\n\n  if (curve === 'P-521') {\n    return 'P-521'\n  }\n\n  throw new InvalidParametersError('Unsupported curve, should be P-256, P-384 or P-521')\n}\n\n/**\n * Convert a libp2p RSA or ECDSA private key to a WebCrypto CryptoKeyPair\n */\nexport async function privateKeyToCryptoKeyPair (privateKey: PrivateKey): Promise<CryptoKeyPair> {\n  if (privateKey.type === 'RSA') {\n    return {\n      privateKey: await crypto.subtle.importKey('jwk', privateKey.jwk, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n      }, true, ['sign']),\n      publicKey: await crypto.subtle.importKey('jwk', privateKey.publicKey.jwk, {\n        name: 'RSASSA-PKCS1-v1_5',\n        hash: { name: 'SHA-256' }\n      }, true, ['verify'])\n    }\n  }\n\n  if (privateKey.type === 'ECDSA') {\n    return {\n      privateKey: await crypto.subtle.importKey('jwk', privateKey.jwk, {\n        name: 'ECDSA',\n        namedCurve: privateKey.jwk.crv ?? 'P-256'\n      }, true, ['sign']),\n      publicKey: await crypto.subtle.importKey('jwk', privateKey.publicKey.jwk, {\n        name: 'ECDSA',\n        namedCurve: privateKey.publicKey.jwk.crv ?? 'P-256'\n      }, true, ['verify'])\n    }\n  }\n\n  throw new InvalidParametersError('Only RSA and ECDSA keys are supported')\n}\n\n/**\n * Convert a RSA or ECDSA WebCrypto CryptoKeyPair to a libp2p private key\n */\nexport async function privateKeyFromCryptoKeyPair (keyPair: CryptoKeyPair): Promise<PrivateKey> {\n  if (keyPair.privateKey.algorithm.name === 'RSASSA-PKCS1-v1_5') {\n    const jwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n\n    return jwkToRSAPrivateKey(jwk)\n  }\n\n  if (keyPair.privateKey.algorithm.name === 'ECDSA') {\n    const jwk = await crypto.subtle.exportKey('jwk', keyPair.privateKey)\n\n    return new ECDSAPrivateKeyClass(jwk)\n  }\n\n  throw new InvalidParametersError('Only RSA and ECDSA keys are supported')\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('k51qzi5uqu5dkwkqm42v9j9kqcam2jiuvloi16g72i4i4amoo2m8u3ol3mqu6s')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { peerIdSymbol } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport { identity } from 'multiformats/hashes/identity'\nimport { equals as uint8ArrayEquals } from 'uint8arrays/equals'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Ed25519PeerId as Ed25519PeerIdInterface, PeerIdType, RSAPeerId as RSAPeerIdInterface, URLPeerId as URLPeerIdInterface, Secp256k1PeerId as Secp256k1PeerIdInterface, PeerId, PublicKey, Ed25519PublicKey, Secp256k1PublicKey, RSAPublicKey } from '@libp2p/interface'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\nconst inspect = Symbol.for('nodejs.util.inspect.custom')\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\n\ninterface PeerIdInit <DigestCode extends number> {\n  type: PeerIdType\n  multihash: MultihashDigest<DigestCode>\n}\n\ninterface RSAPeerIdInit {\n  multihash: MultihashDigest<0x12>\n  publicKey?: RSAPublicKey\n}\n\ninterface Ed25519PeerIdInit {\n  multihash: MultihashDigest<0x0>\n  publicKey: Ed25519PublicKey\n}\n\ninterface Secp256k1PeerIdInit {\n  multihash: MultihashDigest<0x0>\n  publicKey: Secp256k1PublicKey\n}\n\nclass PeerIdImpl <DigestCode extends number> {\n  public type: PeerIdType\n  private readonly multihash: MultihashDigest<DigestCode>\n  public readonly publicKey?: PublicKey\n  private string?: string\n\n  constructor (init: PeerIdInit<DigestCode>) {\n    this.type = init.type\n    this.multihash = init.multihash\n\n    // mark string cache as non-enumerable\n    Object.defineProperty(this, 'string', {\n      enumerable: false,\n      writable: true\n    })\n  }\n\n  get [Symbol.toStringTag] (): string {\n    return `PeerId(${this.toString()})`\n  }\n\n  readonly [peerIdSymbol] = true\n\n  toString (): string {\n    if (this.string == null) {\n      this.string = base58btc.encode(this.multihash.bytes).slice(1)\n    }\n\n    return this.string\n  }\n\n  toMultihash (): MultihashDigest<DigestCode> {\n    return this.multihash\n  }\n\n  // return self-describing String representation\n  // in default format from RFC 0001: https://github.com/libp2p/specs/pull/209\n  toCID (): CID<Uint8Array, 0x72, DigestCode, 1> {\n    return CID.createV1(LIBP2P_KEY_CODE, this.multihash)\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  /**\n   * Checks the equality of `this` peer against a given PeerId\n   */\n  equals (id?: PeerId | Uint8Array | string): boolean {\n    if (id == null) {\n      return false\n    }\n\n    if (id instanceof Uint8Array) {\n      return uint8ArrayEquals(this.multihash.bytes, id)\n    } else if (typeof id === 'string') {\n      return this.toString() === id\n    } else if (id?.toMultihash()?.bytes != null) {\n      return uint8ArrayEquals(this.multihash.bytes, id.toMultihash().bytes)\n    } else {\n      throw new Error('not valid Id')\n    }\n  }\n\n  /**\n   * Returns PeerId as a human-readable string\n   * https://nodejs.org/api/util.html#utilinspectcustom\n   *\n   * @example\n   * ```TypeScript\n   * import { peerIdFromString } from '@libp2p/peer-id'\n   *\n   * console.info(peerIdFromString('QmFoo'))\n   * // 'PeerId(QmFoo)'\n   * ```\n   */\n  [inspect] (): string {\n    return `PeerId(${this.toString()})`\n  }\n}\n\nexport class RSAPeerId extends PeerIdImpl<0x12> implements RSAPeerIdInterface {\n  public readonly type = 'RSA'\n  public readonly publicKey?: RSAPublicKey\n\n  constructor (init: RSAPeerIdInit) {\n    super({ ...init, type: 'RSA' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nexport class Ed25519PeerId extends PeerIdImpl<0x0> implements Ed25519PeerIdInterface {\n  public readonly type = 'Ed25519'\n  public readonly publicKey: Ed25519PublicKey\n\n  constructor (init: Ed25519PeerIdInit) {\n    super({ ...init, type: 'Ed25519' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\nexport class Secp256k1PeerId extends PeerIdImpl<0x0> implements Secp256k1PeerIdInterface {\n  public readonly type = 'secp256k1'\n  public readonly publicKey: Secp256k1PublicKey\n\n  constructor (init: Secp256k1PeerIdInit) {\n    super({ ...init, type: 'secp256k1' })\n\n    this.publicKey = init.publicKey\n  }\n}\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920\n\nexport class URLPeerId implements URLPeerIdInterface {\n  readonly type = 'url'\n  readonly multihash: MultihashDigest<0x0>\n  readonly publicKey: undefined\n  readonly url: string\n\n  constructor (url: URL) {\n    this.url = url.toString()\n    this.multihash = identity.digest(uint8ArrayFromString(this.url))\n  }\n\n  [inspect] (): string {\n    return `PeerId(${this.url})`\n  }\n\n  readonly [peerIdSymbol] = true\n\n  toString (): string {\n    return this.toCID().toString()\n  }\n\n  toMultihash (): MultihashDigest<0x0> {\n    return this.multihash\n  }\n\n  toCID (): CID<Uint8Array, 0x0920, 0x0, 1> {\n    return CID.createV1(TRANSPORT_IPFS_GATEWAY_HTTP_CODE, this.toMultihash())\n  }\n\n  toJSON (): string {\n    return this.toString()\n  }\n\n  equals (other?: PeerId | Uint8Array | string): boolean {\n    if (other == null) {\n      return false\n    }\n\n    if (other instanceof Uint8Array) {\n      other = uint8ArrayToString(other)\n    }\n\n    return other.toString() === this.toString()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An implementation of a peer id\n *\n * @example\n *\n * ```TypeScript\n * import { peerIdFromString } from '@libp2p/peer-id'\n * const peer = peerIdFromString('12D3KooWKnDdG3iXw9eTFijk3EWSunZcFi54Zka4wmtqtt6rPxc8')\n *\n * console.log(peer.toCID()) // CID(bafzaa...)\n * console.log(peer.toString()) // \"12D3K...\"\n * ```\n */\n\nimport { publicKeyFromMultihash } from '@libp2p/crypto/keys'\nimport { InvalidCIDError, InvalidMultihashError, InvalidParametersError, UnsupportedKeyTypeError } from '@libp2p/interface'\nimport { base58btc } from 'multiformats/bases/base58'\nimport { CID } from 'multiformats/cid'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { identity } from 'multiformats/hashes/identity'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { RSAPeerId as RSAPeerIdClass, Ed25519PeerId as Ed25519PeerIdClass, Secp256k1PeerId as Secp256k1PeerIdClass, URLPeerId as URLPeerIdClass } from './peer-id.js'\nimport type { Ed25519PeerId, RSAPeerId, URLPeerId, Secp256k1PeerId, PeerId, PublicKey, Ed25519PublicKey, Secp256k1PublicKey, RSAPublicKey, Ed25519PrivateKey, Secp256k1PrivateKey, RSAPrivateKey, PrivateKey } from '@libp2p/interface'\nimport type { MultibaseDecoder } from 'multiformats/cid'\nimport type { MultihashDigest } from 'multiformats/hashes/interface'\n\n// these values are from https://github.com/multiformats/multicodec/blob/master/table.csv\nconst LIBP2P_KEY_CODE = 0x72\nconst TRANSPORT_IPFS_GATEWAY_HTTP_CODE = 0x0920\n\nexport function peerIdFromString (str: string, decoder?: MultibaseDecoder<any>): Ed25519PeerId | Secp256k1PeerId | RSAPeerId | URLPeerId {\n  let multihash: MultihashDigest\n\n  if (str.charAt(0) === '1' || str.charAt(0) === 'Q') {\n    // identity hash ed25519/secp256k1 key or sha2-256 hash of\n    // rsa public key - base58btc encoded either way\n    multihash = Digest.decode(base58btc.decode(`z${str}`))\n  } else if (str.startsWith('k51qzi5uqu5') || str.startsWith('kzwfwjn5ji4') || str.startsWith('k2k4r8') || str.startsWith('bafz')) {\n    // base36 encoded CIDv1 with libp2p-key and identity hash (for ed25519/secp256k1/rsa) or base32 encoded CIDv1 with libp2p-key and identity hash (for ed25519/secp256k1/rsa)\n    return peerIdFromCID(CID.parse(str))\n  } else {\n    if (decoder == null) {\n      throw new InvalidParametersError('Please pass a multibase decoder for strings that do not start with \"1\" or \"Q\"')\n    }\n\n    multihash = Digest.decode(decoder.decode(str))\n  }\n\n  return peerIdFromMultihash(multihash)\n}\n\nexport function peerIdFromPublicKey (publicKey: Ed25519PublicKey): Ed25519PeerId\nexport function peerIdFromPublicKey (publicKey: Secp256k1PublicKey): Secp256k1PeerId\nexport function peerIdFromPublicKey (publicKey: RSAPublicKey): RSAPeerId\nexport function peerIdFromPublicKey (publicKey: PublicKey): PeerId\nexport function peerIdFromPublicKey (publicKey: PublicKey): PeerId {\n  if (publicKey.type === 'Ed25519') {\n    return new Ed25519PeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  } else if (publicKey.type === 'secp256k1') {\n    return new Secp256k1PeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  } else if (publicKey.type === 'RSA') {\n    return new RSAPeerIdClass({\n      multihash: publicKey.toCID().multihash,\n      publicKey\n    })\n  }\n\n  throw new UnsupportedKeyTypeError()\n}\n\nexport function peerIdFromPrivateKey (privateKey: Ed25519PrivateKey): Ed25519PeerId\nexport function peerIdFromPrivateKey (privateKey: Secp256k1PrivateKey): Secp256k1PeerId\nexport function peerIdFromPrivateKey (privateKey: RSAPrivateKey): RSAPeerId\nexport function peerIdFromPrivateKey (privateKey: PrivateKey): PeerId\nexport function peerIdFromPrivateKey (privateKey: PrivateKey): PeerId {\n  return peerIdFromPublicKey(privateKey.publicKey)\n}\n\nexport function peerIdFromMultihash (multihash: MultihashDigest): PeerId {\n  if (isSha256Multihash(multihash)) {\n    return new RSAPeerIdClass({ multihash })\n  } else if (isIdentityMultihash(multihash)) {\n    try {\n      const publicKey = publicKeyFromMultihash(multihash)\n\n      if (publicKey.type === 'Ed25519') {\n        return new Ed25519PeerIdClass({ multihash, publicKey })\n      } else if (publicKey.type === 'secp256k1') {\n        return new Secp256k1PeerIdClass({ multihash, publicKey })\n      }\n    } catch (err) {\n      // was not Ed or secp key, try URL\n      const url = uint8ArrayToString(multihash.digest)\n\n      return new URLPeerIdClass(new URL(url))\n    }\n  }\n\n  throw new InvalidMultihashError('Supplied PeerID Multihash is invalid')\n}\n\nexport function peerIdFromCID (cid: CID): Ed25519PeerId | Secp256k1PeerId | RSAPeerId | URLPeerId {\n  if (cid?.multihash == null || cid.version == null || (cid.version === 1 && (cid.code !== LIBP2P_KEY_CODE) && cid.code !== TRANSPORT_IPFS_GATEWAY_HTTP_CODE)) {\n    throw new InvalidCIDError('Supplied PeerID CID is invalid')\n  }\n\n  if (cid.code === TRANSPORT_IPFS_GATEWAY_HTTP_CODE) {\n    const url = uint8ArrayToString(cid.multihash.digest)\n\n    return new URLPeerIdClass(new URL(url))\n  }\n\n  return peerIdFromMultihash(cid.multihash)\n}\n\nfunction isIdentityMultihash (multihash: MultihashDigest): multihash is MultihashDigest<0x0> {\n  return multihash.code === identity.code\n}\n\nfunction isSha256Multihash (multihash: MultihashDigest): multihash is MultihashDigest<0x12> {\n  return multihash.code === sha256.code\n}\n", "/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n\n/**\n * The incoming stream ended before the expected number of bytes were read\n */\nexport class UnexpectedEOFError extends Error {\n  name = 'UnexpectedEOFError'\n  code = 'ERR_UNEXPECTED_EOF'\n}\n", "export function isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n", "import * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { allocUnsafe } from 'uint8arrays/alloc'\nimport { MAX_DATA_LENGTH } from './constants.js'\nimport { InvalidDataLengthError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { EncoderOptions, LengthEncoderFunction } from './index.js'\nimport type { Source } from 'it-stream-types'\n\n// Helper function to validate the chunk size against maxDataLength\nfunction validateMaxDataLength (chunk: Uint8Array | Uint8ArrayList, maxDataLength: number): void {\n  if (chunk.byteLength > maxDataLength) {\n    throw new InvalidDataLengthError('Message length too long')\n  }\n}\n\nconst defaultEncoder: LengthEncoderFunction = (length) => {\n  const lengthLength = varint.encodingLength(length)\n  const lengthBuf = allocUnsafe(lengthLength)\n\n  varint.encode(length, lengthBuf)\n\n  defaultEncoder.bytes = lengthLength\n\n  return lengthBuf\n}\ndefaultEncoder.bytes = 0\n\nexport function encode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): AsyncGenerator<Uint8Array, void, undefined>\nexport function encode (source: Source<Uint8ArrayList | Uint8Array>, options?: EncoderOptions): Generator<Uint8Array, void, undefined> | AsyncGenerator<Uint8Array, void, undefined> {\n  options = options ?? {}\n\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (chunk: Uint8Array | Uint8ArrayList): Generator<Uint8Array, void, undefined> {\n    validateMaxDataLength(chunk, maxDataLength)\n\n    // length + data\n    const length = encodeLength(chunk.byteLength)\n\n    // yield only Uint8Arrays\n    if (length instanceof Uint8Array) {\n      yield length\n    } else {\n      yield * length\n    }\n\n    // yield only Uint8Arrays\n    if (chunk instanceof Uint8Array) {\n      yield chunk\n    } else {\n      yield * chunk\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const chunk of source) {\n        yield * maybeYield(chunk)\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const chunk of source) {\n      yield * maybeYield(chunk)\n    }\n  })()\n}\n\nencode.single = (chunk: Uint8ArrayList | Uint8Array, options?: EncoderOptions) => {\n  options = options ?? {}\n  const encodeLength = options.lengthEncoder ?? defaultEncoder\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  validateMaxDataLength(chunk, maxDataLength)\n\n  return new Uint8ArrayList(\n    encodeLength(chunk.byteLength),\n    chunk\n  )\n}\n", "/* eslint max-depth: [\"error\", 6] */\n\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { MAX_DATA_LENGTH, MAX_LENGTH_LENGTH } from './constants.js'\nimport { InvalidDataLengthError, InvalidDataLengthLengthError, InvalidMessageLengthError, UnexpectedEOFError } from './errors.js'\nimport { isAsyncIterable } from './utils.js'\nimport type { DecoderOptions, LengthDecoderFunction } from './index.js'\nimport type { Reader } from 'it-reader'\nimport type { Source } from 'it-stream-types'\n\nenum ReadMode {\n  LENGTH,\n  DATA\n}\n\nconst defaultDecoder: LengthDecoderFunction = (buf) => {\n  const length = varint.decode(buf)\n  defaultDecoder.bytes = varint.encodingLength(length)\n\n  return length\n}\ndefaultDecoder.bytes = 0\n\nexport function decode (source: Iterable<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): AsyncGenerator<Uint8ArrayList, void, unknown>\nexport function decode (source: Source<Uint8ArrayList | Uint8Array>, options?: DecoderOptions): Generator<Uint8ArrayList, void, unknown> | AsyncGenerator<Uint8ArrayList, void, unknown> {\n  const buffer = new Uint8ArrayList()\n  let mode = ReadMode.LENGTH\n  let dataLength = -1\n\n  const lengthDecoder = options?.lengthDecoder ?? defaultDecoder\n  const maxLengthLength = options?.maxLengthLength ?? MAX_LENGTH_LENGTH\n  const maxDataLength = options?.maxDataLength ?? MAX_DATA_LENGTH\n\n  function * maybeYield (): Generator<Uint8ArrayList> {\n    while (buffer.byteLength > 0) {\n      if (mode === ReadMode.LENGTH) {\n        // read length, ignore errors for short reads\n        try {\n          dataLength = lengthDecoder(buffer)\n\n          if (dataLength < 0) {\n            throw new InvalidMessageLengthError('Invalid message length')\n          }\n\n          if (dataLength > maxDataLength) {\n            throw new InvalidDataLengthError('Message length too long')\n          }\n\n          const dataLengthLength = lengthDecoder.bytes\n          buffer.consume(dataLengthLength)\n\n          if (options?.onLength != null) {\n            options.onLength(dataLength)\n          }\n\n          mode = ReadMode.DATA\n        } catch (err: any) {\n          if (err instanceof RangeError) {\n            if (buffer.byteLength > maxLengthLength) {\n              throw new InvalidDataLengthLengthError('Message length length too long')\n            }\n\n            break\n          }\n\n          throw err\n        }\n      }\n\n      if (mode === ReadMode.DATA) {\n        if (buffer.byteLength < dataLength) {\n          // not enough data, wait for more\n          break\n        }\n\n        const data = buffer.sublist(0, dataLength)\n        buffer.consume(dataLength)\n\n        if (options?.onData != null) {\n          options.onData(data)\n        }\n\n        yield data\n\n        mode = ReadMode.LENGTH\n      }\n    }\n  }\n\n  if (isAsyncIterable(source)) {\n    return (async function * () {\n      for await (const buf of source) {\n        buffer.append(buf)\n\n        yield * maybeYield()\n      }\n\n      if (buffer.byteLength > 0) {\n        throw new UnexpectedEOFError('Unexpected end of input')\n      }\n    })()\n  }\n\n  return (function * () {\n    for (const buf of source) {\n      buffer.append(buf)\n\n      yield * maybeYield()\n    }\n\n    if (buffer.byteLength > 0) {\n      throw new UnexpectedEOFError('Unexpected end of input')\n    }\n  })()\n}\n\ndecode.fromReader = (reader: Reader, options?: DecoderOptions) => {\n  let byteLength = 1 // Read single byte chunks until the length is known\n\n  const varByteSource = (async function * () {\n    while (true) {\n      try {\n        const { done, value } = await reader.next(byteLength)\n\n        if (done === true) {\n          return\n        }\n\n        if (value != null) {\n          yield value\n        }\n      } catch (err: any) {\n        if (err.code === 'ERR_UNDER_READ') {\n          return { done: true, value: null }\n        }\n        throw err\n      } finally {\n        // Reset the byteLength so we continue to check for varints\n        byteLength = 1\n      }\n    }\n  }())\n\n  /**\n   * Once the length has been parsed, read chunk for that length\n   */\n  const onLength = (l: number): void => { byteLength = l }\n  return decode(varByteSource, {\n    ...(options ?? {}),\n    onLength\n  })\n}\n", "export default function pDefer() {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\treturn deferred;\n}\n", "// ported from https://www.npmjs.com/package/fast-fifo\n\nexport interface Next<T> {\n  done?: boolean\n  error?: Error\n  value?: T\n}\n\nclass FixedFIFO<T> {\n  public buffer: Array<Next<T> | undefined>\n  private readonly mask: number\n  private top: number\n  private btm: number\n  public next: FixedFIFO<T> | null\n\n  constructor (hwm: number) {\n    if (!(hwm > 0) || ((hwm - 1) & hwm) !== 0) {\n      throw new Error('Max size for a FixedFIFO should be a power of two')\n    }\n\n    this.buffer = new Array(hwm)\n    this.mask = hwm - 1\n    this.top = 0\n    this.btm = 0\n    this.next = null\n  }\n\n  push (data: Next<T>): boolean {\n    if (this.buffer[this.top] !== undefined) {\n      return false\n    }\n\n    this.buffer[this.top] = data\n    this.top = (this.top + 1) & this.mask\n\n    return true\n  }\n\n  shift (): Next<T> | undefined {\n    const last = this.buffer[this.btm]\n\n    if (last === undefined) {\n      return undefined\n    }\n\n    this.buffer[this.btm] = undefined\n    this.btm = (this.btm + 1) & this.mask\n    return last\n  }\n\n  isEmpty (): boolean {\n    return this.buffer[this.btm] === undefined\n  }\n}\n\nexport interface FIFOOptions {\n  /**\n   * When the queue reaches this size, it will be split into head/tail parts\n   */\n  splitLimit?: number\n}\n\nexport class FIFO<T> {\n  public size: number\n  private readonly hwm: number\n  private head: FixedFIFO<T>\n  private tail: FixedFIFO<T>\n\n  constructor (options: FIFOOptions = {}) {\n    this.hwm = options.splitLimit ?? 16\n    this.head = new FixedFIFO<T>(this.hwm)\n    this.tail = this.head\n    this.size = 0\n  }\n\n  calculateSize (obj: any): number {\n    if (obj?.byteLength != null) {\n      return obj.byteLength\n    }\n\n    return 1\n  }\n\n  push (val: Next<T>): void {\n    if (val?.value != null) {\n      this.size += this.calculateSize(val.value)\n    }\n\n    if (!this.head.push(val)) {\n      const prev = this.head\n      this.head = prev.next = new FixedFIFO<T>(2 * this.head.buffer.length)\n      this.head.push(val)\n    }\n  }\n\n  shift (): Next<T> | undefined {\n    let val = this.tail.shift()\n\n    if (val === undefined && (this.tail.next != null)) {\n      const next = this.tail.next\n      this.tail.next = null\n      this.tail = next\n      val = this.tail.shift()\n    }\n\n    if (val?.value != null) {\n      this.size -= this.calculateSize(val.value)\n    }\n\n    return val\n  }\n\n  isEmpty (): boolean {\n    return this.head.isEmpty()\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * An iterable that you can push values into.\n *\n * @example\n *\n * ```js\n * import { pushable } from 'it-pushable'\n *\n * const source = pushable()\n *\n * setTimeout(() => source.push('hello'), 100)\n * setTimeout(() => source.push('world'), 200)\n * setTimeout(() => source.end(), 300)\n *\n * const start = Date.now()\n *\n * for await (const value of source) {\n *   console.log(`got \"${value}\" after ${Date.now() - start}ms`)\n * }\n * console.log(`done after ${Date.now() - start}ms`)\n *\n * // Output:\n * // got \"hello\" after 105ms\n * // got \"world\" after 207ms\n * // done after 309ms\n * ```\n *\n * @example\n *\n * ```js\n * import { pushableV } from 'it-pushable'\n * import all from 'it-all'\n *\n * const source = pushableV()\n *\n * source.push(1)\n * source.push(2)\n * source.push(3)\n * source.end()\n *\n * console.info(await all(source))\n *\n * // Output:\n * // [ [1, 2, 3] ]\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { FIFO, type Next } from './fifo.js'\n\nexport class AbortError extends Error {\n  type: string\n  code: string\n\n  constructor (message?: string, code?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface AbortOptions {\n  signal?: AbortSignal\n}\n\ninterface BasePushable<T> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error): this\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T): this\n\n  /**\n   * Returns a promise that resolves when the underlying queue becomes empty (e.g.\n   * this.readableLength === 0).\n   *\n   * If an AbortSignal is passed as an option and that signal aborts, it only\n   * causes the returned promise to reject - it does not end the pushable.\n   */\n  onEmpty(options?: AbortOptions): Promise<void>\n\n  /**\n   * This property contains the number of bytes (or objects) in the queue ready to be read.\n   *\n   * If `objectMode` is true, this is the number of objects in the queue, if false it's the\n   * total number of bytes in the queue.\n   */\n  readableLength: number\n}\n\n/**\n * An iterable that you can push values into.\n */\nexport interface Pushable<T, R = void, N = unknown> extends AsyncGenerator<T, R, N>, BasePushable<T> {}\n\n/**\n * Similar to `pushable`, except it yields multiple buffered chunks at a time. All values yielded from the iterable will be arrays.\n */\nexport interface PushableV<T, R = void, N = unknown> extends AsyncGenerator<T[], R, N>, BasePushable<T> {}\n\nexport interface Options {\n  /**\n   * A boolean value that means non-`Uint8Array`s will be passed to `.push`, default: `false`\n   */\n  objectMode?: boolean\n\n  /**\n   * A function called after *all* values have been yielded from the iterator (including\n   * buffered values). In the case when the iterator is ended with an error it will be\n   * passed the error as a parameter.\n   */\n  onEnd?(err?: Error): void\n}\n\nexport interface DoneResult { done: true }\nexport interface ValueResult<T> { done: false, value: T }\nexport type NextResult<T> = ValueResult<T> | DoneResult\n\ninterface getNext<T, V = T> { (buffer: FIFO<T>): NextResult<V> }\n\nexport interface ObjectPushableOptions extends Options {\n  objectMode: true\n}\n\nexport interface BytePushableOptions extends Options {\n  objectMode?: false\n}\n\n/**\n * Create a new async iterable. The values yielded from calls to `.next()`\n * or when used in a `for await of`loop are \"pushed\" into the iterable.\n * Returns an async iterable object with additional methods.\n */\nexport function pushable<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): Pushable<T>\nexport function pushable<T> (options: ObjectPushableOptions): Pushable<T>\nexport function pushable<T> (options: Options = {}): Pushable<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T> => {\n    const next: Next<T> | undefined = buffer.shift()\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    if (next.error != null) {\n      throw next.error\n    }\n\n    return {\n      done: next.done === true,\n      // @ts-expect-error if done is false, value will be present\n      value: next.value\n    }\n  }\n\n  return _pushable<T, T, Pushable<T>>(getNext, options)\n}\n\nexport function pushableV<T extends { byteLength: number } = Uint8Array> (options?: BytePushableOptions): PushableV<T>\nexport function pushableV<T> (options: ObjectPushableOptions): PushableV<T>\nexport function pushableV<T> (options: Options = {}): PushableV<T> {\n  const getNext = (buffer: FIFO<T>): NextResult<T[]> => {\n    let next: Next<T> | undefined\n    const values: T[] = []\n\n    while (!buffer.isEmpty()) {\n      next = buffer.shift()\n\n      if (next == null) {\n        break\n      }\n\n      if (next.error != null) {\n        throw next.error\n      }\n\n      if (next.done === false) {\n        // @ts-expect-error if done is false value should be pushed\n        values.push(next.value)\n      }\n    }\n\n    if (next == null) {\n      return { done: true }\n    }\n\n    return {\n      done: next.done === true,\n      value: values\n    }\n  }\n\n  return _pushable<T, T[], PushableV<T>>(getNext, options)\n}\n\nfunction _pushable<PushType, ValueType, ReturnType> (getNext: getNext<PushType, ValueType>, options?: Options): ReturnType {\n  options = options ?? {}\n  let onEnd = options.onEnd\n  let buffer = new FIFO<PushType>()\n  let pushable: any\n  let onNext: ((next: Next<PushType>) => ReturnType) | null\n  let ended: boolean\n  let drain = deferred()\n\n  const waitNext = async (): Promise<NextResult<ValueType>> => {\n    try {\n      if (!buffer.isEmpty()) {\n        return getNext(buffer)\n      }\n\n      if (ended) {\n        return { done: true }\n      }\n\n      return await new Promise<NextResult<ValueType>>((resolve, reject) => {\n        onNext = (next: Next<PushType>) => {\n          onNext = null\n          buffer.push(next)\n\n          try {\n            resolve(getNext(buffer))\n          } catch (err) {\n            reject(err)\n          }\n\n          return pushable\n        }\n      })\n    } finally {\n      if (buffer.isEmpty()) {\n        // settle promise in the microtask queue to give consumers a chance to\n        // await after calling .push\n        queueMicrotask(() => {\n          drain.resolve()\n          drain = deferred()\n        })\n      }\n    }\n  }\n\n  const bufferNext = (next: Next<PushType>): ReturnType => {\n    if (onNext != null) {\n      return onNext(next)\n    }\n\n    buffer.push(next)\n    return pushable\n  }\n\n  const bufferError = (err: Error): ReturnType => {\n    buffer = new FIFO()\n\n    if (onNext != null) {\n      return onNext({ error: err })\n    }\n\n    buffer.push({ error: err })\n    return pushable\n  }\n\n  const push = (value: PushType): ReturnType => {\n    if (ended) {\n      return pushable\n    }\n\n    // @ts-expect-error `byteLength` is not declared on PushType\n    if (options?.objectMode !== true && value?.byteLength == null) {\n      throw new Error('objectMode was not true but tried to push non-Uint8Array value')\n    }\n\n    return bufferNext({ done: false, value })\n  }\n  const end = (err?: Error): ReturnType => {\n    if (ended) return pushable\n    ended = true\n\n    return (err != null) ? bufferError(err) : bufferNext({ done: true })\n  }\n  const _return = (): DoneResult => {\n    buffer = new FIFO()\n    end()\n\n    return { done: true }\n  }\n  const _throw = (err: Error): DoneResult => {\n    end(err)\n\n    return { done: true }\n  }\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next: waitNext,\n    return: _return,\n    throw: _throw,\n    push,\n    end,\n    get readableLength (): number {\n      return buffer.size\n    },\n    onEmpty: async (options?: AbortOptions) => {\n      const signal = options?.signal\n      signal?.throwIfAborted()\n\n      if (buffer.isEmpty()) {\n        return\n      }\n\n      let cancel: Promise<void> | undefined\n      let listener: (() => void) | undefined\n\n      if (signal != null) {\n        cancel = new Promise((resolve, reject) => {\n          listener = () => {\n            reject(new AbortError())\n          }\n\n          signal.addEventListener('abort', listener)\n        })\n      }\n\n      try {\n        await Promise.race([\n          drain.promise,\n          cancel\n        ])\n      } finally {\n        if (listener != null && signal != null) {\n          signal?.removeEventListener('abort', listener)\n        }\n      }\n    }\n  }\n\n  if (onEnd == null) {\n    return pushable\n  }\n\n  const _pushable = pushable\n\n  pushable = {\n    [Symbol.asyncIterator] () { return this },\n    next () {\n      return _pushable.next()\n    },\n    throw (err: Error) {\n      _pushable.throw(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    return () {\n      _pushable.return()\n\n      if (onEnd != null) {\n        onEnd()\n        onEnd = undefined\n      }\n\n      return { done: true }\n    },\n    push,\n    end (err: Error) {\n      _pushable.end(err)\n\n      if (onEnd != null) {\n        onEnd(err)\n        onEnd = undefined\n      }\n\n      return pushable\n    },\n    get readableLength () {\n      return _pushable.readableLength\n    },\n    onEmpty: (opts?: AbortOptions) => {\n      return _pushable.onEmpty(opts)\n    }\n  }\n\n  return pushable\n}\n", "/**\n * An abort error class that extends error\n */\nexport class AbortError extends Error {\n  public type: string\n  public code: string | string\n\n  constructor (message?: string, code?: string, name?: string) {\n    super(message ?? 'The operation was aborted')\n    this.type = 'aborted'\n    this.name = name ?? 'AbortError'\n    this.code = code ?? 'ABORT_ERR'\n  }\n}\n\nexport interface RaceSignalOptions {\n  /**\n   * The message for the error thrown if the signal aborts\n   */\n  errorMessage?: string\n\n  /**\n   * The code for the error thrown if the signal aborts\n   */\n  errorCode?: string\n\n  /**\n   * The name for the error thrown if the signal aborts\n   */\n  errorName?: string\n}\n\n/**\n * Race a promise against an abort signal\n */\nexport async function raceSignal <T> (promise: Promise<T>, signal?: AbortSignal, opts?: RaceSignalOptions): Promise<T> {\n  if (signal == null) {\n    return promise\n  }\n\n  if (signal.aborted) {\n    // the passed promise may yet resolve or reject but the use has signalled\n    // they are no longer interested so smother the error\n    promise.catch(() => {})\n    return Promise.reject(new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName))\n  }\n\n  let listener\n\n  // create the error here so we have more context in the stack trace\n  const error = new AbortError(opts?.errorMessage, opts?.errorCode, opts?.errorName)\n\n  try {\n    return await Promise.race([\n      promise,\n      new Promise<T>((resolve, reject) => {\n        listener = () => {\n          reject(error)\n        }\n        signal.addEventListener('abort', listener)\n      })\n    ])\n  } finally {\n    if (listener != null) {\n      signal.removeEventListener('abort', listener)\n    }\n  }\n}\n", "/**\n * @packageDocumentation\n *\n * A pushable async generator that waits until the current value is consumed\n * before allowing a new value to be pushed.\n *\n * Useful for when you don't want to keep memory usage under control and/or\n * allow a downstream consumer to dictate how fast data flows through a pipe,\n * but you want to be able to apply a transform to that data.\n *\n * @example\n *\n * ```typescript\n * import { queuelessPushable } from 'it-queueless-pushable'\n *\n * const pushable = queuelessPushable<string>()\n *\n * // run asynchronously\n * Promise.resolve().then(async () => {\n *   // push a value - the returned promise will not resolve until the value is\n *   // read from the pushable\n *   await pushable.push('hello')\n * })\n *\n * // read a value\n * const result = await pushable.next()\n * console.info(result) // { done: false, value: 'hello' }\n * ```\n */\n\nimport deferred from 'p-defer'\nimport { raceSignal } from 'race-signal'\nimport type { AbortOptions } from 'abort-error'\nimport type { RaceSignalOptions } from 'race-signal'\n\nexport interface Pushable<T> extends AsyncGenerator<T, void, unknown> {\n  /**\n   * End the iterable after all values in the buffer (if any) have been yielded. If an\n   * error is passed the buffer is cleared immediately and the next iteration will\n   * throw the passed error\n   */\n  end(err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void>\n\n  /**\n   * Push a value into the iterable. Values are yielded from the iterable in the order\n   * they are pushed. Values not yet consumed from the iterable are buffered.\n   */\n  push(value: T, options?: AbortOptions & RaceSignalOptions): Promise<void>\n}\n\nclass QueuelessPushable <T> implements Pushable<T> {\n  private readNext: PromiseWithResolvers<void>\n  private haveNext: PromiseWithResolvers<void>\n  private ended: boolean\n  private nextResult: IteratorResult<T> | undefined\n  private error?: Error\n\n  constructor () {\n    this.ended = false\n\n    this.readNext = deferred()\n    this.haveNext = deferred()\n  }\n\n  [Symbol.asyncIterator] (): AsyncGenerator<T, void, unknown> {\n    return this\n  }\n\n  async next (): Promise<IteratorResult<T, void>> {\n    if (this.nextResult == null) {\n      // wait for the supplier to push a value\n      await this.haveNext.promise\n    }\n\n    if (this.nextResult == null) {\n      throw new Error('HaveNext promise resolved but nextResult was undefined')\n    }\n\n    const nextResult = this.nextResult\n    this.nextResult = undefined\n\n    // signal to the supplier that we read the value\n    this.readNext.resolve()\n    this.readNext = deferred()\n\n    return nextResult\n  }\n\n  async throw (err?: Error): Promise<IteratorReturnResult<undefined>> {\n    this.ended = true\n    this.error = err\n\n    if (err != null) {\n      // this can cause unhandled promise rejections if nothing is awaiting the\n      // next value so attach a dummy catch listener to the promise\n      this.haveNext.promise.catch(() => {})\n      this.haveNext.reject(err)\n    }\n\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    return result\n  }\n\n  async return (): Promise<IteratorResult<T>> {\n    const result: IteratorReturnResult<undefined> = {\n      done: true,\n      value: undefined\n    }\n\n    this.ended = true\n    this.nextResult = result\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n\n    return result\n  }\n\n  async push (value: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    await this._push(value, options)\n  }\n\n  async end (err?: Error, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (err != null) {\n      await this.throw(err)\n    } else {\n      // abortable return\n      await this._push(undefined, options)\n    }\n  }\n\n  private async _push (value?: T, options?: AbortOptions & RaceSignalOptions): Promise<void> {\n    if (value != null && this.ended) {\n      throw this.error ?? new Error('Cannot push value onto an ended pushable')\n    }\n\n    // wait for all values to be read\n    while (this.nextResult != null) {\n      await this.readNext.promise\n    }\n\n    if (value != null) {\n      this.nextResult = { done: false, value }\n    } else {\n      this.ended = true\n      this.nextResult = { done: true, value: undefined }\n    }\n\n    // let the consumer know we have a new value\n    this.haveNext.resolve()\n    this.haveNext = deferred()\n\n    // wait for the consumer to have finished processing the value and requested\n    // the next one or for the passed signal to abort the waiting\n    await raceSignal(\n      this.readNext.promise,\n      options?.signal,\n      options\n    )\n  }\n}\n\nexport function queuelessPushable <T> (): Pushable<T> {\n  return new QueuelessPushable<T>()\n}\n", "/**\n * @packageDocumentation\n *\n * Merge several (async)iterables into one, yield values as they arrive.\n *\n * Nb. sources are iterated over in parallel so the order of emitted items is not guaranteed.\n *\n * @example\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, generator, etc\n * const values1 = [0, 1, 2, 3, 4]\n * const values2 = [5, 6, 7, 8, 9]\n *\n * const arr = all(merge(values1, values2))\n *\n * console.info(arr) // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n * ```\n *\n * Async sources must be awaited:\n *\n * ```javascript\n * import merge from 'it-merge'\n * import all from 'it-all'\n *\n * // This can also be an iterator, async iterator, generator, etc\n * const values1 = async function * () {\n *   yield * [0, 1, 2, 3, 4]\n * }\n * const values2 = async function * () {\n *   yield * [5, 6, 7, 8, 9]\n * }\n *\n * const arr = await all(merge(values1(), values2()))\n *\n * console.info(arr) // 0, 1, 5, 6, 2, 3, 4, 7, 8, 9  <- nb. order is not guaranteed\n * ```\n */\n\nimport { queuelessPushable } from 'it-queueless-pushable'\nimport type { Pushable } from 'it-queueless-pushable'\n\nfunction isAsyncIterable <T> (thing: any): thing is AsyncIterable<T> {\n  return thing[Symbol.asyncIterator] != null\n}\n\nasync function addAllToPushable <T> (sources: Array<AsyncIterable<T> | Iterable<T>>, output: Pushable<T>, signal: AbortSignal): Promise<void> {\n  try {\n    await Promise.all(\n      sources.map(async (source) => {\n        for await (const item of source) {\n          await output.push(item, {\n            signal\n          })\n          signal.throwIfAborted()\n        }\n      })\n    )\n\n    await output.end(undefined, {\n      signal\n    })\n  } catch (err: any) {\n    await output.end(err, {\n      signal\n    })\n      .catch(() => {})\n  }\n}\n\nasync function * mergeSources <T> (sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> {\n  const controller = new AbortController()\n  const output = queuelessPushable<T>()\n\n  addAllToPushable(sources, output, controller.signal)\n    .catch(() => {})\n\n  try {\n    yield * output\n  } finally {\n    controller.abort()\n  }\n}\n\nfunction * mergeSyncSources <T> (syncSources: Array<Iterable<T>>): Generator<T, void, undefined> {\n  for (const source of syncSources) {\n    yield * source\n  }\n}\n\n/**\n * Treat one or more iterables as a single iterable.\n *\n * Nb. sources are iterated over in parallel so the\n * order of emitted items is not guaranteed.\n */\nfunction merge <T> (...sources: Array<Iterable<T>>): Generator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined>\nfunction merge <T> (...sources: Array<AsyncIterable<T> | Iterable<T>>): AsyncGenerator<T, void, undefined> | Generator<T, void, undefined> {\n  const syncSources: Array<Iterable<T>> = []\n\n  for (const source of sources) {\n    if (!isAsyncIterable(source)) {\n      syncSources.push(source)\n    }\n  }\n\n  if (syncSources.length === sources.length) {\n    // all sources are synchronous\n    return mergeSyncSources(syncSources)\n  }\n\n  return mergeSources(sources)\n}\n\nexport default merge\n", "import { pushable } from 'it-pushable'\nimport merge from 'it-merge'\nimport type { Duplex, Transform, Sink } from 'it-stream-types'\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any>\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A>\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B>\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\n// one item, just a pass-through\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\n\nexport function pipe (first: any, ...rest: any[]): any {\n  if (first == null) {\n    throw new Error('Empty pipeline')\n  }\n\n  // Duplex at start: wrap in function and return duplex source\n  if (isDuplex(first)) {\n    const duplex = first\n    first = () => duplex.source\n  // Iterable at start: wrap in function\n  } else if (isIterable(first) || isAsyncIterable(first)) {\n    const source = first\n    first = () => source\n  }\n\n  const fns = [first, ...rest]\n\n  if (fns.length > 1) {\n    // Duplex at end: use duplex sink\n    if (isDuplex(fns[fns.length - 1])) {\n      fns[fns.length - 1] = fns[fns.length - 1].sink\n    }\n  }\n\n  if (fns.length > 2) {\n    // Duplex in the middle, consume source with duplex sink and return duplex source\n    for (let i = 1; i < fns.length - 1; i++) {\n      if (isDuplex(fns[i])) {\n        fns[i] = duplexPipelineFn(fns[i])\n      }\n    }\n  }\n\n  return rawPipe(...fns)\n}\n\nexport const rawPipe = (...fns: any): any => {\n  let res\n  while (fns.length > 0) {\n    res = fns.shift()(res)\n  }\n  return res\n}\n\nconst isAsyncIterable = (obj: any): obj is AsyncIterable<unknown> => {\n  return obj?.[Symbol.asyncIterator] != null\n}\n\nconst isIterable = (obj: any): obj is Iterable<unknown> => {\n  return obj?.[Symbol.iterator] != null\n}\n\nconst isDuplex = (obj: any): obj is Duplex => {\n  if (obj == null) {\n    return false\n  }\n\n  return obj.sink != null && obj.source != null\n}\n\nconst duplexPipelineFn = (duplex: Duplex<any, any, any>) => {\n  return (source: any) => {\n    const p = duplex.sink(source)\n\n    if (p?.then != null) {\n      const stream = pushable<any>({\n        objectMode: true\n      })\n      p.then(() => {\n        stream.end()\n      }, (err: Error) => {\n        stream.end(err)\n      })\n\n      let sourceWrap: () => Iterable<any> | AsyncIterable<any>\n      const source = duplex.source\n\n      if (isAsyncIterable(source)) {\n        sourceWrap = async function * () {\n          yield * source\n          stream.end()\n        }\n      } else if (isIterable(source)) {\n        sourceWrap = function * () {\n          yield * source\n          stream.end()\n        }\n      } else {\n        throw new Error('Unknown duplex source type - must be Iterable or AsyncIterable')\n      }\n\n      return merge(stream, sourceWrap())\n    }\n\n    return duplex.source\n  }\n}\n", "export interface DecodeRPCLimits {\n  maxSubscriptions: number\n  maxMessages: number\n  maxIhaveMessageIDs: number\n  maxIwantMessageIDs: number\n  maxIdontwantMessageIDs: number\n  maxControlMessages: number\n  maxPeerInfos: number\n}\n\nexport const defaultDecodeRpcLimits: DecodeRPCLimits = {\n  maxSubscriptions: Infinity,\n  maxMessages: Infinity,\n  maxIhaveMessageIDs: Infinity,\n  maxIwantMessageIDs: Infinity,\n  maxIdontwantMessageIDs: Infinity,\n  maxControlMessages: Infinity,\n  maxPeerInfos: Infinity\n}\n", "/* eslint-disable complexity */\n\nimport { decodeMessage, encodeMessage, MaxLengthError, message } from 'protons-runtime'\nimport type { Codec, DecodeOptions } from 'protons-runtime'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nexport interface RPC {\n  subscriptions: RPC.SubOpts[]\n  messages: RPC.Message[]\n  control?: RPC.ControlMessage\n}\n\nexport namespace RPC {\n  export interface SubOpts {\n    subscribe?: boolean\n    topic?: string\n  }\n\n  export namespace SubOpts {\n    let _codec: Codec<SubOpts>\n\n    export const codec = (): Codec<SubOpts> => {\n      if (_codec == null) {\n        _codec = message<SubOpts>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.subscribe != null) {\n            w.uint32(8)\n            w.bool(obj.subscribe)\n          }\n\n          if (obj.topic != null) {\n            w.uint32(18)\n            w.string(obj.topic)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.subscribe = reader.bool()\n                break\n              }\n              case 2: {\n                obj.topic = reader.string()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<SubOpts>): Uint8Array => {\n      return encodeMessage(obj, SubOpts.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<SubOpts>): SubOpts => {\n      return decodeMessage(buf, SubOpts.codec(), opts)\n    }\n  }\n\n  export interface Message {\n    from?: Uint8Array\n    data?: Uint8Array\n    seqno?: Uint8Array\n    topic: string\n    signature?: Uint8Array\n    key?: Uint8Array\n  }\n\n  export namespace Message {\n    let _codec: Codec<Message>\n\n    export const codec = (): Codec<Message> => {\n      if (_codec == null) {\n        _codec = message<Message>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.from != null) {\n            w.uint32(10)\n            w.bytes(obj.from)\n          }\n\n          if (obj.data != null) {\n            w.uint32(18)\n            w.bytes(obj.data)\n          }\n\n          if (obj.seqno != null) {\n            w.uint32(26)\n            w.bytes(obj.seqno)\n          }\n\n          if ((obj.topic != null && obj.topic !== '')) {\n            w.uint32(34)\n            w.string(obj.topic)\n          }\n\n          if (obj.signature != null) {\n            w.uint32(42)\n            w.bytes(obj.signature)\n          }\n\n          if (obj.key != null) {\n            w.uint32(50)\n            w.bytes(obj.key)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            topic: ''\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.from = reader.bytes()\n                break\n              }\n              case 2: {\n                obj.data = reader.bytes()\n                break\n              }\n              case 3: {\n                obj.seqno = reader.bytes()\n                break\n              }\n              case 4: {\n                obj.topic = reader.string()\n                break\n              }\n              case 5: {\n                obj.signature = reader.bytes()\n                break\n              }\n              case 6: {\n                obj.key = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<Message>): Uint8Array => {\n      return encodeMessage(obj, Message.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<Message>): Message => {\n      return decodeMessage(buf, Message.codec(), opts)\n    }\n  }\n\n  export interface ControlMessage {\n    ihave: RPC.ControlIHave[]\n    iwant: RPC.ControlIWant[]\n    graft: RPC.ControlGraft[]\n    prune: RPC.ControlPrune[]\n    idontwant: RPC.ControlIDontWant[]\n  }\n\n  export namespace ControlMessage {\n    let _codec: Codec<ControlMessage>\n\n    export const codec = (): Codec<ControlMessage> => {\n      if (_codec == null) {\n        _codec = message<ControlMessage>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.ihave != null) {\n            for (const value of obj.ihave) {\n              w.uint32(10)\n              RPC.ControlIHave.codec().encode(value, w)\n            }\n          }\n\n          if (obj.iwant != null) {\n            for (const value of obj.iwant) {\n              w.uint32(18)\n              RPC.ControlIWant.codec().encode(value, w)\n            }\n          }\n\n          if (obj.graft != null) {\n            for (const value of obj.graft) {\n              w.uint32(26)\n              RPC.ControlGraft.codec().encode(value, w)\n            }\n          }\n\n          if (obj.prune != null) {\n            for (const value of obj.prune) {\n              w.uint32(34)\n              RPC.ControlPrune.codec().encode(value, w)\n            }\n          }\n\n          if (obj.idontwant != null) {\n            for (const value of obj.idontwant) {\n              w.uint32(42)\n              RPC.ControlIDontWant.codec().encode(value, w)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            ihave: [],\n            iwant: [],\n            graft: [],\n            prune: [],\n            idontwant: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                if (opts.limits?.ihave != null && obj.ihave.length === opts.limits.ihave) {\n                  throw new MaxLengthError('Decode error - map field \"ihave\" had too many elements')\n                }\n\n                obj.ihave.push(RPC.ControlIHave.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.ihave$\n                }))\n                break\n              }\n              case 2: {\n                if (opts.limits?.iwant != null && obj.iwant.length === opts.limits.iwant) {\n                  throw new MaxLengthError('Decode error - map field \"iwant\" had too many elements')\n                }\n\n                obj.iwant.push(RPC.ControlIWant.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.iwant$\n                }))\n                break\n              }\n              case 3: {\n                if (opts.limits?.graft != null && obj.graft.length === opts.limits.graft) {\n                  throw new MaxLengthError('Decode error - map field \"graft\" had too many elements')\n                }\n\n                obj.graft.push(RPC.ControlGraft.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.graft$\n                }))\n                break\n              }\n              case 4: {\n                if (opts.limits?.prune != null && obj.prune.length === opts.limits.prune) {\n                  throw new MaxLengthError('Decode error - map field \"prune\" had too many elements')\n                }\n\n                obj.prune.push(RPC.ControlPrune.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.prune$\n                }))\n                break\n              }\n              case 5: {\n                if (opts.limits?.idontwant != null && obj.idontwant.length === opts.limits.idontwant) {\n                  throw new MaxLengthError('Decode error - map field \"idontwant\" had too many elements')\n                }\n\n                obj.idontwant.push(RPC.ControlIDontWant.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.idontwant$\n                }))\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlMessage>): Uint8Array => {\n      return encodeMessage(obj, ControlMessage.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlMessage>): ControlMessage => {\n      return decodeMessage(buf, ControlMessage.codec(), opts)\n    }\n  }\n\n  export interface ControlIHave {\n    topicID?: string\n    messageIDs: Uint8Array[]\n  }\n\n  export namespace ControlIHave {\n    let _codec: Codec<ControlIHave>\n\n    export const codec = (): Codec<ControlIHave> => {\n      if (_codec == null) {\n        _codec = message<ControlIHave>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.topicID != null) {\n            w.uint32(10)\n            w.string(obj.topicID)\n          }\n\n          if (obj.messageIDs != null) {\n            for (const value of obj.messageIDs) {\n              w.uint32(18)\n              w.bytes(value)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            messageIDs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.topicID = reader.string()\n                break\n              }\n              case 2: {\n                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                  throw new MaxLengthError('Decode error - map field \"messageIDs\" had too many elements')\n                }\n\n                obj.messageIDs.push(reader.bytes())\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlIHave>): Uint8Array => {\n      return encodeMessage(obj, ControlIHave.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIHave>): ControlIHave => {\n      return decodeMessage(buf, ControlIHave.codec(), opts)\n    }\n  }\n\n  export interface ControlIWant {\n    messageIDs: Uint8Array[]\n  }\n\n  export namespace ControlIWant {\n    let _codec: Codec<ControlIWant>\n\n    export const codec = (): Codec<ControlIWant> => {\n      if (_codec == null) {\n        _codec = message<ControlIWant>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.messageIDs != null) {\n            for (const value of obj.messageIDs) {\n              w.uint32(10)\n              w.bytes(value)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            messageIDs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                  throw new MaxLengthError('Decode error - map field \"messageIDs\" had too many elements')\n                }\n\n                obj.messageIDs.push(reader.bytes())\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlIWant>): Uint8Array => {\n      return encodeMessage(obj, ControlIWant.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIWant>): ControlIWant => {\n      return decodeMessage(buf, ControlIWant.codec(), opts)\n    }\n  }\n\n  export interface ControlGraft {\n    topicID?: string\n  }\n\n  export namespace ControlGraft {\n    let _codec: Codec<ControlGraft>\n\n    export const codec = (): Codec<ControlGraft> => {\n      if (_codec == null) {\n        _codec = message<ControlGraft>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.topicID != null) {\n            w.uint32(10)\n            w.string(obj.topicID)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.topicID = reader.string()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlGraft>): Uint8Array => {\n      return encodeMessage(obj, ControlGraft.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlGraft>): ControlGraft => {\n      return decodeMessage(buf, ControlGraft.codec(), opts)\n    }\n  }\n\n  export interface ControlPrune {\n    topicID?: string\n    peers: RPC.PeerInfo[]\n    backoff?: number\n  }\n\n  export namespace ControlPrune {\n    let _codec: Codec<ControlPrune>\n\n    export const codec = (): Codec<ControlPrune> => {\n      if (_codec == null) {\n        _codec = message<ControlPrune>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.topicID != null) {\n            w.uint32(10)\n            w.string(obj.topicID)\n          }\n\n          if (obj.peers != null) {\n            for (const value of obj.peers) {\n              w.uint32(18)\n              RPC.PeerInfo.codec().encode(value, w)\n            }\n          }\n\n          if (obj.backoff != null) {\n            w.uint32(24)\n            w.uint64Number(obj.backoff)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            peers: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.topicID = reader.string()\n                break\n              }\n              case 2: {\n                if (opts.limits?.peers != null && obj.peers.length === opts.limits.peers) {\n                  throw new MaxLengthError('Decode error - map field \"peers\" had too many elements')\n                }\n\n                obj.peers.push(RPC.PeerInfo.codec().decode(reader, reader.uint32(), {\n                  limits: opts.limits?.peers$\n                }))\n                break\n              }\n              case 3: {\n                obj.backoff = reader.uint64Number()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlPrune>): Uint8Array => {\n      return encodeMessage(obj, ControlPrune.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlPrune>): ControlPrune => {\n      return decodeMessage(buf, ControlPrune.codec(), opts)\n    }\n  }\n\n  export interface PeerInfo {\n    peerID?: Uint8Array\n    signedPeerRecord?: Uint8Array\n  }\n\n  export namespace PeerInfo {\n    let _codec: Codec<PeerInfo>\n\n    export const codec = (): Codec<PeerInfo> => {\n      if (_codec == null) {\n        _codec = message<PeerInfo>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.peerID != null) {\n            w.uint32(10)\n            w.bytes(obj.peerID)\n          }\n\n          if (obj.signedPeerRecord != null) {\n            w.uint32(18)\n            w.bytes(obj.signedPeerRecord)\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {}\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                obj.peerID = reader.bytes()\n                break\n              }\n              case 2: {\n                obj.signedPeerRecord = reader.bytes()\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<PeerInfo>): Uint8Array => {\n      return encodeMessage(obj, PeerInfo.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<PeerInfo>): PeerInfo => {\n      return decodeMessage(buf, PeerInfo.codec(), opts)\n    }\n  }\n\n  export interface ControlIDontWant {\n    messageIDs: Uint8Array[]\n  }\n\n  export namespace ControlIDontWant {\n    let _codec: Codec<ControlIDontWant>\n\n    export const codec = (): Codec<ControlIDontWant> => {\n      if (_codec == null) {\n        _codec = message<ControlIDontWant>((obj, w, opts = {}) => {\n          if (opts.lengthDelimited !== false) {\n            w.fork()\n          }\n\n          if (obj.messageIDs != null) {\n            for (const value of obj.messageIDs) {\n              w.uint32(10)\n              w.bytes(value)\n            }\n          }\n\n          if (opts.lengthDelimited !== false) {\n            w.ldelim()\n          }\n        }, (reader, length, opts = {}) => {\n          const obj: any = {\n            messageIDs: []\n          }\n\n          const end = length == null ? reader.len : reader.pos + length\n\n          while (reader.pos < end) {\n            const tag = reader.uint32()\n\n            switch (tag >>> 3) {\n              case 1: {\n                if (opts.limits?.messageIDs != null && obj.messageIDs.length === opts.limits.messageIDs) {\n                  throw new MaxLengthError('Decode error - map field \"messageIDs\" had too many elements')\n                }\n\n                obj.messageIDs.push(reader.bytes())\n                break\n              }\n              default: {\n                reader.skipType(tag & 7)\n                break\n              }\n            }\n          }\n\n          return obj\n        })\n      }\n\n      return _codec\n    }\n\n    export const encode = (obj: Partial<ControlIDontWant>): Uint8Array => {\n      return encodeMessage(obj, ControlIDontWant.codec())\n    }\n\n    export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<ControlIDontWant>): ControlIDontWant => {\n      return decodeMessage(buf, ControlIDontWant.codec(), opts)\n    }\n  }\n\n  let _codec: Codec<RPC>\n\n  export const codec = (): Codec<RPC> => {\n    if (_codec == null) {\n      _codec = message<RPC>((obj, w, opts = {}) => {\n        if (opts.lengthDelimited !== false) {\n          w.fork()\n        }\n\n        if (obj.subscriptions != null) {\n          for (const value of obj.subscriptions) {\n            w.uint32(10)\n            RPC.SubOpts.codec().encode(value, w)\n          }\n        }\n\n        if (obj.messages != null) {\n          for (const value of obj.messages) {\n            w.uint32(18)\n            RPC.Message.codec().encode(value, w)\n          }\n        }\n\n        if (obj.control != null) {\n          w.uint32(26)\n          RPC.ControlMessage.codec().encode(obj.control, w)\n        }\n\n        if (opts.lengthDelimited !== false) {\n          w.ldelim()\n        }\n      }, (reader, length, opts = {}) => {\n        const obj: any = {\n          subscriptions: [],\n          messages: []\n        }\n\n        const end = length == null ? reader.len : reader.pos + length\n\n        while (reader.pos < end) {\n          const tag = reader.uint32()\n\n          switch (tag >>> 3) {\n            case 1: {\n              if (opts.limits?.subscriptions != null && obj.subscriptions.length === opts.limits.subscriptions) {\n                throw new MaxLengthError('Decode error - map field \"subscriptions\" had too many elements')\n              }\n\n              obj.subscriptions.push(RPC.SubOpts.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.subscriptions$\n              }))\n              break\n            }\n            case 2: {\n              if (opts.limits?.messages != null && obj.messages.length === opts.limits.messages) {\n                throw new MaxLengthError('Decode error - map field \"messages\" had too many elements')\n              }\n\n              obj.messages.push(RPC.Message.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.messages$\n              }))\n              break\n            }\n            case 3: {\n              obj.control = RPC.ControlMessage.codec().decode(reader, reader.uint32(), {\n                limits: opts.limits?.control\n              })\n              break\n            }\n            default: {\n              reader.skipType(tag & 7)\n              break\n            }\n          }\n        }\n\n        return obj\n      })\n    }\n\n    return _codec\n  }\n\n  export const encode = (obj: Partial<RPC>): Uint8Array => {\n    return encodeMessage(obj, RPC.codec())\n  }\n\n  export const decode = (buf: Uint8Array | Uint8ArrayList, opts?: DecodeOptions<RPC>): RPC => {\n    return decodeMessage(buf, RPC.codec(), opts)\n  }\n}\n", "import type { RPC } from './message/rpc.js'\nimport type { MessageId, MsgIdStr, PeerIdStr, TopicStr, MsgIdToStrFn } from './types.js'\n\nexport type CacheEntry = MessageId & {\n  topic: TopicStr\n}\n\nexport type MessageCacheRecord = Pick<MessageCacheEntry, 'message' | 'originatingPeers'>\n\ninterface MessageCacheEntry {\n  message: RPC.Message\n  /**\n   * Tracks if the message has been validated by the app layer and thus forwarded\n   */\n  validated: boolean\n  /**\n   * Tracks peers that sent this message before it has been validated by the app layer\n   */\n  originatingPeers: Set<PeerIdStr>\n  /**\n   * For every message and peer the number of times this peer asked for the message\n   */\n  iwantCounts: Map<PeerIdStr, number>\n}\n\nexport class MessageCache {\n  msgs = new Map<MsgIdStr, MessageCacheEntry>()\n\n  msgIdToStrFn: MsgIdToStrFn\n\n  history: CacheEntry[][] = []\n\n  /** Track with accounting of messages in the mcache that are not yet validated */\n  notValidatedCount = 0\n\n  /**\n   * Holds history of messages in timebounded history arrays\n   */\n  constructor (\n    /**\n     * The number of indices in the cache history used for gossiping. That means that a message\n     * won't get gossiped anymore when shift got called `gossip` many times after inserting the\n     * message in the cache.\n     */\n    private readonly gossip: number,\n    historyCapacity: number,\n    msgIdToStrFn: MsgIdToStrFn\n  ) {\n    this.msgIdToStrFn = msgIdToStrFn\n    for (let i = 0; i < historyCapacity; i++) {\n      this.history[i] = []\n    }\n  }\n\n  get size (): number {\n    return this.msgs.size\n  }\n\n  /**\n   * Adds a message to the current window and the cache\n   * Returns true if the message is not known and is inserted in the cache\n   */\n  put (messageId: MessageId, msg: RPC.Message, validated = false): boolean {\n    const { msgIdStr } = messageId\n    // Don't add duplicate entries to the cache.\n    if (this.msgs.has(msgIdStr)) {\n      return false\n    }\n\n    this.msgs.set(msgIdStr, {\n      message: msg,\n      validated,\n      originatingPeers: new Set(),\n      iwantCounts: new Map()\n    })\n\n    this.history[0].push({ ...messageId, topic: msg.topic })\n\n    if (!validated) {\n      this.notValidatedCount++\n    }\n\n    return true\n  }\n\n  observeDuplicate (msgId: MsgIdStr, fromPeerIdStr: PeerIdStr): void {\n    const entry = this.msgs.get(msgId)\n\n    if (\n      (entry != null) &&\n      // if the message is already validated, we don't need to store extra peers sending us\n      // duplicates as the message has already been forwarded\n      !entry.validated\n    ) {\n      entry.originatingPeers.add(fromPeerIdStr)\n    }\n  }\n\n  /**\n   * Retrieves a message from the cache by its ID, if it is still present\n   */\n  get (msgId: Uint8Array): RPC.Message | undefined {\n    return this.msgs.get(this.msgIdToStrFn(msgId))?.message\n  }\n\n  /**\n   * Increases the iwant count for the given message by one and returns the message together\n   * with the iwant if the message exists.\n   */\n  getWithIWantCount (msgIdStr: string, p: string): { msg: RPC.Message, count: number } | null {\n    const msg = this.msgs.get(msgIdStr)\n    if (msg == null) {\n      return null\n    }\n\n    const count = (msg.iwantCounts.get(p) ?? 0) + 1\n    msg.iwantCounts.set(p, count)\n\n    return { msg: msg.message, count }\n  }\n\n  /**\n   * Retrieves a list of message IDs for a set of topics\n   */\n  getGossipIDs (topics: Set<string>): Map<string, Uint8Array[]> {\n    const msgIdsByTopic = new Map<string, Uint8Array[]>()\n    for (let i = 0; i < this.gossip; i++) {\n      this.history[i].forEach((entry) => {\n        const msg = this.msgs.get(entry.msgIdStr)\n        if ((msg?.validated ?? false) && topics.has(entry.topic)) {\n          let msgIds = msgIdsByTopic.get(entry.topic)\n          if (msgIds == null) {\n            msgIds = []\n            msgIdsByTopic.set(entry.topic, msgIds)\n          }\n          msgIds.push(entry.msgId)\n        }\n      })\n    }\n\n    return msgIdsByTopic\n  }\n\n  /**\n   * Gets a message with msgId and tags it as validated.\n   * This function also returns the known peers that have sent us this message. This is used to\n   * prevent us sending redundant messages to peers who have already propagated it.\n   */\n  validate (msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (entry == null) {\n      return null\n    }\n\n    if (!entry.validated) {\n      this.notValidatedCount--\n    }\n\n    const { message, originatingPeers } = entry\n    entry.validated = true\n    // Clear the known peers list (after a message is validated, it is forwarded and we no\n    // longer need to store the originating peers).\n    entry.originatingPeers = new Set()\n    return { message, originatingPeers }\n  }\n\n  /**\n   * Shifts the current window, discarding messages older than this.history.length of the cache\n   */\n  shift (): void {\n    const lastCacheEntries = this.history[this.history.length - 1]\n    lastCacheEntries.forEach((cacheEntry) => {\n      const entry = this.msgs.get(cacheEntry.msgIdStr)\n      if (entry != null) {\n        this.msgs.delete(cacheEntry.msgIdStr)\n        if (!entry.validated) {\n          this.notValidatedCount--\n        }\n      }\n    })\n\n    this.history.pop()\n    this.history.unshift([])\n  }\n\n  remove (msgId: MsgIdStr): MessageCacheRecord | null {\n    const entry = this.msgs.get(msgId)\n    if (entry == null) {\n      return null\n    }\n\n    // Keep the message on the history vector, it will be dropped on a shift()\n    this.msgs.delete(msgId)\n    return entry\n  }\n}\n", "import { TopicValidatorResult } from './index.ts'\nimport type { Message } from './index.ts'\nimport type { RPC } from './message/rpc.js'\nimport type { PrivateKey, PeerId } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport type MsgIdStr = string\nexport type PeerIdStr = string\nexport type TopicStr = string\nexport type IPStr = string\n\nexport interface AddrInfo {\n  id: PeerId\n  addrs: Multiaddr[]\n}\n\n/**\n * Compute a local non-spec'ed msg-id for faster de-duplication of seen messages.\n * Used exclusively for a local seen_cache\n */\nexport interface FastMsgIdFn { (msg: RPC.Message): string | number }\n\n/**\n * By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n * Application could use this option to provide a more efficient function.\n */\nexport interface MsgIdToStrFn { (msgId: Uint8Array): string }\n\n/**\n * Compute spec'ed msg-id. Used for IHAVE / IWANT messages\n */\nexport interface MsgIdFn {\n  (msg: Message): Promise<Uint8Array> | Uint8Array\n}\n\nexport interface DataTransform {\n  /**\n   * Takes the data published by peers on a topic and transforms the data.\n   * Should be the reverse of outboundTransform(). Example:\n   * - `inboundTransform()`: decompress snappy payload\n   * - `outboundTransform()`: compress snappy payload\n   */\n  inboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n\n  /**\n   * Takes the data to be published (a topic and associated data) transforms the data. The\n   * transformed data will then be used to create a `RawGossipsubMessage` to be sent to peers.\n   */\n  outboundTransform(topic: TopicStr, data: Uint8Array): Uint8Array\n}\n\nexport enum SignaturePolicy {\n  /**\n   * On the producing side:\n   * - Build messages with the signature, key (from may be enough for certain inlineable public key types), from and seqno fields.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be present, reject otherwise.\n   * - Propagate only if the fields are valid and signature can be verified, reject otherwise.\n   */\n  StrictSign = 'StrictSign',\n  /**\n   * On the producing side:\n   * - Build messages without the signature, key, from and seqno fields.\n   * - The corresponding protobuf key-value pairs are absent from the marshalled message, not just empty.\n   *\n   * On the consuming side:\n   * - Enforce the fields to be absent, reject otherwise.\n   * - Propagate only if the fields are absent, reject otherwise.\n   * - A message_id function will not be able to use the above fields, and should instead rely on the data field. A commonplace strategy is to calculate a hash.\n   */\n  StrictNoSign = 'StrictNoSign'\n}\n\nexport interface PublishOpts {\n  /**\n   * Do not throw `PublishError.NoPeersSubscribedToTopic` error if there are no\n   * peers listening on the topic.\n   *\n   * N.B. if you sent this option to true, and you publish a message on a topic\n   * with no peers listening on that topic, no other network node will ever\n   * receive the message.\n   */\n  allowPublishToZeroTopicPeers?: boolean\n  ignoreDuplicatePublishError?: boolean\n  /** serialize message once and send to all peers without control messages */\n  batchPublish?: boolean\n}\n\nexport enum PublishConfigType {\n  Signing,\n  Anonymous\n}\n\nexport type PublishConfig =\n  | {\n    type: PublishConfigType.Signing\n    author: PeerId\n    key: Uint8Array\n    privateKey: PrivateKey\n  }\n  | { type: PublishConfigType.Anonymous }\n\nexport type RejectReasonObj =\n  | { reason: RejectReason.Error, error: ValidateError }\n  | { reason: Exclude<RejectReason, RejectReason.Error> }\n\nexport enum RejectReason {\n  /**\n   * The message failed the configured validation during decoding.\n   * SelfOrigin is considered a ValidationError\n   */\n  Error = 'error',\n  /**\n   * Custom validator fn reported status IGNORE.\n   */\n  Ignore = 'ignore',\n  /**\n   * Custom validator fn reported status REJECT.\n   */\n  Reject = 'reject',\n  /**\n   * The peer that sent the message OR the source from field is blacklisted.\n   * Causes messages to be ignored, not penalized, neither do score record creation.\n   */\n  Blacklisted = 'blacklisted'\n}\n\nexport enum ValidateError {\n  /// The message has an invalid signature,\n  InvalidSignature = 'invalid_signature',\n  /// The sequence number was the incorrect size\n  InvalidSeqno = 'invalid_seqno',\n  /// The PeerId was invalid\n  InvalidPeerId = 'invalid_peerid',\n  /// Signature existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SignaturePresent = 'signature_present',\n  /// Sequence number existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  SeqnoPresent = 'seqno_present',\n  /// Message source existed when validation has been sent to\n  /// [`crate::behaviour::MessageAuthenticity::Anonymous`].\n  FromPresent = 'from_present',\n  /// The data transformation failed.\n  TransformFailed = 'transform_failed'\n}\n\nexport enum MessageStatus {\n  duplicate = 'duplicate',\n  invalid = 'invalid',\n  valid = 'valid'\n}\n\n/**\n * Store both Uint8Array and string message id so that we don't have to convert data between the two.\n * See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/274\n */\nexport interface MessageId {\n  msgId: Uint8Array\n  msgIdStr: MsgIdStr\n}\n\n/**\n * Typesafe conversion of MessageAcceptance -> RejectReason. TS ensures all values covered\n */\nexport function rejectReasonFromAcceptance (\n  acceptance: Exclude<TopicValidatorResult, TopicValidatorResult.Accept>\n): RejectReason.Ignore | RejectReason.Reject {\n  switch (acceptance) {\n    case TopicValidatorResult.Ignore:\n      return RejectReason.Ignore\n    case TopicValidatorResult.Reject:\n      return RejectReason.Reject\n    default:\n      throw new Error('Unreachable')\n  }\n}\n", "import { TopicValidatorResult } from './index.ts'\nimport {\n  MessageStatus,\n\n  RejectReason\n\n} from './types.js'\nimport type { RPC } from './message/rpc.js'\nimport type { PeerScoreThresholds } from './score/peer-score-thresholds.js'\nimport type { PeerIdStr, RejectReasonObj, TopicStr, ValidateError } from './types.js'\n\n/** Topic label as provided in `topicStrToLabel` */\nexport type TopicLabel = string\nexport type TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport enum MessageSource {\n  forward = 'forward',\n  publish = 'publish'\n}\n\ntype NoLabels = Record<string, never>\ntype LabelsGeneric = Record<string, string | number>\ntype LabelKeys<Labels extends LabelsGeneric> = Extract<keyof Labels, string>\ninterface CollectFn<Labels extends LabelsGeneric> { (metric: Gauge<Labels>): void }\n\nexport interface Gauge<Labels extends LabelsGeneric = NoLabels> {\n  inc: NoLabels extends Labels ? (value?: number) => void : (labels: Labels, value?: number) => void\n  set: NoLabels extends Labels ? (value: number) => void : (labels: Labels, value: number) => void\n\n  addCollect(collectFn: CollectFn<Labels>): void\n}\n\nexport interface Histogram<Labels extends LabelsGeneric = NoLabels> {\n  startTimer(): () => void\n\n  observe: NoLabels extends Labels ? (value: number) => void : (labels: Labels, value: number) => void\n\n  reset(): void\n}\n\nexport interface AvgMinMax<Labels extends LabelsGeneric = NoLabels> {\n  set: NoLabels extends Labels ? (values: number[]) => void : (labels: Labels, values: number[]) => void\n}\n\nexport type GaugeConfig<Labels extends LabelsGeneric> = {\n  name: string\n  help: string\n} & (NoLabels extends Labels ? { labelNames?: never } : { labelNames: [LabelKeys<Labels>, ...Array<LabelKeys<Labels>>] })\n\nexport type HistogramConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels> & {\n  buckets?: number[]\n}\n\nexport type AvgMinMaxConfig<Labels extends LabelsGeneric> = GaugeConfig<Labels>\n\nexport interface MetricsRegister {\n  gauge<Labels extends LabelsGeneric = NoLabels>(config: GaugeConfig<Labels>): Gauge<Labels>\n  histogram<Labels extends LabelsGeneric = NoLabels>(config: HistogramConfig<Labels>): Histogram<Labels>\n  avgMinMax<Labels extends LabelsGeneric = NoLabels>(config: AvgMinMaxConfig<Labels>): AvgMinMax<Labels>\n}\n\nexport enum InclusionReason {\n  /** Peer was a fanaout peer. */\n  Fanout = 'fanout',\n  /** Included from random selection. */\n  Random = 'random',\n  /** Peer subscribed. */\n  Subscribed = 'subscribed',\n  /** On heartbeat, peer was included to fill the outbound quota. */\n  Outbound = 'outbound',\n  /** On heartbeat, not enough peers in mesh */\n  NotEnough = 'not_enough',\n  /** On heartbeat opportunistic grafting due to low mesh score */\n  Opportunistic = 'opportunistic'\n}\n\n/// Reasons why a peer was removed from the mesh.\nexport enum ChurnReason {\n  /// Peer disconnected.\n  Dc = 'disconnected',\n  /// Peer had a bad score.\n  BadScore = 'bad_score',\n  /// Peer sent a PRUNE.\n  Prune = 'prune',\n  /// Too many peers.\n  Excess = 'excess'\n}\n\n/// Kinds of reasons a peer's score has been penalized\nexport enum ScorePenalty {\n  /// A peer grafted before waiting the back-off time.\n  GraftBackoff = 'graft_backoff',\n  /// A Peer did not respond to an IWANT request in time.\n  BrokenPromise = 'broken_promise',\n  /// A Peer did not send enough messages as expected.\n  MessageDeficit = 'message_deficit',\n  /// Too many peers under one IP address.\n  IPColocation = 'IP_colocation'\n}\n\nexport enum IHaveIgnoreReason {\n  LowScore = 'low_score',\n  MaxIhave = 'max_ihave',\n  MaxIasked = 'max_iasked'\n}\n\nexport enum ScoreThreshold {\n  graylist = 'graylist',\n  publish = 'publish',\n  gossip = 'gossip',\n  mesh = 'mesh'\n}\n\nexport type PeersByScoreThreshold = Record<ScoreThreshold, number>\n\nexport interface ToSendGroupCount {\n  direct: number\n  floodsub: number\n  mesh: number\n  fanout: number\n}\n\nexport interface ToAddGroupCount {\n  fanout: number\n  random: number\n}\n\nexport type PromiseDeliveredStats =\n  | { expired: false, requestedCount: number, maxDeliverMs: number }\n  | { expired: true, maxDeliverMs: number }\n\nexport interface TopicScoreWeights<T> { p1w: T, p2w: T, p3w: T, p3bw: T, p4w: T }\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport type Metrics = ReturnType<typeof getMetrics>\n\n/**\n * A collection of metrics used throughout the Gossipsub behaviour.\n * NOTE: except for special reasons, do not add more than 1 label for frequent metrics,\n * there's a performance penalty as of June 2023.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-function-return-type\nexport function getMetrics (\n  register: MetricsRegister,\n  topicStrToLabel: TopicStrToLabel,\n  opts: { gossipPromiseExpireSec: number, behaviourPenaltyThreshold: number, maxMeshMessageDeliveriesWindowSec: number }\n) {\n  // Using function style instead of class to prevent having to re-declare all MetricsPrometheus types.\n\n  return {\n    /* Metrics for static config */\n    protocolsEnabled: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_protocol',\n      help: 'Status of enabled protocols',\n      labelNames: ['protocol']\n    }),\n\n    /* Metrics per known topic */\n    /**\n     * Status of our subscription to this topic. This metric allows analyzing other topic metrics\n     * filtered by our current subscription status.\n     * = rust-libp2p `topic_subscription_status`\n     */\n    topicSubscriptionStatus: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_subscription_status',\n      help: 'Status of our subscription to this topic',\n      labelNames: ['topicStr']\n    }),\n    /**\n     * Number of peers subscribed to each topic. This allows us to analyze a topic's behaviour\n     * regardless of our subscription status.\n     */\n    topicPeersCount: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_topic_peer_count',\n      help: 'Number of peers subscribed to each topic',\n      labelNames: ['topicStr']\n    }),\n\n    /* Metrics regarding mesh state */\n    /**\n     * Number of peers in our mesh. This metric should be updated with the count of peers for a\n     * topic in the mesh regardless of inclusion and churn events.\n     * = rust-libp2p `mesh_peer_counts`\n     */\n    meshPeerCounts: register.gauge<{ topicStr: TopicStr }>({\n      name: 'gossipsub_mesh_peer_count',\n      help: 'Number of peers in our mesh',\n      labelNames: ['topicStr']\n    }),\n    /**\n     * Number of times we include peers in a topic mesh for different reasons.\n     * = rust-libp2p `mesh_peer_inclusion_events`\n     */\n    meshPeerInclusionEventsFanout: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_fanout_total',\n      help: 'Number of times we include peers in a topic mesh for fanout reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsRandom: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_random_total',\n      help: 'Number of times we include peers in a topic mesh for random reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsSubscribed: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_subscribed_total',\n      help: 'Number of times we include peers in a topic mesh for subscribed reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOutbound: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_outbound_total',\n      help: 'Number of times we include peers in a topic mesh for outbound reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsNotEnough: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_not_enough_total',\n      help: 'Number of times we include peers in a topic mesh for not_enough reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsOpportunistic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_opportunistic_total',\n      help: 'Number of times we include peers in a topic mesh for opportunistic reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerInclusionEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peer_inclusion_events_unknown_total',\n      help: 'Number of times we include peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n    /**\n     * Number of times we remove peers in a topic mesh for different reasons.\n     * = rust-libp2p `mesh_peer_churn_events`\n     */\n    meshPeerChurnEventsDisconnected: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_disconnected_total',\n      help: 'Number of times we remove peers in a topic mesh for disconnected reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsBadScore: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_bad_score_total',\n      help: 'Number of times we remove peers in a topic mesh for bad_score reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsPrune: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_prune_total',\n      help: 'Number of times we remove peers in a topic mesh for prune reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsExcess: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_excess_total',\n      help: 'Number of times we remove peers in a topic mesh for excess reasons',\n      labelNames: ['topic']\n    }),\n    meshPeerChurnEventsUnknown: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_peer_churn_events_unknown_total',\n      help: 'Number of times we remove peers in a topic mesh for unknown reasons',\n      labelNames: ['topic']\n    }),\n\n    /* General Metrics */\n    /**\n     * Gossipsub supports floodsub, gossipsub v1.0, v1.1, and v1.2. Peers are classified based\n     * on which protocol they support. This metric keeps track of the number of peers that are\n     * connected of each type.\n     */\n    peersPerProtocol: register.gauge<{ protocol: string }>({\n      name: 'gossipsub_peers_per_protocol_count',\n      help: 'Peers connected for each topic',\n      labelNames: ['protocol']\n    }),\n    /** The time it takes to complete one iteration of the heartbeat. */\n    heartbeatDuration: register.histogram({\n      name: 'gossipsub_heartbeat_duration_seconds',\n      help: 'The time it takes to complete one iteration of the heartbeat',\n      // Should take <10ms, over 1s it's a huge issue that needs debugging, since a heartbeat will be cancelled\n      buckets: [0.01, 0.1, 1]\n    }),\n    /** Heartbeat run took longer than heartbeat interval so next is skipped */\n    heartbeatSkipped: register.gauge({\n      name: 'gossipsub_heartbeat_skipped',\n      help: 'Heartbeat run took longer than heartbeat interval so next is skipped'\n    }),\n\n    /**\n     * Message validation results for each topic.\n     * Invalid == Reject?\n     * = rust-libp2p `invalid_messages`, `accepted_messages`, `ignored_messages`, `rejected_messages`\n     */\n    acceptedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_accepted_messages_total',\n      help: 'Total accepted messages for each topic',\n      labelNames: ['topic']\n    }),\n    ignoredMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ignored_messages_total',\n      help: 'Total ignored messages for each topic',\n      labelNames: ['topic']\n    }),\n    rejectedMessagesTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_rejected_messages_total',\n      help: 'Total rejected messages for each topic',\n      labelNames: ['topic']\n    }),\n    unknownValidationResultsTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_unknown_validation_results_total',\n      help: 'Total unknown validation results for each topic',\n      labelNames: ['topic']\n    }),\n    /**\n     * When the user validates a message, it tries to re propagate it to its mesh peers. If the\n     * message expires from the memcache before it can be validated, we count this a cache miss\n     * and it is an indicator that the memcache size should be increased.\n     * = rust-libp2p `mcache_misses`\n     */\n    asyncValidationMcacheHit: register.gauge<{ hit: 'hit' | 'miss' }>({\n      name: 'gossipsub_async_validation_mcache_hit_total',\n      help: 'Async validation result reported by the user layer',\n      labelNames: ['hit']\n    }),\n\n    asyncValidationDelayFromFirstSeenSec: register.histogram({\n      name: 'gossipsub_async_validation_delay_from_first_seen',\n      help: 'Async validation report delay from first seen in second',\n      buckets: [0.01, 0.03, 0.1, 0.3, 1, 3, 10]\n    }),\n\n    asyncValidationUnknownFirstSeen: register.gauge({\n      name: 'gossipsub_async_validation_unknown_first_seen_count_total',\n      help: 'Async validation report unknown first seen value for message'\n    }),\n\n    // peer stream\n    peerReadStreamError: register.gauge({\n      name: 'gossipsub_peer_read_stream_err_count_total',\n      help: 'Peer read stream error'\n    }),\n\n    // RPC outgoing. Track byte length + data structure sizes\n    rpcRecvBytes: register.gauge({ name: 'gossipsub_rpc_recv_bytes_total', help: 'RPC recv' }),\n    rpcRecvCount: register.gauge({ name: 'gossipsub_rpc_recv_count_total', help: 'RPC recv' }),\n    rpcRecvSubscription: register.gauge({ name: 'gossipsub_rpc_recv_subscription_total', help: 'RPC recv' }),\n    rpcRecvMessage: register.gauge({ name: 'gossipsub_rpc_recv_message_total', help: 'RPC recv' }),\n    rpcRecvControl: register.gauge({ name: 'gossipsub_rpc_recv_control_total', help: 'RPC recv' }),\n    rpcRecvIHave: register.gauge({ name: 'gossipsub_rpc_recv_ihave_total', help: 'RPC recv' }),\n    rpcRecvIWant: register.gauge({ name: 'gossipsub_rpc_recv_iwant_total', help: 'RPC recv' }),\n    rpcRecvGraft: register.gauge({ name: 'gossipsub_rpc_recv_graft_total', help: 'RPC recv' }),\n    rpcRecvPrune: register.gauge({ name: 'gossipsub_rpc_recv_prune_total', help: 'RPC recv' }),\n    rpcDataError: register.gauge({ name: 'gossipsub_rpc_data_err_count_total', help: 'RPC data error' }),\n    rpcRecvError: register.gauge({ name: 'gossipsub_rpc_recv_err_count_total', help: 'RPC recv error' }),\n\n    /** Total count of RPC dropped because acceptFrom() == false */\n    rpcRecvNotAccepted: register.gauge({\n      name: 'gossipsub_rpc_rcv_not_accepted_total',\n      help: 'Total count of RPC dropped because acceptFrom() == false'\n    }),\n\n    // RPC incoming. Track byte length + data structure sizes\n    rpcSentBytes: register.gauge({ name: 'gossipsub_rpc_sent_bytes_total', help: 'RPC sent' }),\n    rpcSentCount: register.gauge({ name: 'gossipsub_rpc_sent_count_total', help: 'RPC sent' }),\n    rpcSentSubscription: register.gauge({ name: 'gossipsub_rpc_sent_subscription_total', help: 'RPC sent' }),\n    rpcSentMessage: register.gauge({ name: 'gossipsub_rpc_sent_message_total', help: 'RPC sent' }),\n    rpcSentControl: register.gauge({ name: 'gossipsub_rpc_sent_control_total', help: 'RPC sent' }),\n    rpcSentIHave: register.gauge({ name: 'gossipsub_rpc_sent_ihave_total', help: 'RPC sent' }),\n    rpcSentIWant: register.gauge({ name: 'gossipsub_rpc_sent_iwant_total', help: 'RPC sent' }),\n    rpcSentGraft: register.gauge({ name: 'gossipsub_rpc_sent_graft_total', help: 'RPC sent' }),\n    rpcSentPrune: register.gauge({ name: 'gossipsub_rpc_sent_prune_total', help: 'RPC sent' }),\n    rpcSentIDontWant: register.gauge({ name: 'gossipsub_rpc_sent_idontwant_total', help: 'RPC sent' }),\n\n    // publish message. Track peers sent to and bytes\n    /** Total count of msg published by topic */\n    msgPublishCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_count_total',\n      help: 'Total count of msg published by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we publish a msg to */\n    msgPublishPeersByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_peers_total',\n      help: 'Total count of peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers (by group) that we publish a msg to */\n    directPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_direct_peers_published_total',\n      help: 'Total direct peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    floodsubPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_floodsub_peers_published_total',\n      help: 'Total floodsub peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    meshPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_mesh_peers_published_total',\n      help: 'Total mesh peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    fanoutPeersPublishedTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_fanout_peers_published_total',\n      help: 'Total fanout peers that we publish a msg to',\n      labelNames: ['topic']\n    }),\n    /** Total count of msg publish data.length bytes */\n    msgPublishBytes: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_bytes_total',\n      help: 'Total count of msg publish data.length bytes',\n      labelNames: ['topic']\n    }),\n    /** Total time in seconds to publish a message */\n    msgPublishTime: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_publish_seconds',\n      help: 'Total time in seconds to publish a message',\n      buckets: [0.001, 0.002, 0.005, 0.01, 0.1, 0.5, 1],\n      labelNames: ['topic']\n    }),\n\n    /** Total count of msg forwarded by topic */\n    msgForwardCount: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_count_total',\n      help: 'Total count of msg forwarded by topic',\n      labelNames: ['topic']\n    }),\n    /** Total count of peers that we forward a msg to */\n    msgForwardPeers: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_forward_peers_total',\n      help: 'Total count of peers that we forward a msg to',\n      labelNames: ['topic']\n    }),\n\n    /** Total count of recv msgs before any validation */\n    msgReceivedPreValidation: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_prevalidation_total',\n      help: 'Total count of recv msgs before any validation',\n      labelNames: ['topic']\n    }),\n    /** Total count of recv msgs error */\n    msgReceivedError: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_error_total',\n      help: 'Total count of recv msgs error',\n      labelNames: ['topic']\n    }),\n    /** Tracks distribution of recv msgs by duplicate, invalid, valid */\n    prevalidationInvalidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_invalid_total',\n      help: 'Total count of invalid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationValidTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_valid_total',\n      help: 'Total count of valid messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationDuplicateTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_duplicate_total',\n      help: 'Total count of duplicate messages received',\n      labelNames: ['topic']\n    }),\n    prevalidationUnknownTotal: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_pre_validation_unknown_status_total',\n      help: 'Total count of unknown_status messages received',\n      labelNames: ['topic']\n    }),\n    /** Tracks specific reason of invalid */\n    msgReceivedInvalid: register.gauge<{ error: RejectReason | ValidateError }>({\n      name: 'gossipsub_msg_received_invalid_total',\n      help: 'Tracks specific reason of invalid',\n      labelNames: ['error']\n    }),\n    msgReceivedInvalidByTopic: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_msg_received_invalid_by_topic_total',\n      help: 'Tracks specific invalid message by topic',\n      labelNames: ['topic']\n    }),\n    /** Track duplicate message delivery time */\n    duplicateMsgDeliveryDelay: register.histogram<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_delivery_delay_seconds',\n      help: 'Time since the 1st duplicated message validated',\n      labelNames: ['topic'],\n      buckets: [\n        0.25 * opts.maxMeshMessageDeliveriesWindowSec,\n        0.5 * opts.maxMeshMessageDeliveriesWindowSec,\n        Number(opts.maxMeshMessageDeliveriesWindowSec),\n        2 * opts.maxMeshMessageDeliveriesWindowSec,\n        4 * opts.maxMeshMessageDeliveriesWindowSec\n      ]\n    }),\n    /** Total count of late msg delivery total by topic */\n    duplicateMsgLateDelivery: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_duplicate_msg_late_delivery_total',\n      help: 'Total count of late duplicate message delivery by topic, which triggers P3 penalty',\n      labelNames: ['topic']\n    }),\n\n    duplicateMsgIgnored: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossisub_ignored_published_duplicate_msgs_total',\n      help: 'Total count of published duplicate message ignored by topic',\n      labelNames: ['topic']\n    }),\n\n    /* Metrics related to scoring */\n    /** Total times score() is called */\n    scoreFnCalls: register.gauge({\n      name: 'gossipsub_score_fn_calls_total',\n      help: 'Total times score() is called'\n    }),\n    /** Total times score() call actually computed computeScore(), no cache */\n    scoreFnRuns: register.gauge({\n      name: 'gossipsub_score_fn_runs_total',\n      help: 'Total times score() call actually computed computeScore(), no cache'\n    }),\n    scoreCachedDelta: register.histogram({\n      name: 'gossipsub_score_cache_delta',\n      help: 'Delta of score between cached values that expired',\n      buckets: [10, 100, 1000]\n    }),\n    /** Current count of peers by score threshold */\n    peersByScoreThreshold: register.gauge<{ threshold: ScoreThreshold }>({\n      name: 'gossipsub_peers_by_score_threshold_count',\n      help: 'Current count of peers by score threshold',\n      labelNames: ['threshold']\n    }),\n    score: register.avgMinMax({\n      name: 'gossipsub_score',\n      help: 'Avg min max of gossip scores'\n    }),\n    /**\n     * Separate score weights\n     * Need to use 2-label metrics in this case to debug the score weights\n     */\n    scoreWeights: register.avgMinMax<{ topic?: TopicLabel, p: string }>({\n      name: 'gossipsub_score_weights',\n      help: 'Separate score weights',\n      labelNames: ['topic', 'p']\n    }),\n    /** Histogram of the scores for each mesh topic. */\n    // TODO: Not implemented\n    scorePerMesh: register.avgMinMax<{ topic: TopicLabel }>({\n      name: 'gossipsub_score_per_mesh',\n      help: 'Histogram of the scores for each mesh topic',\n      labelNames: ['topic']\n    }),\n    /** A counter of the kind of penalties being applied to peers. */\n    // TODO: Not fully implemented\n    scoringPenalties: register.gauge<{ penalty: ScorePenalty }>({\n      name: 'gossipsub_scoring_penalties_total',\n      help: 'A counter of the kind of penalties being applied to peers',\n      labelNames: ['penalty']\n    }),\n    behaviourPenalty: register.histogram({\n      name: 'gossipsub_peer_stat_behaviour_penalty',\n      help: 'Current peer stat behaviour_penalty at each scrape',\n      buckets: [\n        0.25 * opts.behaviourPenaltyThreshold,\n        0.5 * opts.behaviourPenaltyThreshold,\n        Number(opts.behaviourPenaltyThreshold),\n        2 * opts.behaviourPenaltyThreshold,\n        4 * opts.behaviourPenaltyThreshold\n      ]\n    }),\n\n    // TODO:\n    // - iasked per peer (on heartbeat)\n    // - when promise is resolved, track messages from promises\n\n    /** Total received IHAVE messages that we ignore for some reason */\n    ihaveRcvIgnored: register.gauge<{ reason: IHaveIgnoreReason }>({\n      name: 'gossipsub_ihave_rcv_ignored_total',\n      help: 'Total received IHAVE messages that we ignore for some reason',\n      labelNames: ['reason']\n    }),\n    /** Total received IHAVE messages by topic */\n    ihaveRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_msgids_total',\n      help: 'Total received IHAVE messages by topic',\n      labelNames: ['topic']\n    }),\n    /**\n     * Total messages per topic we don't have. Not actual requests.\n     * The number of times we have decided that an IWANT control message is required for this\n     * topic. A very high metric might indicate an underperforming network.\n     * = rust-libp2p `topic_iwant_msgs`\n     */\n    ihaveRcvNotSeenMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_ihave_rcv_not_seen_msgids_total',\n      help: 'Total messages per topic we do not have, not actual requests',\n      labelNames: ['topic']\n    }),\n\n    /** Total received IWANT messages by topic */\n    iwantRcvMsgids: register.gauge<{ topic: TopicLabel }>({\n      name: 'gossipsub_iwant_rcv_msgids_total',\n      help: 'Total received IWANT messages by topic',\n      labelNames: ['topic']\n    }),\n    /** Total requested messageIDs that we don't have */\n    iwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_iwant_rcv_dont_have_msgids_total',\n      help: 'Total requested messageIDs that we do not have'\n    }),\n    /** Total received IDONTWANT messages */\n    idontwantRcvMsgids: register.gauge({\n      name: 'gossipsub_idontwant_rcv_msgids_total',\n      help: 'Total received IDONTWANT messages'\n    }),\n    /** Total received IDONTWANT messageIDs that we don't have */\n    idontwantRcvDonthaveMsgids: register.gauge({\n      name: 'gossipsub_idontwant_rcv_dont_have_msgids_total',\n      help: 'Total received IDONTWANT messageIDs that we do not have in mcache'\n    }),\n    iwantPromiseStarted: register.gauge({\n      name: 'gossipsub_iwant_promise_sent_total',\n      help: 'Total count of started IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises */\n    iwantPromiseResolved: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_total',\n      help: 'Total count of resolved IWANT promises'\n    }),\n    /** Total count of resolved IWANT promises from duplicate messages */\n    iwantPromiseResolvedFromDuplicate: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_from_duplicate_total',\n      help: 'Total count of resolved IWANT promises from duplicate messages'\n    }),\n    /** Total count of peers we have asked IWANT promises that are resolved */\n    iwantPromiseResolvedPeers: register.gauge({\n      name: 'gossipsub_iwant_promise_resolved_peers',\n      help: 'Total count of peers we have asked IWANT promises that are resolved'\n    }),\n    iwantPromiseBroken: register.gauge({\n      name: 'gossipsub_iwant_promise_broken',\n      help: 'Total count of broken IWANT promises'\n    }),\n    iwantMessagePruned: register.gauge({\n      name: 'gossipsub_iwant_message_pruned',\n      help: 'Total count of pruned IWANT messages'\n    }),\n    /** Histogram of delivery time of resolved IWANT promises */\n    iwantPromiseDeliveryTime: register.histogram({\n      name: 'gossipsub_iwant_promise_delivery_seconds',\n      help: 'Histogram of delivery time of resolved IWANT promises',\n      buckets: [\n        0.5 * opts.gossipPromiseExpireSec,\n        Number(opts.gossipPromiseExpireSec),\n        2 * opts.gossipPromiseExpireSec,\n        4 * opts.gossipPromiseExpireSec\n      ]\n    }),\n    iwantPromiseUntracked: register.gauge({\n      name: 'gossip_iwant_promise_untracked',\n      help: 'Total count of untracked IWANT promise'\n    }),\n    /** Backoff time */\n    connectedPeersBackoffSec: register.histogram({\n      name: 'gossipsub_connected_peers_backoff_seconds',\n      help: 'Backoff time in seconds',\n      // Using 1 seconds as minimum as that's close to the heartbeat duration, no need for more resolution.\n      // As per spec, backoff times are 10 seconds for UnsubscribeBackoff and 60 seconds for PruneBackoff.\n      // Higher values of 60 seconds should not occur, but we add 120 seconds just in case\n      // https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.1.md#overview-of-new-parameters\n      buckets: [1, 2, 4, 10, 20, 60, 120]\n    }),\n\n    /* Data structure sizes */\n    /** Unbounded cache sizes */\n    cacheSize: register.gauge<{ cache: string }>({\n      name: 'gossipsub_cache_size',\n      help: 'Unbounded cache sizes',\n      labelNames: ['cache']\n    }),\n    /** Current mcache msg count */\n    mcacheSize: register.gauge({\n      name: 'gossipsub_mcache_size',\n      help: 'Current mcache msg count'\n    }),\n    mcacheNotValidatedCount: register.gauge({\n      name: 'gossipsub_mcache_not_validated_count',\n      help: 'Current mcache msg count not validated'\n    }),\n\n    fastMsgIdCacheCollision: register.gauge({\n      name: 'gossipsub_fastmsgid_cache_collision_total',\n      help: 'Total count of key collisions on fastmsgid cache put'\n    }),\n\n    newConnectionCount: register.gauge<{ status: string }>({\n      name: 'gossipsub_new_connection_total',\n      help: 'Total new connection by status',\n      labelNames: ['status']\n    }),\n\n    topicStrToLabel,\n\n    toTopic (topicStr: TopicStr): TopicLabel {\n      return this.topicStrToLabel.get(topicStr) ?? topicStr\n    },\n\n    /** We joined a topic */\n    onJoin (topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 1)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** We left a topic */\n    onLeave (topicStr: TopicStr): void {\n      this.topicSubscriptionStatus.set({ topicStr }, 0)\n      this.meshPeerCounts.set({ topicStr }, 0) // Reset count\n    },\n\n    /** Register the inclusion of peers in our mesh due to some reason. */\n    onAddToMesh (topicStr: TopicStr, reason: InclusionReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case InclusionReason.Fanout:\n          this.meshPeerInclusionEventsFanout.inc({ topic }, count)\n          break\n        case InclusionReason.Random:\n          this.meshPeerInclusionEventsRandom.inc({ topic }, count)\n          break\n        case InclusionReason.Subscribed:\n          this.meshPeerInclusionEventsSubscribed.inc({ topic }, count)\n          break\n        case InclusionReason.Outbound:\n          this.meshPeerInclusionEventsOutbound.inc({ topic }, count)\n          break\n        case InclusionReason.NotEnough:\n          this.meshPeerInclusionEventsNotEnough.inc({ topic }, count)\n          break\n        case InclusionReason.Opportunistic:\n          this.meshPeerInclusionEventsOpportunistic.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerInclusionEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /** Register the removal of peers in our mesh due to some reason */\n    // - remove_peer_from_mesh()\n    // - heartbeat() Churn::BadScore\n    // - heartbeat() Churn::Excess\n    // - on_disconnect() Churn::Ds\n    onRemoveFromMesh (topicStr: TopicStr, reason: ChurnReason, count: number): void {\n      const topic = this.toTopic(topicStr)\n      switch (reason) {\n        case ChurnReason.Dc:\n          this.meshPeerChurnEventsDisconnected.inc({ topic }, count)\n          break\n        case ChurnReason.BadScore:\n          this.meshPeerChurnEventsBadScore.inc({ topic }, count)\n          break\n        case ChurnReason.Prune:\n          this.meshPeerChurnEventsPrune.inc({ topic }, count)\n          break\n        case ChurnReason.Excess:\n          this.meshPeerChurnEventsExcess.inc({ topic }, count)\n          break\n        default:\n          this.meshPeerChurnEventsUnknown.inc({ topic }, count)\n          break\n      }\n    },\n\n    /**\n     * Update validation result to metrics\n     *\n     * @param messageRecord - null means the message's mcache record was not known at the time of acceptance report\n     */\n    onReportValidation (\n      messageRecord: { message: { topic: TopicStr } } | null,\n      acceptance: TopicValidatorResult,\n      firstSeenTimestampMs: number | null\n    ): void {\n      this.asyncValidationMcacheHit.inc({ hit: messageRecord != null ? 'hit' : 'miss' })\n\n      if (messageRecord != null) {\n        const topic = this.toTopic(messageRecord.message.topic)\n        switch (acceptance) {\n          case TopicValidatorResult.Accept:\n            this.acceptedMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Ignore:\n            this.ignoredMessagesTotal.inc({ topic })\n            break\n          case TopicValidatorResult.Reject:\n            this.rejectedMessagesTotal.inc({ topic })\n            break\n          default:\n            this.unknownValidationResultsTotal.inc({ topic })\n            break\n        }\n      }\n\n      if (firstSeenTimestampMs != null) {\n        this.asyncValidationDelayFromFirstSeenSec.observe((Date.now() - firstSeenTimestampMs) / 1000)\n      } else {\n        this.asyncValidationUnknownFirstSeen.inc()\n      }\n    },\n\n    /**\n     * - in handle_graft() Penalty::GraftBackoff\n     * - in apply_iwant_penalties() Penalty::BrokenPromise\n     * - in metric_score() P3 Penalty::MessageDeficit\n     * - in metric_score() P6 Penalty::IPColocation\n     */\n    onScorePenalty (penalty: ScorePenalty): void {\n      // Can this be labeled by topic too?\n      this.scoringPenalties.inc({ penalty }, 1)\n    },\n\n    onIhaveRcv (topicStr: TopicStr, ihave: number, idonthave: number): void {\n      const topic = this.toTopic(topicStr)\n      this.ihaveRcvMsgids.inc({ topic }, ihave)\n      this.ihaveRcvNotSeenMsgids.inc({ topic }, idonthave)\n    },\n\n    onIwantRcv (iwantByTopic: Map<TopicStr, number>, iwantDonthave: number): void {\n      for (const [topicStr, iwant] of iwantByTopic) {\n        const topic = this.toTopic(topicStr)\n        this.iwantRcvMsgids.inc({ topic }, iwant)\n      }\n\n      this.iwantRcvDonthaveMsgids.inc(iwantDonthave)\n    },\n\n    onIdontwantRcv (idontwant: number, idontwantDonthave: number): void {\n      this.idontwantRcvMsgids.inc(idontwant)\n      this.idontwantRcvDonthaveMsgids.inc(idontwantDonthave)\n    },\n\n    onForwardMsg (topicStr: TopicStr, tosendCount: number): void {\n      const topic = this.toTopic(topicStr)\n      this.msgForwardCount.inc({ topic }, 1)\n      this.msgForwardPeers.inc({ topic }, tosendCount)\n    },\n\n    onPublishMsg (\n      topicStr: TopicStr,\n      tosendGroupCount: ToSendGroupCount,\n      tosendCount: number,\n      dataLen: number,\n      ms: number\n    ): void {\n      const topic = this.toTopic(topicStr)\n      this.msgPublishCount.inc({ topic }, 1)\n      this.msgPublishBytes.inc({ topic }, tosendCount * dataLen)\n      this.msgPublishPeersByTopic.inc({ topic }, tosendCount)\n      this.directPeersPublishedTotal.inc({ topic }, tosendGroupCount.direct)\n      this.floodsubPeersPublishedTotal.inc({ topic }, tosendGroupCount.floodsub)\n      this.meshPeersPublishedTotal.inc({ topic }, tosendGroupCount.mesh)\n      this.fanoutPeersPublishedTotal.inc({ topic }, tosendGroupCount.fanout)\n      this.msgPublishTime.observe({ topic }, ms / 1000)\n    },\n\n    onMsgRecvPreValidation (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedPreValidation.inc({ topic }, 1)\n    },\n\n    onMsgRecvError (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.msgReceivedError.inc({ topic }, 1)\n    },\n\n    onPrevalidationResult (topicStr: TopicStr, status: MessageStatus): void {\n      const topic = this.toTopic(topicStr)\n      switch (status) {\n        case MessageStatus.duplicate:\n          this.prevalidationDuplicateTotal.inc({ topic })\n          break\n        case MessageStatus.invalid:\n          this.prevalidationInvalidTotal.inc({ topic })\n          break\n        case MessageStatus.valid:\n          this.prevalidationValidTotal.inc({ topic })\n          break\n        default:\n          this.prevalidationUnknownTotal.inc({ topic })\n          break\n      }\n    },\n\n    onMsgRecvInvalid (topicStr: TopicStr, reason: RejectReasonObj): void {\n      const topic = this.toTopic(topicStr)\n\n      const error = reason.reason === RejectReason.Error ? reason.error : reason.reason\n      this.msgReceivedInvalid.inc({ error }, 1)\n      this.msgReceivedInvalidByTopic.inc({ topic }, 1)\n    },\n\n    onDuplicateMsgDelivery (topicStr: TopicStr, deliveryDelayMs: number, isLateDelivery: boolean): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgDeliveryDelay.observe({ topic }, deliveryDelayMs / 1000)\n      if (isLateDelivery) {\n        this.duplicateMsgLateDelivery.inc({ topic }, 1)\n      }\n    },\n\n    onPublishDuplicateMsg (topicStr: TopicStr): void {\n      const topic = this.toTopic(topicStr)\n      this.duplicateMsgIgnored.inc({ topic }, 1)\n    },\n\n    onPeerReadStreamError (): void {\n      this.peerReadStreamError.inc(1)\n    },\n\n    onRpcRecvError (): void {\n      this.rpcRecvError.inc(1)\n    },\n\n    onRpcDataError (): void {\n      this.rpcDataError.inc(1)\n    },\n\n    onRpcRecv (rpc: RPC, rpcBytes: number): void {\n      this.rpcRecvBytes.inc(rpcBytes)\n      this.rpcRecvCount.inc(1)\n      if (rpc.subscriptions != null) { this.rpcRecvSubscription.inc(rpc.subscriptions.length) }\n      if (rpc.messages != null) { this.rpcRecvMessage.inc(rpc.messages.length) }\n      if (rpc.control != null) {\n        this.rpcRecvControl.inc(1)\n        if (rpc.control.ihave != null) { this.rpcRecvIHave.inc(rpc.control.ihave.length) }\n        if (rpc.control.iwant != null) { this.rpcRecvIWant.inc(rpc.control.iwant.length) }\n        if (rpc.control.graft != null) { this.rpcRecvGraft.inc(rpc.control.graft.length) }\n        if (rpc.control.prune != null) { this.rpcRecvPrune.inc(rpc.control.prune.length) }\n      }\n    },\n\n    onRpcSent (rpc: RPC, rpcBytes: number): void {\n      this.rpcSentBytes.inc(rpcBytes)\n      this.rpcSentCount.inc(1)\n      if (rpc.subscriptions != null) { this.rpcSentSubscription.inc(rpc.subscriptions.length) }\n      if (rpc.messages != null) { this.rpcSentMessage.inc(rpc.messages.length) }\n      if (rpc.control != null) {\n        const ihave = rpc.control.ihave?.length ?? 0\n        const iwant = rpc.control.iwant?.length ?? 0\n        const graft = rpc.control.graft?.length ?? 0\n        const prune = rpc.control.prune?.length ?? 0\n        const idontwant = rpc.control.idontwant?.length ?? 0\n        if (ihave > 0) { this.rpcSentIHave.inc(ihave) }\n        if (iwant > 0) { this.rpcSentIWant.inc(iwant) }\n        if (graft > 0) { this.rpcSentGraft.inc(graft) }\n        if (prune > 0) { this.rpcSentPrune.inc(prune) }\n        if (idontwant > 0) { this.rpcSentIDontWant.inc(idontwant) }\n        if (ihave > 0 || iwant > 0 || graft > 0 || prune > 0 || idontwant > 0) { this.rpcSentControl.inc(1) }\n      }\n    },\n\n    registerScores (scores: number[], scoreThresholds: PeerScoreThresholds): void {\n      let graylist = 0\n      let publish = 0\n      let gossip = 0\n      let mesh = 0\n\n      for (const score of scores) {\n        if (score >= scoreThresholds.graylistThreshold) { graylist++ }\n        if (score >= scoreThresholds.publishThreshold) { publish++ }\n        if (score >= scoreThresholds.gossipThreshold) { gossip++ }\n        if (score >= 0) { mesh++ }\n      }\n\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.graylist }, graylist)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.publish }, publish)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.gossip }, gossip)\n      this.peersByScoreThreshold.set({ threshold: ScoreThreshold.mesh }, mesh)\n\n      // Register full score too\n      this.score.set(scores)\n    },\n\n    registerScoreWeights (sw: ScoreWeights<number[]>): void {\n      for (const [topic, wsTopic] of sw.byTopic) {\n        this.scoreWeights.set({ topic, p: 'p1' }, wsTopic.p1w)\n        this.scoreWeights.set({ topic, p: 'p2' }, wsTopic.p2w)\n        this.scoreWeights.set({ topic, p: 'p3' }, wsTopic.p3w)\n        this.scoreWeights.set({ topic, p: 'p3b' }, wsTopic.p3bw)\n        this.scoreWeights.set({ topic, p: 'p4' }, wsTopic.p4w)\n      }\n\n      this.scoreWeights.set({ p: 'p5' }, sw.p5w)\n      this.scoreWeights.set({ p: 'p6' }, sw.p6w)\n      this.scoreWeights.set({ p: 'p7' }, sw.p7w)\n    },\n\n    registerScorePerMesh (mesh: Map<TopicStr, Set<PeerIdStr>>, scoreByPeer: Map<PeerIdStr, number>): void {\n      const peersPerTopicLabel = new Map<TopicLabel, Set<PeerIdStr>>()\n\n      mesh.forEach((peers, topicStr) => {\n        // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n        const topicLabel = this.topicStrToLabel.get(topicStr) ?? 'unknown'\n        let peersInMesh = peersPerTopicLabel.get(topicLabel)\n        if (peersInMesh == null) {\n          peersInMesh = new Set()\n          peersPerTopicLabel.set(topicLabel, peersInMesh)\n        }\n        peers.forEach((p) => peersInMesh?.add(p))\n      })\n\n      for (const [topic, peers] of peersPerTopicLabel) {\n        const meshScores: number[] = []\n        peers.forEach((peer) => {\n          meshScores.push(scoreByPeer.get(peer) ?? 0)\n        })\n        this.scorePerMesh.set({ topic }, meshScores)\n      }\n    }\n  }\n}\n", "export class InvalidPeerScoreParamsError extends Error {\n  static name = 'InvalidPeerScoreParamsError'\n\n  constructor (message = 'Invalid peer score params') {\n    super(message)\n    this.name = 'InvalidPeerScoreParamsError'\n  }\n}\n\nexport class InvalidPeerScoreThresholdsError extends Error {\n  static name = 'InvalidPeerScoreThresholdsError'\n\n  constructor (message = 'Invalid peer score thresholds') {\n    super(message)\n    this.name = 'InvalidPeerScoreThresholdsError'\n  }\n}\n", "import { InvalidPeerScoreParamsError } from '../errors.js'\n\n// This file defines PeerScoreParams and TopicScoreParams interfaces\n// as well as constructors, default constructors, and validation functions\n// for these interfaces\n\nexport interface PeerScoreParams {\n  /**\n   * Score parameters per topic.\n   */\n  topics: Record<string, TopicScoreParams>\n\n  /**\n   * Aggregate topic score cap; this limits the total contribution of topics towards a positive\n   * score. It must be positive (or 0 for no cap).\n   */\n  topicScoreCap: number\n\n  /**\n   * P5: Application-specific peer scoring\n   */\n  appSpecificScore(p: string): number\n  appSpecificWeight: number\n\n  /**\n   * P6: IP-colocation factor.\n   * The parameter has an associated counter which counts the number of peers with the same IP.\n   * If the number of peers in the same IP exceeds IPColocationFactorThreshold, then the value\n   * is the square of the difference, ie (PeersInSameIP - IPColocationThreshold)^2.\n   * If the number of peers in the same IP is less than the threshold, then the value is 0.\n   * The weight of the parameter MUST be negative, unless you want to disable for testing.\n   * Note: In order to simulate many IPs in a managable manner when testing, you can set the weight to 0\n   * thus disabling the IP colocation penalty.\n   */\n  IPColocationFactorWeight: number\n  IPColocationFactorThreshold: number\n  IPColocationFactorWhitelist: Set<string>\n\n  /**\n   * P7: behavioural pattern penalties.\n   * This parameter has an associated counter which tracks misbehaviour as detected by the\n   * router. The router currently applies penalties for the following behaviors:\n   * - attempting to re-graft before the prune backoff time has elapsed.\n   * - not following up in IWANT requests for messages advertised with IHAVE.\n   *\n   * The value of the parameter is the square of the counter, which decays with  BehaviourPenaltyDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  behaviourPenaltyWeight: number\n  behaviourPenaltyThreshold: number\n  behaviourPenaltyDecay: number\n\n  /**\n   * the decay interval for parameter counters.\n   */\n  decayInterval: number\n\n  /**\n   * counter value below which it is considered 0.\n   */\n  decayToZero: number\n\n  /**\n   * time to remember counters for a disconnected peer.\n   */\n  retainScore: number\n}\n\nexport interface TopicScoreParams {\n  /**\n   * The weight of the topic.\n   */\n  topicWeight: number\n\n  /**\n   * P1: time in the mesh\n   * This is the time the peer has ben grafted in the mesh.\n   * The value of the parameter is the time/TimeInMeshQuantum, capped by TimeInMeshCap\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  timeInMeshWeight: number\n  timeInMeshQuantum: number\n  timeInMeshCap: number\n\n  /**\n   * P2: first message deliveries\n   * This is the number of message deliveries in the topic.\n   * The value of the parameter is a counter, decaying with FirstMessageDeliveriesDecay, and capped\n   * by FirstMessageDeliveriesCap.\n   * The weight of the parameter MUST be positive (or zero to disable).\n   */\n  firstMessageDeliveriesWeight: number\n  firstMessageDeliveriesDecay: number\n  firstMessageDeliveriesCap: number\n\n  /**\n   * P3: mesh message deliveries\n   * This is the number of message deliveries in the mesh, within the MeshMessageDeliveriesWindow of\n   * message validation; deliveries during validation also count and are retroactively applied\n   * when validation succeeds.\n   * This window accounts for the minimum time before a hostile mesh peer trying to game the score\n   * could replay back a valid message we just sent them.\n   * It effectively tracks first and near-first deliveries, ie a message seen from a mesh peer\n   * before we have forwarded it to them.\n   * The parameter has an associated counter, decaying with MeshMessageDeliveriesDecay.\n   * If the counter exceeds the threshold, its value is 0.\n   * If the counter is below the MeshMessageDeliveriesThreshold, the value is the square of\n   * the deficit, ie (MessageDeliveriesThreshold - counter)^2\n   * The penalty is only activated after MeshMessageDeliveriesActivation time in the mesh.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  meshMessageDeliveriesWeight: number\n  meshMessageDeliveriesDecay: number\n  meshMessageDeliveriesCap: number\n  meshMessageDeliveriesThreshold: number\n  meshMessageDeliveriesWindow: number\n  meshMessageDeliveriesActivation: number\n\n  /**\n   * P3b: sticky mesh propagation failures\n   * This is a sticky penalty that applies when a peer gets pruned from the mesh with an active\n   * mesh message delivery penalty.\n   * The weight of the parameter MUST be negative (or zero to disable)\n   */\n  meshFailurePenaltyWeight: number\n  meshFailurePenaltyDecay: number\n\n  /**\n   * P4: invalid messages\n   * This is the number of invalid messages in the topic.\n   * The value of the parameter is the square of the counter, decaying with\n   * InvalidMessageDeliveriesDecay.\n   * The weight of the parameter MUST be negative (or zero to disable).\n   */\n  invalidMessageDeliveriesWeight: number\n  invalidMessageDeliveriesDecay: number\n}\n\nexport const defaultPeerScoreParams: PeerScoreParams = {\n  topics: {},\n  topicScoreCap: 10.0,\n  appSpecificScore: () => 0.0,\n  appSpecificWeight: 10.0,\n  IPColocationFactorWeight: -5.0,\n  IPColocationFactorThreshold: 10.0,\n  IPColocationFactorWhitelist: new Set(),\n  behaviourPenaltyWeight: -10.0,\n  behaviourPenaltyThreshold: 0.0,\n  behaviourPenaltyDecay: 0.2,\n  decayInterval: 1000.0,\n  decayToZero: 0.1,\n  retainScore: 3600 * 1000\n}\n\nexport const defaultTopicScoreParams: TopicScoreParams = {\n  topicWeight: 0.5,\n  timeInMeshWeight: 1,\n  timeInMeshQuantum: 1,\n  timeInMeshCap: 3600,\n\n  firstMessageDeliveriesWeight: 1,\n  firstMessageDeliveriesDecay: 0.5,\n  firstMessageDeliveriesCap: 2000,\n\n  meshMessageDeliveriesWeight: -1,\n  meshMessageDeliveriesDecay: 0.5,\n  meshMessageDeliveriesCap: 100,\n  meshMessageDeliveriesThreshold: 20,\n  meshMessageDeliveriesWindow: 10,\n  meshMessageDeliveriesActivation: 5000,\n\n  meshFailurePenaltyWeight: -1,\n  meshFailurePenaltyDecay: 0.5,\n\n  invalidMessageDeliveriesWeight: -1,\n  invalidMessageDeliveriesDecay: 0.3\n}\n\nexport function createPeerScoreParams (p: Partial<PeerScoreParams> = {}): PeerScoreParams {\n  return {\n    ...defaultPeerScoreParams,\n    ...p,\n    topics: (p.topics != null)\n      ? Object.entries(p.topics).reduce<Record<string, TopicScoreParams>>((topics, [topic, topicScoreParams]) => {\n        topics[topic] = createTopicScoreParams(topicScoreParams)\n        return topics\n      }, {})\n      : {}\n  }\n}\n\nexport function createTopicScoreParams (p: Partial<TopicScoreParams> = {}): TopicScoreParams {\n  return {\n    ...defaultTopicScoreParams,\n    ...p\n  }\n}\n\n// peer score parameter validation\nexport function validatePeerScoreParams (p: PeerScoreParams): void {\n  for (const [topic, params] of Object.entries(p.topics)) {\n    try {\n      validateTopicScoreParams(params)\n    } catch (e) {\n      throw new InvalidPeerScoreParamsError(`invalid score parameters for topic ${topic}: ${(e as Error).message}`)\n    }\n  }\n\n  // check that the topic score is 0 or something positive\n  if (p.topicScoreCap < 0) {\n    throw new InvalidPeerScoreParamsError('invalid topic score cap; must be positive (or 0 for no cap)')\n  }\n\n  // check that we have an app specific score; the weight can be anything (but expected positive)\n  if (p.appSpecificScore === null || p.appSpecificScore === undefined) {\n    throw new InvalidPeerScoreParamsError('missing application specific score function')\n  }\n\n  // check the IP colocation factor\n  if (p.IPColocationFactorWeight > 0) {\n    throw new InvalidPeerScoreParamsError('invalid IPColocationFactorWeight; must be negative (or 0 to disable)')\n  }\n  if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {\n    throw new InvalidPeerScoreParamsError('invalid IPColocationFactorThreshold; must be at least 1')\n  }\n\n  // check the behaviour penalty\n  if (p.behaviourPenaltyWeight > 0) {\n    throw new InvalidPeerScoreParamsError('invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)')\n  }\n  if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {\n    throw new InvalidPeerScoreParamsError('invalid BehaviourPenaltyDecay; must be between 0 and 1')\n  }\n\n  // check the decay parameters\n  if (p.decayInterval < 1000) {\n    throw new InvalidPeerScoreParamsError('invalid DecayInterval; must be at least 1s')\n  }\n  if (p.decayToZero <= 0 || p.decayToZero >= 1) {\n    throw new InvalidPeerScoreParamsError('invalid DecayToZero; must be between 0 and 1')\n  }\n\n  // no need to check the score retention; a value of 0 means that we don't retain scores\n}\n\n// eslint-disable-next-line complexity\nexport function validateTopicScoreParams (p: TopicScoreParams): void {\n  // make sure we have a sane topic weight\n  if (p.topicWeight < 0) {\n    throw new InvalidPeerScoreParamsError('invalid topic weight; must be >= 0')\n  }\n\n  // check P1\n  if (p.timeInMeshQuantum === 0) {\n    throw new InvalidPeerScoreParamsError('invalid TimeInMeshQuantum; must be non zero')\n  }\n  if (p.timeInMeshWeight < 0) {\n    throw new InvalidPeerScoreParamsError('invalid TimeInMeshWeight; must be positive (or 0 to disable)')\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {\n    throw new InvalidPeerScoreParamsError('invalid TimeInMeshQuantum; must be positive')\n  }\n  if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {\n    throw new InvalidPeerScoreParamsError('invalid TimeInMeshCap; must be positive')\n  }\n\n  // check P2\n  if (p.firstMessageDeliveriesWeight < 0) {\n    throw new InvalidPeerScoreParamsError('invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)')\n  }\n  if (\n    p.firstMessageDeliveriesWeight !== 0 &&\n    (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)\n  ) {\n    throw new InvalidPeerScoreParamsError('invalid FirstMessageDeliveriesDecay; must be between 0 and 1')\n  }\n  if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {\n    throw new InvalidPeerScoreParamsError('invalid FirstMessageDeliveriesCap; must be positive')\n  }\n\n  // check P3\n  if (p.meshMessageDeliveriesWeight > 0) {\n    throw new InvalidPeerScoreParamsError('invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)')\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {\n    throw new InvalidPeerScoreParamsError('invalid MeshMessageDeliveriesDecay; must be between 0 and 1')\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {\n    throw new InvalidPeerScoreParamsError('invalid MeshMessageDeliveriesCap; must be positive')\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {\n    throw new InvalidPeerScoreParamsError('invalid MeshMessageDeliveriesThreshold; must be positive')\n  }\n  if (p.meshMessageDeliveriesWindow < 0) {\n    throw new InvalidPeerScoreParamsError('invalid MeshMessageDeliveriesWindow; must be non-negative')\n  }\n  if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1000) {\n    throw new InvalidPeerScoreParamsError('invalid MeshMessageDeliveriesActivation; must be at least 1s')\n  }\n\n  // check P3b\n  if (p.meshFailurePenaltyWeight > 0) {\n    throw new InvalidPeerScoreParamsError('invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)')\n  }\n  if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {\n    throw new InvalidPeerScoreParamsError('invalid MeshFailurePenaltyDecay; must be between 0 and 1')\n  }\n\n  // check P4\n  if (p.invalidMessageDeliveriesWeight > 0) {\n    throw new InvalidPeerScoreParamsError('invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)')\n  }\n  if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {\n    throw new InvalidPeerScoreParamsError('invalid InvalidMessageDeliveriesDecay; must be between 0 and 1')\n  }\n}\n", "import { InvalidPeerScoreThresholdsError } from '../errors.js'\n\n// This file defines PeerScoreThresholds interface\n// as well as a constructor, default constructor, and validation function\n// for this interface\n\nexport interface PeerScoreThresholds {\n  /**\n   * gossipThreshold is the score threshold below which gossip propagation is supressed;\n   * should be negative.\n   */\n  gossipThreshold: number\n\n  /**\n   * publishThreshold is the score threshold below which we shouldn't publish when using flood\n   * publishing (also applies to fanout and floodsub peers); should be negative and <= GossipThreshold.\n   */\n  publishThreshold: number\n\n  /**\n   * graylistThreshold is the score threshold below which message processing is supressed altogether,\n   * implementing an effective graylist according to peer score; should be negative and <= PublisThreshold.\n   */\n  graylistThreshold: number\n\n  /**\n   * acceptPXThreshold is the score threshold below which PX will be ignored; this should be positive\n   * and limited to scores attainable by bootstrappers and other trusted nodes.\n   */\n  acceptPXThreshold: number\n\n  /**\n   * opportunisticGraftThreshold is the median mesh score threshold before triggering opportunistic\n   * grafting; this should have a small positive value.\n   */\n  opportunisticGraftThreshold: number\n}\n\nexport const defaultPeerScoreThresholds: PeerScoreThresholds = {\n  gossipThreshold: -10,\n  publishThreshold: -50,\n  graylistThreshold: -80,\n  acceptPXThreshold: 10,\n  opportunisticGraftThreshold: 20\n}\n\nexport function createPeerScoreThresholds (p: Partial<PeerScoreThresholds> = {}): PeerScoreThresholds {\n  return {\n    ...defaultPeerScoreThresholds,\n    ...p\n  }\n}\n\nexport function validatePeerScoreThresholds (p: PeerScoreThresholds): void {\n  if (p.gossipThreshold > 0) {\n    throw new InvalidPeerScoreThresholdsError('invalid gossip threshold; it must be <= 0')\n  }\n  if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {\n    throw new InvalidPeerScoreThresholdsError('invalid publish threshold; it must be <= 0 and <= gossip threshold')\n  }\n  if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {\n    throw new InvalidPeerScoreThresholdsError('invalid graylist threshold; it must be <= 0 and <= publish threshold')\n  }\n  if (p.acceptPXThreshold < 0) {\n    throw new InvalidPeerScoreThresholdsError('invalid accept PX threshold; it must be >= 0')\n  }\n  if (p.opportunisticGraftThreshold < 0) {\n    throw new InvalidPeerScoreThresholdsError('invalid opportunistic grafting threshold; it must be >= 0')\n  }\n}\n", "/**\n * Exclude up to `ineed` items from a set if item meets condition `cond`\n */\nexport function removeItemsFromSet<T> (\n  superSet: Set<T>,\n  ineed: number,\n  cond: (peer: T) => boolean = () => true\n): Set<T> {\n  const subset = new Set<T>()\n  if (ineed <= 0) { return subset }\n\n  for (const id of superSet) {\n    if (subset.size >= ineed) { break }\n    if (cond(id)) {\n      subset.add(id)\n      superSet.delete(id)\n    }\n  }\n\n  return subset\n}\n\n/**\n * Exclude up to `ineed` items from a set\n */\nexport function removeFirstNItemsFromSet<T> (superSet: Set<T>, ineed: number): Set<T> {\n  return removeItemsFromSet(superSet, ineed, () => true)\n}\n\nexport class MapDef<K, V> extends Map<K, V> {\n  constructor (private readonly getDefault: () => V) {\n    super()\n  }\n\n  getOrDefault (key: K): V {\n    let value = super.get(key)\n    if (value === undefined) {\n      value = this.getDefault()\n      this.set(key, value)\n    }\n    return value\n  }\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\nexport function computeScore (\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>\n): number {\n  let score = 0\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScore = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      let p1 = tstats.meshTime / topicParams.timeInMeshQuantum\n      if (p1 > topicParams.timeInMeshCap) {\n        p1 = topicParams.timeInMeshCap\n      }\n      topicScore += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    topicScore += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      topicScore += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    topicScore += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    topicScore += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += topicScore * topicParams.topicWeight\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n  }\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  score += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = (peersInIP != null) ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      score += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  if (pstats.behaviourPenalty > params.behaviourPenaltyThreshold) {\n    const excess = pstats.behaviourPenalty - params.behaviourPenaltyThreshold\n    const p7 = excess * excess\n    score += p7 * params.behaviourPenaltyWeight\n  }\n\n  return score\n}\n", "import Denque from 'denque'\nimport { TimeCacheDuration } from '../constants.js'\n\nexport enum DeliveryRecordStatus {\n  /**\n   * we don't know (yet) if the message is valid\n   */\n  unknown,\n  /**\n   * we know the message is valid\n   */\n  valid,\n  /**\n   * we know the message is invalid\n   */\n  invalid,\n  /**\n   * we were instructed by the validator to ignore the message\n   */\n  ignored\n}\n\nexport interface DeliveryRecord {\n  status: DeliveryRecordStatus\n  firstSeenTsMs: number\n  validated: number\n  peers: Set<string>\n}\n\ninterface DeliveryQueueEntry {\n  msgId: string\n  expire: number\n}\n\n/**\n * Map of canonical message ID to DeliveryRecord\n *\n * Maintains an internal queue for efficient gc of old messages\n */\nexport class MessageDeliveries {\n  private readonly records: Map<string, DeliveryRecord>\n  public queue: Denque<DeliveryQueueEntry>\n\n  constructor () {\n    this.records = new Map()\n    this.queue = new Denque()\n  }\n\n  getRecord (msgIdStr: string): DeliveryRecord | undefined {\n    return this.records.get(msgIdStr)\n  }\n\n  ensureRecord (msgIdStr: string): DeliveryRecord {\n    let drec = this.records.get(msgIdStr)\n    if (drec != null) {\n      return drec\n    }\n\n    // record doesn't exist yet\n    // create record\n    drec = {\n      status: DeliveryRecordStatus.unknown,\n      firstSeenTsMs: Date.now(),\n      validated: 0,\n      peers: new Set()\n    }\n    this.records.set(msgIdStr, drec)\n\n    // and add msgId to the queue\n    const entry: DeliveryQueueEntry = {\n      msgId: msgIdStr,\n      expire: Date.now() + TimeCacheDuration\n    }\n    this.queue.push(entry)\n\n    return drec\n  }\n\n  gc (): void {\n    const now = Date.now()\n    // queue is sorted by expiry time\n    // remove expired messages, remove from queue until first un-expired message found\n    let head = this.queue.peekFront()\n    while ((head != null) && head.expire < now) {\n      this.records.delete(head.msgId)\n      this.queue.shift()\n      head = this.queue.peekFront()\n    }\n  }\n\n  clear (): void {\n    this.records.clear()\n    this.queue.clear()\n  }\n}\n", "import { RejectReason } from '../types.js'\nimport { MapDef } from '../utils/set.js'\nimport { computeScore } from './compute-score.js'\nimport { MessageDeliveries, DeliveryRecordStatus } from './message-deliveries.js'\nimport { validatePeerScoreParams } from './peer-score-params.js'\nimport type { MsgIdStr, PeerIdStr, TopicStr, IPStr } from '../types.js'\nimport type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats, TopicStats } from './peer-stats.js'\nimport type { Metrics, ScorePenalty } from '../metrics.js'\nimport type { ComponentLogger, Logger } from '@libp2p/interface'\n\ninterface PeerScoreOpts {\n  /**\n   * Miliseconds to cache computed score per peer\n   */\n  scoreCacheValidityMs: number\n\n  computeScore?: typeof computeScore\n}\n\ninterface ScoreCacheEntry {\n  /** The cached score */\n  score: number\n  /** Unix timestamp in miliseconds, the time after which the cached score for a peer is no longer valid */\n  cacheUntil: number\n}\n\nexport type PeerScoreStatsDump = Record<PeerIdStr, PeerStats>\n\nexport class PeerScore {\n  /**\n   * Per-peer stats for score calculation\n   */\n  readonly peerStats = new Map<PeerIdStr, PeerStats>()\n  /**\n   * IP colocation tracking; maps IP => set of peers.\n   */\n  readonly peerIPs = new MapDef<PeerIdStr, Set<IPStr>>(() => new Set())\n  /**\n   * Cache score up to decayInterval if topic stats are unchanged.\n   */\n  readonly scoreCache = new Map<PeerIdStr, ScoreCacheEntry>()\n  /**\n   * Recent message delivery timing/participants\n   */\n  readonly deliveryRecords = new MessageDeliveries()\n\n  _backgroundInterval?: ReturnType<typeof setInterval>\n\n  private readonly scoreCacheValidityMs: number\n  private readonly computeScore: typeof computeScore\n  private readonly log: Logger\n\n  constructor (readonly params: PeerScoreParams, private readonly metrics: Metrics | null, componentLogger: ComponentLogger, opts: PeerScoreOpts) {\n    validatePeerScoreParams(params)\n    this.scoreCacheValidityMs = opts.scoreCacheValidityMs\n    this.computeScore = opts.computeScore ?? computeScore\n    this.log = componentLogger.forComponent('libp2p:gossipsub:score')\n  }\n\n  get size (): number {\n    return this.peerStats.size\n  }\n\n  /**\n   * Start PeerScore instance\n   */\n  start (): void {\n    if (this._backgroundInterval != null) {\n      this.log('Peer score already running')\n      return\n    }\n    this._backgroundInterval = setInterval(() => { this.background() }, this.params.decayInterval)\n    this.log('started')\n  }\n\n  /**\n   * Stop PeerScore instance\n   */\n  stop (): void {\n    if (this._backgroundInterval == null) {\n      this.log('Peer score already stopped')\n      return\n    }\n    clearInterval(this._backgroundInterval)\n    delete this._backgroundInterval\n    this.peerIPs.clear()\n    this.peerStats.clear()\n    this.deliveryRecords.clear()\n    this.log('stopped')\n  }\n\n  /**\n   * Periodic maintenance\n   */\n  background (): void {\n    this.refreshScores()\n    this.deliveryRecords.gc()\n  }\n\n  dumpPeerScoreStats (): PeerScoreStatsDump {\n    return Object.fromEntries(Array.from(this.peerStats.entries()).map(([peer, stats]) => [peer, stats]))\n  }\n\n  messageFirstSeenTimestampMs (msgIdStr: MsgIdStr): number | null {\n    const drec = this.deliveryRecords.getRecord(msgIdStr)\n    return (drec != null) ? drec.firstSeenTsMs : null\n  }\n\n  /**\n   * Decays scores, and purges score records for disconnected peers once their expiry has elapsed.\n   */\n  public refreshScores (): void {\n    const now = Date.now()\n    const decayToZero = this.params.decayToZero\n\n    this.peerStats.forEach((pstats, id) => {\n      if (!pstats.connected) {\n        // has the retention period expired?\n        if (now > pstats.expire) {\n          // yes, throw it away (but clean up the IP tracking first)\n          this.removeIPsForPeer(id, pstats.knownIPs)\n          this.peerStats.delete(id)\n          this.scoreCache.delete(id)\n        }\n\n        // we don't decay retained scores, as the peer is not active.\n        // this way the peer cannot reset a negative score by simply disconnecting and reconnecting,\n        // unless the retention period has elapsed.\n        // similarly, a well behaved peer does not lose its score by getting disconnected.\n        return\n      }\n\n      Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n        const tparams = this.params.topics[topic]\n        if (tparams === undefined) {\n          // we are not scoring this topic\n          // should be unreachable, we only add scored topics to pstats\n          return\n        }\n\n        // decay counters\n        tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay\n        if (tstats.firstMessageDeliveries < decayToZero) {\n          tstats.firstMessageDeliveries = 0\n        }\n\n        tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay\n        if (tstats.meshMessageDeliveries < decayToZero) {\n          tstats.meshMessageDeliveries = 0\n        }\n\n        tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay\n        if (tstats.meshFailurePenalty < decayToZero) {\n          tstats.meshFailurePenalty = 0\n        }\n\n        tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay\n        if (tstats.invalidMessageDeliveries < decayToZero) {\n          tstats.invalidMessageDeliveries = 0\n        }\n\n        // update mesh time and activate mesh message delivery parameter if need be\n        if (tstats.inMesh) {\n          tstats.meshTime = now - tstats.graftTime\n          if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {\n            tstats.meshMessageDeliveriesActive = true\n          }\n        }\n      })\n\n      // decay P7 counter\n      pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay\n      if (pstats.behaviourPenalty < decayToZero) {\n        pstats.behaviourPenalty = 0\n      }\n    })\n  }\n\n  /**\n   * Return the score for a peer\n   */\n  score (id: PeerIdStr): number {\n    this.metrics?.scoreFnCalls.inc()\n\n    const pstats = this.peerStats.get(id)\n    if (pstats == null) {\n      return 0\n    }\n\n    const now = Date.now()\n    const cacheEntry = this.scoreCache.get(id)\n\n    // Found cached score within validity period\n    if ((cacheEntry != null) && cacheEntry.cacheUntil > now) {\n      return cacheEntry.score\n    }\n\n    this.metrics?.scoreFnRuns.inc()\n\n    const score = this.computeScore(id, pstats, this.params, this.peerIPs)\n    const cacheUntil = now + this.scoreCacheValidityMs\n\n    if (cacheEntry != null) {\n      this.metrics?.scoreCachedDelta.observe(Math.abs(score - cacheEntry.score))\n      cacheEntry.score = score\n      cacheEntry.cacheUntil = cacheUntil\n    } else {\n      this.scoreCache.set(id, { score, cacheUntil })\n    }\n\n    return score\n  }\n\n  /**\n   * Apply a behavioural penalty to a peer\n   */\n  addPenalty (id: PeerIdStr, penalty: number, penaltyLabel: ScorePenalty): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.behaviourPenalty += penalty\n      this.metrics?.onScorePenalty(penaltyLabel)\n    }\n  }\n\n  addPeer (id: PeerIdStr): void {\n    // create peer stats (not including topic stats for each topic to be scored)\n    // topic stats will be added as needed\n    const pstats: PeerStats = {\n      connected: true,\n      expire: 0,\n      topics: {},\n      knownIPs: new Set(),\n      behaviourPenalty: 0\n    }\n    this.peerStats.set(id, pstats)\n  }\n\n  /** Adds a new IP to a peer, if the peer is not known the update is ignored */\n  addIP (id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.knownIPs.add(ip)\n    }\n\n    this.peerIPs.getOrDefault(ip).add(id)\n  }\n\n  /** Remove peer association with IP */\n  removeIP (id: PeerIdStr, ip: string): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      pstats.knownIPs.delete(ip)\n    }\n\n    const peersWithIP = this.peerIPs.get(ip)\n    if (peersWithIP != null) {\n      peersWithIP.delete(id)\n      if (peersWithIP.size === 0) {\n        this.peerIPs.delete(ip)\n      }\n    }\n  }\n\n  removePeer (id: PeerIdStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats == null) {\n      return\n    }\n\n    // decide whether to retain the score; this currently only retains non-positive scores\n    // to dissuade attacks on the score function.\n    if (this.score(id) > 0) {\n      this.removeIPsForPeer(id, pstats.knownIPs)\n      this.peerStats.delete(id)\n      return\n    }\n\n    // furthermore, when we decide to retain the score, the firstMessageDelivery counters are\n    // reset to 0 and mesh delivery penalties applied.\n    Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n      tstats.firstMessageDeliveries = 0\n\n      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n      if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n        const deficit = threshold - tstats.meshMessageDeliveries\n        tstats.meshFailurePenalty += deficit * deficit\n      }\n\n      tstats.inMesh = false\n      tstats.meshMessageDeliveriesActive = false\n    })\n\n    pstats.connected = false\n    pstats.expire = Date.now() + this.params.retainScore\n  }\n\n  /** Handles scoring functionality as a peer GRAFTs to a topic. */\n  graft (id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        // if we are scoring the topic, update the mesh status.\n        tstats.inMesh = true\n        tstats.graftTime = Date.now()\n        tstats.meshTime = 0\n        tstats.meshMessageDeliveriesActive = false\n      }\n    }\n  }\n\n  /** Handles scoring functionality as a peer PRUNEs from a topic. */\n  prune (id: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(id)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        // sticky mesh delivery rate failure penalty\n        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold\n        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {\n          const deficit = threshold - tstats.meshMessageDeliveries\n          tstats.meshFailurePenalty += deficit * deficit\n        }\n        tstats.meshMessageDeliveriesActive = false\n        tstats.inMesh = false\n\n        // TODO: Consider clearing score cache on important penalties\n        // this.scoreCache.delete(id)\n      }\n    }\n  }\n\n  validateMessage (msgIdStr: MsgIdStr): void {\n    this.deliveryRecords.ensureRecord(msgIdStr)\n  }\n\n  deliverMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    this.markFirstMessageDelivery(from, topic)\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n    const now = Date.now()\n\n    // defensive check that this is the first delivery trace -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      this.log(\n        'unexpected delivery: message from %s was first seen %s ago and has delivery status %s',\n        from,\n        now - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    // mark the message as valid and reward mesh peers that have already forwarded it to us\n    drec.status = DeliveryRecordStatus.valid\n    drec.validated = now\n    drec.peers.forEach((p) => {\n      // this check is to make sure a peer can't send us a message twice and get a double count\n      // if it is a first delivery.\n      if (p !== from.toString()) {\n        this.markDuplicateMessageDelivery(p, topic)\n      }\n    })\n  }\n\n  /**\n   * Similar to `rejectMessage` except does not require the message id or reason for an invalid message.\n   */\n  rejectInvalidMessage (from: PeerIdStr, topic: TopicStr): void {\n    this.markInvalidMessageDelivery(from, topic)\n  }\n\n  rejectMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr, reason: RejectReason): void {\n    // eslint-disable-next-line default-case\n    switch (reason) {\n      // these messages are not tracked, but the peer is penalized as they are invalid\n      case RejectReason.Error:\n        this.markInvalidMessageDelivery(from, topic)\n        return\n\n      // we ignore those messages, so do nothing.\n      case RejectReason.Blacklisted:\n        return\n\n      // the rest are handled after record creation\n    }\n\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    // defensive check that this is the first rejection -- delivery status should be unknown\n    if (drec.status !== DeliveryRecordStatus.unknown) {\n      this.log(\n        'unexpected rejection: message from %s was first seen %s ago and has delivery status %d',\n        from,\n        Date.now() - drec.firstSeenTsMs,\n        DeliveryRecordStatus[drec.status]\n      )\n      return\n    }\n\n    if (reason === RejectReason.Ignore) {\n      // we were explicitly instructed by the validator to ignore the message but not penalize the peer\n      drec.status = DeliveryRecordStatus.ignored\n      drec.peers.clear()\n      return\n    }\n\n    // mark the message as invalid and penalize peers that have already forwarded it.\n    drec.status = DeliveryRecordStatus.invalid\n\n    this.markInvalidMessageDelivery(from, topic)\n    drec.peers.forEach((p) => {\n      this.markInvalidMessageDelivery(p, topic)\n    })\n\n    // release the delivery time tracking map to free some memory early\n    drec.peers.clear()\n  }\n\n  duplicateMessage (from: PeerIdStr, msgIdStr: MsgIdStr, topic: TopicStr): void {\n    const drec = this.deliveryRecords.ensureRecord(msgIdStr)\n\n    if (drec.peers.has(from)) {\n      // we have already seen this duplicate\n      return\n    }\n\n    // eslint-disable-next-line default-case\n    switch (drec.status) {\n      case DeliveryRecordStatus.unknown:\n        // the message is being validated; track the peer delivery and wait for\n        // the Deliver/Reject/Ignore notification.\n        drec.peers.add(from)\n        break\n\n      case DeliveryRecordStatus.valid:\n        // mark the peer delivery time to only count a duplicate delivery once.\n        drec.peers.add(from)\n        this.markDuplicateMessageDelivery(from, topic, drec.validated)\n        break\n\n      case DeliveryRecordStatus.invalid:\n        // we no longer track delivery time\n        this.markInvalidMessageDelivery(from, topic)\n        break\n\n      case DeliveryRecordStatus.ignored:\n        // the message was ignored; do nothing (we don't know if it was valid)\n        break\n    }\n  }\n\n  /**\n   * Increments the \"invalid message deliveries\" counter for all scored topics the message is published in.\n   */\n  public markInvalidMessageDelivery (from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        tstats.invalidMessageDeliveries += 1\n      }\n    }\n  }\n\n  /**\n   * Increments the \"first message deliveries\" counter for all scored topics the message is published in,\n   * as well as the \"mesh message deliveries\" counter, if the peer is in the mesh for the topic.\n   * Messages already known (with the seenCache) are counted with markDuplicateMessageDelivery()\n   */\n  public markFirstMessageDelivery (from: PeerIdStr, topic: TopicStr): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const tstats = this.getPtopicStats(pstats, topic)\n      if (tstats != null) {\n        let cap = this.params.topics[topic].firstMessageDeliveriesCap\n        tstats.firstMessageDeliveries = Math.min(cap, tstats.firstMessageDeliveries + 1)\n\n        if (tstats.inMesh) {\n          cap = this.params.topics[topic].meshMessageDeliveriesCap\n          tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n        }\n      }\n    }\n  }\n\n  /**\n   * Increments the \"mesh message deliveries\" counter for messages we've seen before,\n   * as long the message was received within the P3 window.\n   */\n  public markDuplicateMessageDelivery (from: PeerIdStr, topic: TopicStr, validatedTime?: number): void {\n    const pstats = this.peerStats.get(from)\n    if (pstats != null) {\n      const now = validatedTime !== undefined ? Date.now() : 0\n\n      const tstats = this.getPtopicStats(pstats, topic)\n\n      if (tstats != null && tstats.inMesh) {\n        const tparams = this.params.topics[topic]\n\n        // check against the mesh delivery window -- if the validated time is passed as 0, then\n        // the message was received before we finished validation and thus falls within the mesh\n        // delivery window.\n        if (validatedTime !== undefined) {\n          const deliveryDelayMs = now - validatedTime\n          const isLateDelivery = deliveryDelayMs > tparams.meshMessageDeliveriesWindow\n          this.metrics?.onDuplicateMsgDelivery(topic, deliveryDelayMs, isLateDelivery)\n\n          if (isLateDelivery) {\n            return\n          }\n        }\n\n        const cap = tparams.meshMessageDeliveriesCap\n        tstats.meshMessageDeliveries = Math.min(cap, tstats.meshMessageDeliveries + 1)\n      }\n    }\n  }\n\n  /**\n   * Removes an IP list from the tracking list for a peer.\n   */\n  private removeIPsForPeer (id: PeerIdStr, ipsToRemove: Set<IPStr>): void {\n    for (const ipToRemove of ipsToRemove) {\n      const peerSet = this.peerIPs.get(ipToRemove)\n      if (peerSet != null) {\n        peerSet.delete(id)\n        if (peerSet.size === 0) {\n          this.peerIPs.delete(ipToRemove)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns topic stats if they exist, otherwise if the supplied parameters score the\n   * topic, inserts the default stats and returns a reference to those. If neither apply, returns None.\n   */\n  private getPtopicStats (pstats: PeerStats, topic: TopicStr): TopicStats | null {\n    let topicStats: TopicStats | undefined = pstats.topics[topic]\n\n    if (topicStats !== undefined) {\n      return topicStats\n    }\n\n    if (this.params.topics[topic] !== undefined) {\n      topicStats = {\n        inMesh: false,\n        graftTime: 0,\n        meshTime: 0,\n        firstMessageDeliveries: 0,\n        meshMessageDeliveries: 0,\n        meshMessageDeliveriesActive: false,\n        meshFailurePenalty: 0,\n        invalidMessageDeliveries: 0\n      }\n      pstats.topics[topic] = topicStats\n\n      return topicStats\n    }\n\n    return null\n  }\n}\n", "import type { PeerScoreParams } from './peer-score-params.js'\nimport type { PeerStats } from './peer-stats.js'\n\ntype TopicLabel = string\ntype TopicStr = string\ntype TopicStrToLabel = Map<TopicStr, TopicLabel>\n\nexport interface TopicScoreWeights<T> {\n  p1w: T\n  p2w: T\n  p3w: T\n  p3bw: T\n  p4w: T\n}\nexport interface ScoreWeights<T> {\n  byTopic: Map<TopicLabel, TopicScoreWeights<T>>\n  p5w: T\n  p6w: T\n  p7w: T\n  score: T\n}\n\nexport function computeScoreWeights (\n  peer: string,\n  pstats: PeerStats,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number> {\n  let score = 0\n\n  const byTopic = new Map<TopicLabel, TopicScoreWeights<number>>()\n\n  // topic stores\n  Object.entries(pstats.topics).forEach(([topic, tstats]) => {\n    // the topic parameters\n    // Aggregate by known topicLabel or throw to 'unknown'. This prevent too high cardinality\n    const topicLabel = topicStrToLabel.get(topic) ?? 'unknown'\n    const topicParams = params.topics[topic]\n    if (topicParams === undefined) {\n      // we are not scoring this topic\n      return\n    }\n\n    let topicScores = byTopic.get(topicLabel)\n    if (topicScores == null) {\n      topicScores = {\n        p1w: 0,\n        p2w: 0,\n        p3w: 0,\n        p3bw: 0,\n        p4w: 0\n      }\n      byTopic.set(topicLabel, topicScores)\n    }\n\n    let p1w = 0\n    let p2w = 0\n    let p3w = 0\n    let p3bw = 0\n    let p4w = 0\n\n    // P1: time in Mesh\n    if (tstats.inMesh) {\n      const p1 = Math.max(tstats.meshTime / topicParams.timeInMeshQuantum, topicParams.timeInMeshCap)\n      p1w += p1 * topicParams.timeInMeshWeight\n    }\n\n    // P2: first message deliveries\n    let p2 = tstats.firstMessageDeliveries\n    if (p2 > topicParams.firstMessageDeliveriesCap) {\n      p2 = topicParams.firstMessageDeliveriesCap\n    }\n    p2w += p2 * topicParams.firstMessageDeliveriesWeight\n\n    // P3: mesh message deliveries\n    if (\n      tstats.meshMessageDeliveriesActive &&\n      tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold\n    ) {\n      const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries\n      const p3 = deficit * deficit\n      p3w += p3 * topicParams.meshMessageDeliveriesWeight\n    }\n\n    // P3b:\n    // NOTE: the weight of P3b is negative (validated in validateTopicScoreParams) so this detracts\n    const p3b = tstats.meshFailurePenalty\n    p3bw += p3b * topicParams.meshFailurePenaltyWeight\n\n    // P4: invalid messages\n    // NOTE: the weight of P4 is negative (validated in validateTopicScoreParams) so this detracts\n    const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries\n    p4w += p4 * topicParams.invalidMessageDeliveriesWeight\n\n    // update score, mixing with topic weight\n    score += (p1w + p2w + p3w + p3bw + p4w) * topicParams.topicWeight\n\n    topicScores.p1w += p1w\n    topicScores.p2w += p2w\n    topicScores.p3w += p3w\n    topicScores.p3bw += p3bw\n    topicScores.p4w += p4w\n  })\n\n  // apply the topic score cap, if any\n  if (params.topicScoreCap > 0 && score > params.topicScoreCap) {\n    score = params.topicScoreCap\n\n    // Proportionally apply cap to all individual contributions\n    const capF = params.topicScoreCap / score\n    for (const ws of byTopic.values()) {\n      ws.p1w *= capF\n      ws.p2w *= capF\n      ws.p3w *= capF\n      ws.p3bw *= capF\n      ws.p4w *= capF\n    }\n  }\n\n  let p5w = 0\n  let p6w = 0\n  let p7w = 0\n\n  // P5: application-specific score\n  const p5 = params.appSpecificScore(peer)\n  p5w += p5 * params.appSpecificWeight\n\n  // P6: IP colocation factor\n  pstats.knownIPs.forEach((ip) => {\n    if (params.IPColocationFactorWhitelist.has(ip)) {\n      return\n    }\n\n    // P6 has a cliff (IPColocationFactorThreshold)\n    // It's only applied if at least that many peers are connected to us from that source IP addr.\n    // It is quadratic, and the weight is negative (validated in validatePeerScoreParams)\n    const peersInIP = peerIPs.get(ip)\n    const numPeersInIP = (peersInIP != null) ? peersInIP.size : 0\n    if (numPeersInIP > params.IPColocationFactorThreshold) {\n      const surplus = numPeersInIP - params.IPColocationFactorThreshold\n      const p6 = surplus * surplus\n      p6w += p6 * params.IPColocationFactorWeight\n    }\n  })\n\n  // P7: behavioural pattern penalty\n  const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty\n  p7w += p7 * params.behaviourPenaltyWeight\n\n  score += p5w + p6w + p7w\n\n  return {\n    byTopic,\n    p5w,\n    p6w,\n    p7w,\n    score\n  }\n}\n\nexport function computeAllPeersScoreWeights (\n  peerIdStrs: Iterable<string>,\n  peerStats: Map<string, PeerStats>,\n  params: PeerScoreParams,\n  peerIPs: Map<string, Set<string>>,\n  topicStrToLabel: TopicStrToLabel\n): ScoreWeights<number[]> {\n  const sw: ScoreWeights<number[]> = {\n    byTopic: new Map(),\n    p5w: [],\n    p6w: [],\n    p7w: [],\n    score: []\n  }\n\n  for (const peerIdStr of peerIdStrs) {\n    const pstats = peerStats.get(peerIdStr)\n    if (pstats != null) {\n      const swPeer = computeScoreWeights(peerIdStr, pstats, params, peerIPs, topicStrToLabel)\n\n      for (const [topic, swPeerTopic] of swPeer.byTopic) {\n        let swTopic = sw.byTopic.get(topic)\n        if (swTopic == null) {\n          swTopic = {\n            p1w: [],\n            p2w: [],\n            p3w: [],\n            p3bw: [],\n            p4w: []\n          }\n          sw.byTopic.set(topic, swTopic)\n        }\n\n        swTopic.p1w.push(swPeerTopic.p1w)\n        swTopic.p2w.push(swPeerTopic.p2w)\n        swTopic.p3w.push(swPeerTopic.p3w)\n        swTopic.p3bw.push(swPeerTopic.p3bw)\n        swTopic.p4w.push(swPeerTopic.p4w)\n      }\n\n      sw.p5w.push(swPeer.p5w)\n      sw.p6w.push(swPeer.p6w)\n      sw.p7w.push(swPeer.p7w)\n      sw.score.push(swPeer.score)\n    } else {\n      sw.p5w.push(0)\n      sw.p6w.push(0)\n      sw.p7w.push(0)\n      sw.score.push(0)\n    }\n  }\n\n  return sw\n}\n", "import { InvalidParametersError } from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport interface IP4NetConfig {\n  type: 'ip4'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port?: number\n  cidr?: number\n  sni?: string\n}\n\nexport interface IP6NetConfig {\n  type: 'ip6'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port?: number\n  zone?: string\n  cidr?: string\n  sni?: string\n}\n\nexport interface DNSNetConfig {\n  type: 'dns'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport interface DNS4NetConfig {\n  type: 'dns4'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport interface DNS6NetConfig {\n  type: 'dns6'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport interface DNSAddrNetConfig {\n  type: 'dnsaddr'\n  host: string\n  protocol?: 'tcp' | 'udp'\n  port: number\n  cidr?: number\n}\n\nexport type NetConfig = IP4NetConfig | IP6NetConfig | DNSNetConfig | DNS4NetConfig | DNS6NetConfig | DNSAddrNetConfig\n\n/**\n * Returns host/port/etc information for multiaddrs, if it is available.\n *\n * It will throw if the passed multiaddr does not start with a network address,\n * e.g. a IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address\n */\nexport function getNetConfig (ma: Multiaddr): NetConfig {\n  const components = ma.getComponents()\n  const config: any = {}\n  let index = 0\n\n  if (components[index]?.name === 'ip6zone') {\n    config.zone = `${components[index].value}`\n    index++\n  }\n\n  if (components[index].name === 'ip4' || components[index].name === 'ip6') {\n    config.type = components[index].name\n    config.host = components[index].value\n    index++\n  } else if (components[index].name === 'dns' || components[index].name === 'dns4' || components[index].name === 'dns6') {\n    config.type = components[index].name\n    config.host = components[index].value\n    index++\n  } else if (components[index].name === 'dnsaddr') {\n    config.type = components[index].name\n    config.host = `_dnsaddr.${components[index].value}`\n    index++\n  }\n\n  if (components[index]?.name === 'tcp' || components[index]?.name === 'udp') {\n    config.protocol = components[index].name === 'tcp' ? 'tcp' : 'udp'\n    config.port = parseInt(`${components[index].value}`)\n    index++\n  }\n\n  if (components[index]?.name === 'ipcidr') {\n    if (config.type === 'ip4') {\n      config.cidr = parseInt(`${components[index].value}`)\n    } else if (config.type === 'ip6') {\n      config.cidr = `${components[index].value}`\n    }\n    index++\n  }\n\n  if (config.type == null || config.host == null) {\n    throw new InvalidParametersError(`Multiaddr ${ma} was not an IPv4, IPv6, DNS, DNS4, DNS6 or DNSADDR address`)\n  }\n\n  if (components[index]?.name === 'tls' && components[index + 1]?.name === 'sni') {\n    config.sni = components[index + 1].value\n    index += 2\n  }\n\n  return config\n}\n", "import { getNetConfig } from './get-net-config.ts'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\n/**\n * Check if a given multiaddr is a network address\n */\nexport function isNetworkAddress (ma: Multiaddr): boolean {\n  try {\n    getNetConfig(ma)\n\n    return true\n  } catch {\n    return false\n  }\n}\n", "export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n", "import pTimeout from 'p-timeout';\n\nconst normalizeEmitter = emitter => {\n\tconst addListener = emitter.addEventListener || emitter.on || emitter.addListener;\n\tconst removeListener = emitter.removeEventListener || emitter.off || emitter.removeListener;\n\n\tif (!addListener || !removeListener) {\n\t\tthrow new TypeError('Emitter is not compatible');\n\t}\n\n\treturn {\n\t\taddListener: addListener.bind(emitter),\n\t\tremoveListener: removeListener.bind(emitter),\n\t};\n};\n\nexport function pEventMultiple(emitter, event, options) {\n\tlet cancel;\n\tconst returnValue = new Promise((resolve, reject) => {\n\t\toptions = {\n\t\t\trejectionEvents: ['error'],\n\t\t\tmultiArgs: false,\n\t\t\trejectionMultiArgs: false,\n\t\t\tresolveImmediately: false,\n\t\t\t...options,\n\t\t};\n\n\t\tif (!(options.count >= 0 && (options.count === Number.POSITIVE_INFINITY || Number.isInteger(options.count)))) {\n\t\t\tthrow new TypeError('The `count` option should be at least 0 or more');\n\t\t}\n\n\t\toptions.signal?.throwIfAborted();\n\n\t\t// Allow multiple events\n\t\tconst events = [event].flat();\n\n\t\tconst items = [];\n\t\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\t\tconst onItem = async (...arguments_) => {\n\t\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\t\tif (options.filter) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!(await options.filter(value))) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treject(error);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titems.push(value);\n\n\t\t\tif (options.count === items.length) {\n\t\t\t\tcancel();\n\t\t\t\tresolve(items);\n\t\t\t}\n\t\t};\n\n\t\tconst rejectHandler = (...arguments_) => {\n\t\t\tcancel();\n\t\t\treject(options.rejectionMultiArgs ? arguments_ : arguments_[0]);\n\t\t};\n\n\t\tcancel = () => {\n\t\t\tfor (const event of events) {\n\t\t\t\tremoveListener(event, onItem);\n\t\t\t}\n\n\t\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t\t// Only remove rejection handler if we actually registered it\n\t\t\t\tif (!events.includes(rejectionEvent)) {\n\t\t\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tfor (const event of events) {\n\t\t\taddListener(event, onItem);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\t// Skip registering rejection handler if we're already listening to this event\n\t\t\t// as the main event takes priority (as documented)\n\t\t\tif (!events.includes(rejectionEvent)) {\n\t\t\t\taddListener(rejectionEvent, rejectHandler);\n\t\t\t}\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\toptions.signal.addEventListener('abort', () => {\n\t\t\t\trejectHandler(options.signal.reason);\n\t\t\t}, {once: true});\n\t\t}\n\n\t\tif (options.resolveImmediately) {\n\t\t\tresolve(items);\n\t\t}\n\t});\n\n\treturnValue.cancel = cancel;\n\n\tif (typeof options.timeout === 'number') {\n\t\tconst timeout = pTimeout(returnValue, {milliseconds: options.timeout});\n\t\t// When cancelling, also clear the timeout timer\n\t\ttimeout.cancel = () => {\n\t\t\tcancel();\n\t\t\ttimeout.clear();\n\t\t};\n\n\t\treturn timeout;\n\t}\n\n\treturn returnValue;\n}\n\nexport function pEvent(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\toptions = {\n\t\t...options,\n\t\tcount: 1,\n\t\tresolveImmediately: false,\n\t};\n\n\tconst arrayPromise = pEventMultiple(emitter, event, options);\n\tconst promise = arrayPromise.then(array => array[0]); // eslint-disable-line promise/prefer-await-to-then\n\tpromise.cancel = arrayPromise.cancel;\n\n\treturn promise;\n}\n\nexport function pEventIterator(emitter, event, options) {\n\tif (typeof options === 'function') {\n\t\toptions = {filter: options};\n\t}\n\n\t// Allow multiple events\n\tconst events = [event].flat();\n\n\toptions = {\n\t\trejectionEvents: ['error'],\n\t\tresolutionEvents: [],\n\t\tlimit: Number.POSITIVE_INFINITY,\n\t\tmultiArgs: false,\n\t\trejectionMultiArgs: false,\n\t\t...options,\n\t};\n\n\tconst {limit} = options;\n\tconst isValidLimit = limit >= 0 && (limit === Number.POSITIVE_INFINITY || Number.isInteger(limit));\n\tif (!isValidLimit) {\n\t\tthrow new TypeError('The `limit` option should be a non-negative integer or Infinity');\n\t}\n\n\toptions.signal?.throwIfAborted();\n\n\tif (limit === 0) {\n\t\t// Return an empty async iterator to avoid any further cost\n\t\treturn {\n\t\t\t[Symbol.asyncIterator]() {\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tasync next() {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t},\n\t\t};\n\t}\n\n\tconst {addListener, removeListener} = normalizeEmitter(emitter);\n\n\tlet isDone = false;\n\tlet error;\n\tlet hasPendingError = false;\n\tconst nextQueue = [];\n\tconst valueQueue = [];\n\tlet eventCount = 0;\n\tlet isLimitReached = false;\n\n\tconst valueHandler = (...arguments_) => {\n\t\teventCount++;\n\t\tisLimitReached = eventCount === limit;\n\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\n\t\t\tresolve({done: false, value});\n\n\t\t\tif (isLimitReached) {\n\t\t\t\tcancel();\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tvalueQueue.push(value);\n\n\t\tif (isLimitReached) {\n\t\t\tcancel();\n\t\t}\n\t};\n\n\tconst cancel = () => {\n\t\tisDone = true;\n\n\t\tfor (const event of events) {\n\t\t\tremoveListener(event, valueHandler);\n\t\t}\n\n\t\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\t\tremoveListener(rejectionEvent, rejectHandler);\n\t\t}\n\n\t\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\t\tremoveListener(resolutionEvent, resolveHandler);\n\t\t}\n\n\t\twhile (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value: undefined});\n\t\t}\n\t};\n\n\tconst rejectHandler = (...arguments_) => {\n\t\terror = options.rejectionMultiArgs ? arguments_ : arguments_[0];\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {reject} = nextQueue.shift();\n\t\t\treject(error);\n\t\t} else {\n\t\t\thasPendingError = true;\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tconst resolveHandler = async (...arguments_) => {\n\t\tconst value = options.multiArgs ? arguments_ : arguments_[0];\n\n\t\tif (options.filter) {\n\t\t\ttry {\n\t\t\t\tif (!(await options.filter(value))) {\n\t\t\t\t\tcancel();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} catch (filterError) {\n\t\t\t\tcancel();\n\t\t\t\tif (nextQueue.length > 0) {\n\t\t\t\t\tconst {reject} = nextQueue.shift();\n\t\t\t\t\treject(filterError);\n\t\t\t\t} else {\n\t\t\t\t\t// Store error for next iterator call\n\t\t\t\t\thasPendingError = true;\n\t\t\t\t\terror = filterError;\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (nextQueue.length > 0) {\n\t\t\tconst {resolve} = nextQueue.shift();\n\t\t\tresolve({done: true, value});\n\t\t} else {\n\t\t\tvalueQueue.push(value);\n\t\t}\n\n\t\tcancel();\n\t};\n\n\tfor (const event of events) {\n\t\taddListener(event, valueHandler);\n\t}\n\n\tfor (const rejectionEvent of options.rejectionEvents) {\n\t\taddListener(rejectionEvent, rejectHandler);\n\t}\n\n\tfor (const resolutionEvent of options.resolutionEvents) {\n\t\taddListener(resolutionEvent, resolveHandler);\n\t}\n\n\tif (options.signal) {\n\t\toptions.signal.addEventListener('abort', () => {\n\t\t\trejectHandler(options.signal.reason);\n\t\t}, {once: true});\n\t}\n\n\treturn {\n\t\t[Symbol.asyncIterator]() {\n\t\t\treturn this;\n\t\t},\n\t\tasync next() {\n\t\t\tif (valueQueue.length > 0) {\n\t\t\t\tconst value = valueQueue.shift();\n\t\t\t\treturn {\n\t\t\t\t\tdone: isDone && valueQueue.length === 0 && !isLimitReached,\n\t\t\t\t\tvalue,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (hasPendingError) {\n\t\t\t\thasPendingError = false;\n\t\t\t\tthrow error;\n\t\t\t}\n\n\t\t\tif (isDone) {\n\t\t\t\treturn {\n\t\t\t\t\tdone: true,\n\t\t\t\t\tvalue: undefined,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tnextQueue.push({resolve, reject});\n\t\t\t});\n\t\t},\n\t\tasync return(value) {\n\t\t\tcancel();\n\t\t\treturn {\n\t\t\t\tdone: isDone,\n\t\t\t\tvalue,\n\t\t\t};\n\t\t},\n\t};\n}\n\nexport {TimeoutError} from 'p-timeout';\n", "import { StreamMessageEvent, StreamCloseEvent, InvalidParametersError } from '@libp2p/interface'\nimport { pipe as itPipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport { pEvent } from 'p-event'\nimport { raceSignal } from 'race-signal'\nimport * as varint from 'uint8-varint'\nimport { Uint8ArrayList } from 'uint8arraylist'\nimport { UnexpectedEOFError } from './errors.js'\nimport type { MessageStream, MultiaddrConnection, Stream, AbortOptions } from '@libp2p/interface'\nimport type { Duplex, Source, Transform, Sink } from 'it-stream-types'\n\nconst DEFAULT_MAX_BUFFER_SIZE = 4_194_304\n\nexport class UnwrappedError extends Error {\n  static name = 'UnwrappedError'\n  name = 'UnwrappedError'\n}\n\n/**\n * The reported length of the next data message was not a positive integer\n */\nexport class InvalidMessageLengthError extends Error {\n  name = 'InvalidMessageLengthError'\n  code = 'ERR_INVALID_MSG_LENGTH'\n}\n\n/**\n * The reported length of the next data message was larger than the configured\n * max allowable value\n */\nexport class InvalidDataLengthError extends Error {\n  name = 'InvalidDataLengthError'\n  code = 'ERR_MSG_DATA_TOO_LONG'\n}\n\n/**\n * The varint used to specify the length of the next data message contained more\n * bytes than the configured max allowable value\n */\nexport class InvalidDataLengthLengthError extends Error {\n  name = 'InvalidDataLengthLengthError'\n  code = 'ERR_MSG_LENGTH_TOO_LONG'\n}\n\nexport interface ByteStreamOpts {\n  /**\n   * Incoming bytes are buffered until read, this setting limits how many bytes\n   * will be buffered.\n   *\n   * @default 4_194_304\n   */\n  maxBufferSize?: number\n}\n\nexport interface ReadBytesOptions extends AbortOptions {\n  /**\n   * If specified, read this number of bytes from the stream\n   */\n  bytes: number\n}\n\nexport interface ByteStream<S extends MessageStream> {\n  /**\n   * Read bytes from the stream.\n   *\n   * If a required number of bytes is passed as an option, this will wait for\n   * the underlying stream to supply that number of bytes, throwing an\n   * `UnexpectedEOFError` if the stream closes before this happens.\n   *\n   * If no required number of bytes is passed, this will return `null` if the\n   * underlying stream closes before supplying any bytes.\n   */\n  read(options: ReadBytesOptions): Promise<Uint8ArrayList>\n  read(options?: AbortOptions): Promise<Uint8ArrayList | null>\n\n  /**\n   * Write the passed bytes to the stream\n   */\n  write(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * After calling this method the stream can no longer be used. Any unread data\n   * will be emitted as a message event during the microtask queue of the\n   * current event loop tick.\n   */\n  unwrap(): S\n}\n\nfunction isStream (obj?: any): obj is Stream {\n  return typeof obj?.closeRead === 'function'\n}\n\nfunction isMultiaddrConnection (obj?: any): obj is MultiaddrConnection {\n  return typeof obj?.close === 'function'\n}\n\nfunction isEOF (obj?: any): boolean {\n  if (isStream(obj)) {\n    return obj.readStatus === 'closing' || obj.readStatus === 'closed'\n  }\n\n  if (isMultiaddrConnection(obj)) {\n    return obj.status !== 'open'\n  }\n\n  return false\n}\n\ntype ByteStreamReadable = Pick<Stream & MultiaddrConnection, 'addEventListener' | 'removeEventListener' | 'send' | 'push' | 'log'>\n\nfunction isValid (obj?: any): obj is ByteStreamReadable {\n  return obj?.addEventListener != null && obj?.removeEventListener != null && obj?.send != null && obj?.push != null && obj?.log != null\n}\n\nexport function byteStream <T extends MessageStream> (stream: T, opts?: ByteStreamOpts): ByteStream<T> {\n  const maxBufferSize = opts?.maxBufferSize ?? DEFAULT_MAX_BUFFER_SIZE\n  const readBuffer = new Uint8ArrayList()\n\n  let hasBytes: PromiseWithResolvers<void> | undefined\n  let unwrapped = false\n\n  if (!isValid(stream)) {\n    throw new InvalidParametersError('Argument should be a Stream or a Multiaddr')\n  }\n\n  const byteStreamOnMessageListener = (evt: StreamMessageEvent): void => {\n    readBuffer.append(evt.data)\n\n    if (readBuffer.byteLength > maxBufferSize) {\n      const readBufferSize = readBuffer.byteLength\n      readBuffer.consume(readBuffer.byteLength)\n      hasBytes?.reject(new Error(`Read buffer overflow - ${readBufferSize} > ${maxBufferSize}`))\n    }\n\n    hasBytes?.resolve()\n  }\n  stream.addEventListener('message', byteStreamOnMessageListener)\n\n  const byteStreamOnCloseListener = (evt: StreamCloseEvent): void => {\n    if (evt.error != null) {\n      hasBytes?.reject(evt.error)\n    } else {\n      hasBytes?.resolve()\n    }\n  }\n  stream.addEventListener('close', byteStreamOnCloseListener)\n\n  const byteStreamOnRemoteCloseWrite = (): void => {\n    hasBytes?.resolve()\n  }\n  stream.addEventListener('remoteCloseWrite', byteStreamOnRemoteCloseWrite)\n\n  const byteStream: ByteStream<T> = {\n    readBuffer,\n\n    // @ts-expect-error options type prevents type inference\n    async read (options?: ReadBytesOptions) {\n      if (unwrapped === true) {\n        throw new UnwrappedError('Stream was unwrapped')\n      }\n\n      if (isEOF(stream)) {\n        if (options?.bytes == null) {\n          return null\n        }\n\n        if (readBuffer.byteLength < options.bytes) {\n          stream.log.error('closed after reading %d/%d bytes', readBuffer.byteLength, options.bytes)\n          throw new UnexpectedEOFError(`Unexpected EOF - stream closed after reading ${readBuffer.byteLength}/${options.bytes} bytes`)\n        }\n      }\n\n      const bytesToRead = options?.bytes ?? 1\n      hasBytes = Promise.withResolvers<void>()\n\n      while (true) {\n        if (readBuffer.byteLength >= bytesToRead) {\n          // if we are about to exit the loop this promise will not be awaited\n          // so resolve it to prevent and unhandled promise rejections that may\n          // occur\n          hasBytes.resolve()\n\n          break\n        }\n\n        await raceSignal(hasBytes.promise, options?.signal)\n\n        if (isEOF(stream)) {\n          if (readBuffer.byteLength === 0 && options?.bytes == null) {\n            return null\n          }\n\n          break\n        }\n\n        hasBytes = Promise.withResolvers<void>()\n      }\n\n      const toRead = options?.bytes ?? readBuffer.byteLength\n\n      if (readBuffer.byteLength < toRead) {\n        if (isEOF(stream)) {\n          stream.log.error('closed while reading %d/%d bytes', readBuffer.byteLength, toRead)\n          throw new UnexpectedEOFError(`Unexpected EOF - stream closed while reading ${readBuffer.byteLength}/${toRead} bytes`)\n        }\n\n        return byteStream.read(options)\n      }\n\n      const output = readBuffer.sublist(0, toRead)\n      readBuffer.consume(toRead)\n\n      return output\n    },\n    async write (data: Uint8Array | Uint8ArrayList, options?: AbortOptions) {\n      if (unwrapped === true) {\n        throw new UnwrappedError('Stream was unwrapped')\n      }\n\n      if (!stream.send(data)) {\n        await pEvent(stream, 'drain', {\n          signal: options?.signal,\n          rejectionEvents: ['close']\n        })\n      }\n    },\n    unwrap () {\n      // already unwrapped, just return the original stream\n      if (unwrapped) {\n        return stream\n      }\n\n      // only unwrap once\n      unwrapped = true\n      stream.removeEventListener('message', byteStreamOnMessageListener)\n      stream.removeEventListener('close', byteStreamOnCloseListener)\n      stream.removeEventListener('remoteCloseWrite', byteStreamOnRemoteCloseWrite)\n\n      // emit any unread data\n      if (readBuffer.byteLength > 0) {\n        stream.log('stream unwrapped with %d unread bytes', readBuffer.byteLength)\n        stream.push(readBuffer)\n      }\n\n      return stream\n    }\n  }\n\n  return byteStream\n}\n\nexport interface LengthPrefixedStream<S extends MessageStream = MessageStream> {\n  /**\n   * Read the next length-prefixed number of bytes from the stream\n   */\n  read(options?: AbortOptions): Promise<Uint8ArrayList>\n\n  /**\n   * Write the passed bytes to the stream prefixed by their length\n   */\n  write(data: Uint8Array | Uint8ArrayList, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write passed list of bytes, prefix by their individual lengths to the stream as a single write\n   */\n  writeV(input: Array<Uint8Array | Uint8ArrayList>, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): S\n}\n\nexport interface LengthPrefixedStreamOpts extends ByteStreamOpts {\n  lengthEncoder (value: number): Uint8ArrayList | Uint8Array\n  lengthDecoder (data: Uint8ArrayList): number\n  maxLengthLength: number\n  maxDataLength: number\n}\n\nexport function lpStream <T extends MessageStream> (stream: T, opts: Partial<LengthPrefixedStreamOpts> = {}): LengthPrefixedStream<T> {\n  const bytes = byteStream(stream, opts)\n\n  if (opts.maxDataLength != null && opts.maxLengthLength == null) {\n    // if max data length is set but max length length is not, calculate the\n    // max length length needed to encode max data length\n    opts.maxLengthLength = varint.encodingLength(opts.maxDataLength)\n  }\n\n  const decodeLength = opts?.lengthDecoder ?? varint.decode\n  const encodeLength = opts?.lengthEncoder ?? varint.encode\n\n  const lpStream: LengthPrefixedStream<any> = {\n    async read (options?: AbortOptions) {\n      let dataLength: number = -1\n      const lengthBuffer = new Uint8ArrayList()\n\n      while (true) {\n        // read one byte at a time until we can decode a varint\n        const buf = await bytes.read({\n          ...options,\n          bytes: 1\n        })\n\n        // the underlying resource closed gracefully\n        if (buf == null) {\n          break\n        }\n\n        // append byte and try to decode\n        lengthBuffer.append(buf)\n\n        try {\n          dataLength = decodeLength(lengthBuffer)\n        } catch (err) {\n          if (err instanceof RangeError) {\n            continue\n          }\n\n          throw err\n        }\n\n        if (dataLength < 0) {\n          throw new InvalidMessageLengthError('Invalid message length')\n        }\n\n        if (opts?.maxLengthLength != null && lengthBuffer.byteLength > opts.maxLengthLength) {\n          throw new InvalidDataLengthLengthError(`Message length length too long - ${lengthBuffer.byteLength} > ${opts.maxLengthLength}`)\n        }\n\n        if (dataLength > -1) {\n          break\n        }\n      }\n\n      if (opts?.maxDataLength != null && dataLength > opts.maxDataLength) {\n        throw new InvalidDataLengthError(`Message length too long - ${dataLength} > ${opts.maxDataLength}`)\n      }\n\n      const buf = await bytes.read({\n        ...options,\n        bytes: dataLength\n      })\n\n      if (buf == null) {\n        stream.log.error('tried to read %d bytes but the stream closed', dataLength)\n        throw new UnexpectedEOFError(`Unexpected EOF - tried to read ${dataLength} bytes but the stream closed`)\n      }\n\n      if (buf.byteLength !== dataLength) {\n        stream.log.error('read %d/%d bytes before the stream closed', buf.byteLength, dataLength)\n        throw new UnexpectedEOFError(`Unexpected EOF - read ${buf.byteLength}/${dataLength} bytes before the stream closed`)\n      }\n\n      return buf\n    },\n    async write (data, options?: AbortOptions) {\n      // encode, write\n      await bytes.write(new Uint8ArrayList(encodeLength(data.byteLength), data), options)\n    },\n    async writeV (data, options?: AbortOptions) {\n      const list = new Uint8ArrayList(\n        ...data.flatMap(buf => ([encodeLength(buf.byteLength), buf]))\n      )\n\n      // encode, write\n      await bytes.write(list, options)\n    },\n    unwrap () {\n      return bytes.unwrap()\n    }\n  }\n\n  return lpStream\n}\n\n/**\n * A protobuf decoder - takes a byte array and returns an object\n */\nexport interface ProtobufDecoder<T> {\n  (data: Uint8Array | Uint8ArrayList): T\n}\n\n/**\n * A protobuf encoder - takes an object and returns a byte array\n */\nexport interface ProtobufEncoder<T> {\n  (data: T): Uint8Array\n}\n\n/**\n * Convenience methods for working with protobuf streams\n */\nexport interface ProtobufStream<S extends MessageStream = MessageStream> {\n  /**\n   * Read the next length-prefixed byte array from the stream and decode it as the passed protobuf format\n   */\n  read<T>(proto: { decode: ProtobufDecoder<T> }, options?: AbortOptions): Promise<T>\n\n  /**\n   * Encode the passed object as a protobuf message and write it's length-prefixed bytes to the stream\n   */\n  write<T>(data: T, proto: { encode: ProtobufEncoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Encode the passed objects as protobuf messages and write their length-prefixed bytes to the stream as a single write\n   */\n  writeV<T>(input: T[], proto: { encode: ProtobufEncoder<T> }, options?: AbortOptions): Promise<void>\n\n  /**\n   * Returns an object with read/write methods for operating on one specific type of protobuf message\n   */\n  pb<T>(proto: { encode: ProtobufEncoder<T>, decode: ProtobufDecoder<T> }): ProtobufMessageStream<T, S>\n\n  /**\n   * Returns the underlying stream\n   */\n  unwrap(): S\n}\n\n/**\n * A message reader/writer that only uses one type of message\n */\nexport interface ProtobufMessageStream <T, S extends MessageStream = MessageStream> {\n  /**\n   * Read a message from the stream\n   */\n  read(options?: AbortOptions): Promise<T>\n\n  /**\n   * Write a message to the stream\n   */\n  write(d: T, options?: AbortOptions): Promise<void>\n\n  /**\n   * Write several messages to the stream\n   */\n  writeV(d: T[], options?: AbortOptions): Promise<void>\n\n  /**\n   * Unwrap the underlying protobuf stream\n   */\n  unwrap(): ProtobufStream<S>\n}\n\nexport interface ProtobufStreamOpts extends LengthPrefixedStreamOpts {\n\n}\n\nexport function pbStream <T extends MessageStream = Stream> (stream: T, opts?: Partial<ProtobufStreamOpts>): ProtobufStream<T> {\n  const lp = lpStream(stream, opts)\n\n  const pbStream: ProtobufStream<T> = {\n    read: async (proto, options?: AbortOptions) => {\n      // readLP, decode\n      const value = await lp.read(options)\n\n      return proto.decode(value)\n    },\n    write: async (message, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.write(proto.encode(message), options)\n    },\n    writeV: async (messages, proto, options?: AbortOptions) => {\n      // encode, writeLP\n      await lp.writeV(messages.map(message => proto.encode(message)), options)\n    },\n    pb: (proto) => {\n      return {\n        read: async (options) => pbStream.read(proto, options),\n        write: async (d, options) => pbStream.write(d, proto, options),\n        writeV: async (d, options) => pbStream.writeV(d, proto, options),\n        unwrap: () => pbStream\n      }\n    },\n    unwrap: () => {\n      return lp.unwrap()\n    }\n  }\n\n  return pbStream\n}\n\nexport async function echo (stream: MessageStream, options?: AbortOptions): Promise<void> {\n  const log = stream.log.newScope('echo')\n  const start = Date.now()\n\n  let bytes = 0\n\n  try {\n    for await (const buf of stream) {\n      bytes += buf.byteLength\n\n      if (!stream.send(buf)) {\n        stream.pause()\n\n        await pEvent(stream, 'drain', {\n          rejectionEvents: [\n            'close'\n          ],\n          ...options\n        })\n\n        stream.resume()\n      }\n    }\n\n    log('echoed %d bytes in %dms', bytes, Date.now() - start)\n\n    await stream.close(options)\n  } catch (err: any) {\n    stream.abort(err)\n  }\n}\n\nexport type PipeInput = Iterable<Uint8Array | Uint8ArrayList> | AsyncIterable<Uint8Array | Uint8ArrayList> | Stream\n\nfunction isMessageStream (obj?: any): obj is Stream {\n  return obj?.addEventListener != null\n}\n\nexport function messageStreamToDuplex (stream: Stream): Duplex<AsyncGenerator<Uint8ArrayList | Uint8Array>, Iterable<Uint8ArrayList | Uint8Array> | AsyncIterable<Uint8ArrayList | Uint8Array>, Promise<void>> {\n  const source = pushable<Uint8ArrayList | Uint8Array>()\n  let onError: PromiseWithResolvers<IteratorResult<Uint8ArrayList | Uint8Array>> | undefined\n\n  const onMessage = (evt: StreamMessageEvent): void => {\n    source.push(evt.data)\n  }\n\n  const onRemoteCloseWrite = (): void => {\n    source.end()\n\n    stream.removeEventListener('message', onMessage)\n    stream.removeEventListener('close', onClose)\n    stream.removeEventListener('remoteCloseWrite', onRemoteCloseWrite)\n  }\n\n  const onClose = (evt: StreamCloseEvent): void => {\n    source.end(evt.error)\n\n    if (evt.error != null) {\n      onError?.reject(evt.error)\n    }\n\n    stream.removeEventListener('message', onMessage)\n    stream.removeEventListener('close', onClose)\n    stream.removeEventListener('remoteCloseWrite', onRemoteCloseWrite)\n  }\n\n  stream.addEventListener('message', onMessage)\n  stream.addEventListener('close', onClose, {\n    once: true\n  })\n  stream.addEventListener('remoteCloseWrite', onRemoteCloseWrite, {\n    once: true\n  })\n\n  return {\n    source,\n    async sink (source: Source<Uint8Array | Uint8ArrayList>) {\n      async function * toGenerator (): AsyncGenerator<Uint8Array | Uint8ArrayList> {\n        yield * source\n      }\n\n      const gen = toGenerator()\n\n      while (true) {\n        onError = Promise.withResolvers<IteratorResult<Uint8ArrayList | Uint8Array>>()\n\n        const { done, value } = await Promise.race([\n          gen.next(),\n          onError.promise\n        ])\n\n        if (stream.writeStatus === 'closing' || stream.writeStatus === 'closed') {\n          break\n        }\n\n        if (value != null) {\n          if (!stream.send(value)) {\n            await Promise.race([\n              pEvent(stream, 'drain', {\n                rejectionEvents: [\n                  'close'\n                ]\n              })\n            ])\n          }\n        }\n\n        if (done === true) {\n          break\n        }\n      }\n\n      await stream.close()\n    }\n  }\n}\n\ninterface SourceFn<A = any> { (): A }\n\ntype PipeSource<A = any> =\n  Iterable<A> |\n  AsyncIterable<A> |\n  SourceFn<A> |\n  Duplex<A, any, any> |\n  MessageStream\n\ntype PipeTransform<A = any, B = any> =\n  Transform<A, B> |\n  Duplex<B, A> |\n  MessageStream\n\ntype PipeSink<A = any, B = any> =\n  Sink<A, B> |\n  Duplex<any, A, B> |\n  MessageStream\n\ntype PipeOutput<A> =\n  A extends Sink<any> ? ReturnType<A> :\n    A extends Duplex<any, any, any> ? ReturnType<A['sink']> :\n      A extends MessageStream ? Promise<void> :\n        never\n\n// single item pipe output includes pipe source types\ntype SingleItemPipeOutput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Duplex<any, any, any> ? A['source'] :\n          PipeOutput<A>\n\ntype PipeFnInput<A> =\n  A extends Iterable<any> ? A :\n    A extends AsyncIterable<any> ? A :\n      A extends SourceFn ? ReturnType<A> :\n        A extends Transform<any, any> ? ReturnType<A> :\n          A extends Duplex<any, any, any> ? A['source'] :\n            never\n\nexport function pipe<\n  A extends PipeSource\n> (\n  source: A\n): SingleItemPipeOutput<A>\n// two items, source to sink\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeSink<PipeFnInput<A>>\n> (\n  source: A,\n  sink: B\n): PipeOutput<B>\n\n// three items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeSink<PipeFnInput<B>>\n> (\n  source: A,\n  transform1: B,\n  sink: C\n): PipeOutput<C>\n\n// many items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeSink<PipeFnInput<C>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  sink: D\n): PipeOutput<D>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeSink<PipeFnInput<D>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  sink: E\n): PipeOutput<E>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeSink<PipeFnInput<E>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  sink: F\n): PipeOutput<F>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeSink<PipeFnInput<F>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  sink: G\n): PipeOutput<G>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeSink<PipeFnInput<G>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  sink: H\n): PipeOutput<H>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeSink<PipeFnInput<H>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  sink: I\n): PipeOutput<I>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeSink<PipeFnInput<I>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  sink: J\n): PipeOutput<J>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeSink<PipeFnInput<J>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  sink: K\n): PipeOutput<K>\n\n// lots of items, source to sink with transform(s) in between\nexport function pipe<\n  A extends PipeSource,\n  B extends PipeTransform<PipeFnInput<A>>,\n  C extends PipeTransform<PipeFnInput<B>>,\n  D extends PipeTransform<PipeFnInput<C>>,\n  E extends PipeTransform<PipeFnInput<D>>,\n  F extends PipeTransform<PipeFnInput<E>>,\n  G extends PipeTransform<PipeFnInput<F>>,\n  H extends PipeTransform<PipeFnInput<G>>,\n  I extends PipeTransform<PipeFnInput<H>>,\n  J extends PipeTransform<PipeFnInput<I>>,\n  K extends PipeTransform<PipeFnInput<J>>,\n  L extends PipeSink<PipeFnInput<K>>\n> (\n  source: A,\n  transform1: B,\n  transform2: C,\n  transform3: D,\n  transform4: E,\n  transform5: F,\n  transform6: G,\n  transform7: H,\n  transform8: I,\n  transform9: J,\n  transform10: K,\n  sink: L\n): PipeOutput<L>\nexport function pipe (...input: any[]): any {\n  const sources = input.map(source => {\n    if (isMessageStream(source)) {\n      return messageStreamToDuplex(source)\n    }\n\n    return source\n  })\n\n  // @ts-expect-error it-pipe types say args cannot be spread like this\n  return itPipe(...sources)\n}\n", "import { pipe } from '@libp2p/utils'\nimport { encode, decode } from 'it-length-prefixed'\nimport type { AbortOptions, Stream } from '@libp2p/interface'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\ninterface OutboundStreamOpts {\n  /** Max size in bytes for pushable buffer. If full, will throw on .push */\n  maxBufferSize?: number\n}\n\ninterface InboundStreamOpts {\n  /** Max size in bytes for reading messages from the stream */\n  maxDataLength?: number\n}\n\nexport class OutboundStream {\n  constructor (private readonly rawStream: Stream, errCallback: (e: Error) => void, opts: OutboundStreamOpts) {\n    if (opts.maxBufferSize != null) {\n      rawStream.maxWriteBufferLength = opts.maxBufferSize\n    }\n\n    rawStream.addEventListener('close', (evt) => {\n      if (evt.error != null) {\n        errCallback(evt.error)\n      }\n    })\n  }\n\n  get protocol (): string {\n    return this.rawStream.protocol\n  }\n\n  async push (data: Uint8Array): Promise<void> {\n    return this.pushPrefixed(encode.single(data))\n  }\n\n  /**\n   * Same to push() but this is prefixed data so no need to encode length prefixed again\n   */\n  pushPrefixed (data: Uint8ArrayList): void {\n    // TODO: backpressure\n    this.rawStream.send(data)\n  }\n\n  async close (options?: AbortOptions): Promise<void> {\n    await this.rawStream.close(options)\n      .catch(err => {\n        this.rawStream.abort(err)\n      })\n  }\n}\n\nexport class InboundStream {\n  public readonly source: AsyncIterable<Uint8ArrayList>\n\n  private readonly rawStream: Stream\n  private readonly closeController: AbortController\n\n  constructor (rawStream: Stream, opts: InboundStreamOpts = {}) {\n    this.rawStream = rawStream\n    this.closeController = new AbortController()\n\n    this.closeController.signal.addEventListener('abort', () => {\n      rawStream.close()\n        .catch(err => {\n          rawStream.abort(err)\n        })\n    })\n\n    this.source = pipe(\n      this.rawStream,\n      (source) => decode(source, opts)\n    )\n  }\n\n  async close (): Promise<void> {\n    this.closeController.abort()\n  }\n}\n", "import { RejectReason } from './types.js'\nimport type { Metrics } from './metrics.js'\nimport type { MsgIdStr, MsgIdToStrFn, PeerIdStr } from './types.js'\n\n/**\n * IWantTracer is an internal tracer that tracks IWANT requests in order to penalize\n * peers who don't follow up on IWANT requests after an IHAVE advertisement.\n * The tracking of promises is probabilistic to avoid using too much memory.\n *\n * Note: Do not confuse these 'promises' with JS Promise objects.\n * These 'promises' are merely expectations of a peer's behavior.\n */\nexport class IWantTracer {\n  /**\n   * Promises to deliver a message\n   * Map per message id, per peer, promise expiration time\n   */\n  private readonly promises = new Map<MsgIdStr, Map<PeerIdStr, number>>()\n  /**\n   * First request time by msgId. Used for metrics to track expire times.\n   * Necessary to know if peers are actually breaking promises or simply sending them a bit later\n   */\n  private readonly requestMsByMsg = new Map<MsgIdStr, number>()\n  private readonly requestMsByMsgExpire: number\n\n  constructor (\n    private readonly gossipsubIWantFollowupMs: number,\n    private readonly msgIdToStrFn: MsgIdToStrFn,\n    private readonly metrics: Metrics | null\n  ) {\n    this.requestMsByMsgExpire = 10 * gossipsubIWantFollowupMs\n  }\n\n  get size (): number {\n    return this.promises.size\n  }\n\n  get requestMsByMsgSize (): number {\n    return this.requestMsByMsg.size\n  }\n\n  /**\n   * Track a promise to deliver a message from a list of msgIds we are requesting\n   */\n  addPromise (from: PeerIdStr, msgIds: Uint8Array[]): void {\n    // pick msgId randomly from the list\n    const ix = Math.floor(Math.random() * msgIds.length)\n    const msgId = msgIds[ix]\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    let expireByPeer = this.promises.get(msgIdStr)\n    if (expireByPeer == null) {\n      expireByPeer = new Map()\n      this.promises.set(msgIdStr, expireByPeer)\n    }\n\n    const now = Date.now()\n\n    // If a promise for this message id and peer already exists we don't update the expiry\n    if (!expireByPeer.has(from)) {\n      expireByPeer.set(from, now + this.gossipsubIWantFollowupMs)\n\n      if (this.metrics != null) {\n        this.metrics.iwantPromiseStarted.inc(1)\n        if (!this.requestMsByMsg.has(msgIdStr)) {\n          this.requestMsByMsg.set(msgIdStr, now)\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the number of broken promises for each peer who didn't follow up on an IWANT request.\n   *\n   * This should be called not too often relative to the expire times, since it iterates over the whole data.\n   */\n  getBrokenPromises (): Map<PeerIdStr, number> {\n    const now = Date.now()\n    const result = new Map<PeerIdStr, number>()\n\n    let brokenPromises = 0\n\n    this.promises.forEach((expireByPeer, msgId) => {\n      expireByPeer.forEach((expire, p) => {\n        // the promise has been broken\n        if (expire < now) {\n          // add 1 to result\n          result.set(p, (result.get(p) ?? 0) + 1)\n          // delete from tracked promises\n          expireByPeer.delete(p)\n          // for metrics\n          brokenPromises++\n        }\n      })\n      // clean up empty promises for a msgId\n      if (expireByPeer.size === 0) {\n        this.promises.delete(msgId)\n      }\n    })\n\n    this.metrics?.iwantPromiseBroken.inc(brokenPromises)\n\n    return result\n  }\n\n  /**\n   * Someone delivered a message, stop tracking promises for it\n   */\n  deliverMessage (msgIdStr: MsgIdStr, isDuplicate = false): void {\n    this.trackMessage(msgIdStr)\n\n    const expireByPeer = this.promises.get(msgIdStr)\n\n    // Expired promise, check requestMsByMsg\n    if (expireByPeer != null) {\n      this.promises.delete(msgIdStr)\n\n      if (this.metrics != null) {\n        this.metrics.iwantPromiseResolved.inc(1)\n        if (isDuplicate) { this.metrics.iwantPromiseResolvedFromDuplicate.inc(1) }\n        this.metrics.iwantPromiseResolvedPeers.inc(expireByPeer.size)\n      }\n    }\n  }\n\n  /**\n   * A message got rejected, so we can stop tracking promises and let the score penalty apply from invalid message delivery,\n   * unless its an obviously invalid message.\n   */\n  rejectMessage (msgIdStr: MsgIdStr, reason: RejectReason): void {\n    this.trackMessage(msgIdStr)\n\n    // A message got rejected, so we can stop tracking promises and let the score penalty apply.\n    // With the expection of obvious invalid messages\n    switch (reason) {\n      case RejectReason.Error:\n        return\n      default:\n        break\n    }\n\n    this.promises.delete(msgIdStr)\n  }\n\n  clear (): void {\n    this.promises.clear()\n  }\n\n  prune (): void {\n    const maxMs = Date.now() - this.requestMsByMsgExpire\n    let count = 0\n\n    for (const [k, v] of this.requestMsByMsg.entries()) {\n      if (v < maxMs) {\n        // messages that stay too long in the requestMsByMsg map, delete\n        this.requestMsByMsg.delete(k)\n        count++\n      } else {\n        // recent messages, keep them\n        // sort by insertion order\n        break\n      }\n    }\n\n    this.metrics?.iwantMessagePruned.inc(count)\n  }\n\n  private trackMessage (msgIdStr: MsgIdStr): void {\n    if (this.metrics != null) {\n      const requestMs = this.requestMsByMsg.get(msgIdStr)\n      if (requestMs !== undefined) {\n        this.metrics.iwantPromiseDeliveryTime.observe((Date.now() - requestMs) / 1000)\n        this.requestMsByMsg.delete(msgIdStr)\n      }\n    }\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { publicKeyFromProtobuf } from '@libp2p/crypto/keys'\nimport { peerIdFromMultihash } from '@libp2p/peer-id'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { concat as uint8ArrayConcat } from 'uint8arrays/concat'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport { StrictSign, StrictNoSign } from '../index.ts'\nimport { RPC } from '../message/rpc.js'\nimport { PublishConfigType, ValidateError } from '../types.js'\nimport type { Message } from '../index.ts'\nimport type { PublishConfig, TopicStr } from '../types.js'\nimport type { PublicKey, PeerId } from '@libp2p/interface'\n\nexport const SignPrefix = uint8ArrayFromString('libp2p-pubsub:')\n\nexport interface RawMessageAndMessage {\n  raw: RPC.Message\n  msg: Message\n}\n\nexport async function buildRawMessage (\n  publishConfig: PublishConfig,\n  topic: TopicStr,\n  originalData: Uint8Array,\n  transformedData: Uint8Array\n): Promise<RawMessageAndMessage> {\n  switch (publishConfig.type) {\n    case PublishConfigType.Signing: {\n      const rpcMsg: RPC.Message = {\n        from: publishConfig.author.toMultihash().bytes,\n        data: transformedData,\n        seqno: randomBytes(8),\n        topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsg)])\n\n      rpcMsg.signature = await publishConfig.privateKey.sign(bytes)\n      rpcMsg.key = publishConfig.key\n\n      const msg: Message = {\n        type: 'signed',\n        from: publishConfig.author,\n        data: originalData,\n        sequenceNumber: BigInt(`0x${uint8ArrayToString(rpcMsg.seqno ?? new Uint8Array(0), 'base16')}`),\n        topic,\n        signature: rpcMsg.signature,\n        key: publicKeyFromProtobuf(rpcMsg.key)\n      }\n      return {\n        raw: rpcMsg,\n        msg\n      }\n    }\n\n    case PublishConfigType.Anonymous: {\n      return {\n        raw: {\n          from: undefined,\n          data: transformedData,\n          seqno: undefined,\n          topic,\n          signature: undefined,\n          key: undefined\n        },\n        msg: {\n          type: 'unsigned',\n          data: originalData,\n          topic\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unreachable')\n  }\n}\n\nexport type ValidationResult = { valid: true, message: Message } | { valid: false, error: ValidateError }\n\nexport async function validateToRawMessage (\n  signaturePolicy: typeof StrictNoSign | typeof StrictSign,\n  msg: RPC.Message\n): Promise<ValidationResult> {\n  // If strict-sign, verify all\n  // If anonymous (no-sign), ensure no preven\n\n  switch (signaturePolicy) {\n    case StrictNoSign:\n      if (msg.signature != null) { return { valid: false, error: ValidateError.SignaturePresent } }\n      if (msg.seqno != null) { return { valid: false, error: ValidateError.SeqnoPresent } }\n      if (msg.key != null) { return { valid: false, error: ValidateError.FromPresent } }\n\n      return { valid: true, message: { type: 'unsigned', topic: msg.topic, data: msg.data ?? new Uint8Array(0) } }\n\n    case StrictSign: {\n      // Verify seqno\n      if (msg.seqno == null) { return { valid: false, error: ValidateError.InvalidSeqno } }\n      if (msg.seqno.length !== 8) {\n        return { valid: false, error: ValidateError.InvalidSeqno }\n      }\n\n      if (msg.signature == null) { return { valid: false, error: ValidateError.InvalidSignature } }\n      if (msg.from == null) { return { valid: false, error: ValidateError.InvalidPeerId } }\n\n      let fromPeerId: PeerId\n      try {\n        // TODO: Fix PeerId types\n        fromPeerId = peerIdFromMultihash(Digest.decode(msg.from))\n      } catch (e) {\n        return { valid: false, error: ValidateError.InvalidPeerId }\n      }\n\n      // - check from defined\n      // - transform source to PeerId\n      // - parse signature\n      // - get .key, else from source\n      // - check key == source if present\n      // - verify sig\n\n      let publicKey: PublicKey\n      if (msg.key != null) {\n        publicKey = publicKeyFromProtobuf(msg.key)\n        // TODO: Should `fromPeerId.pubKey` be optional?\n        if (fromPeerId.publicKey !== undefined && !publicKey.equals(fromPeerId.publicKey)) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n      } else {\n        if (fromPeerId.publicKey == null) {\n          return { valid: false, error: ValidateError.InvalidPeerId }\n        }\n        publicKey = fromPeerId.publicKey\n      }\n\n      const rpcMsgPreSign: RPC.Message = {\n        from: msg.from,\n        data: msg.data,\n        seqno: msg.seqno,\n        topic: msg.topic,\n        signature: undefined, // Exclude signature field for signing\n        key: undefined // Exclude key field for signing\n      }\n\n      // Get the message in bytes, and prepend with the pubsub prefix\n      // the signature is over the bytes \"libp2p-pubsub:<protobuf-message>\"\n      const bytes = uint8ArrayConcat([SignPrefix, RPC.Message.encode(rpcMsgPreSign)])\n\n      if (!(await publicKey.verify(bytes, msg.signature))) {\n        return { valid: false, error: ValidateError.InvalidSignature }\n      }\n\n      return {\n        valid: true,\n        message: {\n          type: 'signed',\n          from: fromPeerId,\n          data: msg.data ?? new Uint8Array(0),\n          sequenceNumber: BigInt(`0x${uint8ArrayToString(msg.seqno, 'base16')}`),\n          topic: msg.topic,\n          signature: msg.signature,\n          key: msg.key != null ? publicKeyFromProtobuf(msg.key) : publicKey\n        }\n      }\n    }\n\n    default:\n      throw new Error('Unreachable')\n  }\n}\n", "import type { RPC } from '../message/rpc.js'\n\n/**\n * Create a gossipsub RPC object\n */\nexport function createGossipRpc (messages: RPC.Message[] = [], control?: Partial<RPC.ControlMessage>): RPC {\n  return {\n    subscriptions: [],\n    messages,\n    control: control !== undefined\n      ? {\n          graft: control.graft ?? [],\n          prune: control.prune ?? [],\n          ihave: control.ihave ?? [],\n          iwant: control.iwant ?? [],\n          idontwant: control.idontwant ?? []\n        }\n      : undefined\n  }\n}\n\nexport function ensureControl (rpc: RPC): Required<RPC> {\n  if (rpc.control === undefined) {\n    rpc.control = {\n      graft: [],\n      prune: [],\n      ihave: [],\n      iwant: [],\n      idontwant: []\n    }\n  }\n\n  return rpc as Required<RPC>\n}\n", "/**\n * Pseudo-randomly shuffles an array\n *\n * Mutates the input array\n */\nexport function shuffle<T> (arr: T[]): T[] {\n  if (arr.length <= 1) {\n    return arr\n  }\n  const randInt = (): number => {\n    return Math.floor(Math.random() * Math.floor(arr.length))\n  }\n\n  for (let i = 0; i < arr.length; i++) {\n    const j = randInt()\n    const tmp = arr[i]\n    arr[i] = arr[j]\n    arr[j] = tmp\n  }\n  return arr\n}\n", "import { toString } from 'uint8arrays/to-string'\n\n/**\n * Browser friendly function to convert Uint8Array message id to base64 string.\n */\nexport function messageIdToString (msgId: Uint8Array): string {\n  return toString(msgId, 'base64')\n}\n", "import { publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { StrictSign, StrictNoSign } from '../index.ts'\nimport { PublishConfigType } from '../types.js'\nimport type { PublishConfig } from '../types.js'\nimport type { PeerId, PrivateKey } from '@libp2p/interface'\n\n/**\n * Prepare a PublishConfig object from a PeerId.\n */\nexport function getPublishConfigFromPeerId (\n  signaturePolicy: typeof StrictSign | typeof StrictNoSign,\n  peerId: PeerId,\n  privateKey: PrivateKey\n): PublishConfig {\n  switch (signaturePolicy) {\n    case StrictSign: {\n      return {\n        type: PublishConfigType.Signing,\n        author: peerId,\n        key: publicKeyToProtobuf(privateKey.publicKey),\n        privateKey\n      }\n    }\n\n    case StrictNoSign:\n      return {\n        type: PublishConfigType.Anonymous\n      }\n\n    default:\n      throw new Error(`Unknown signature policy \"${signaturePolicy}\"`)\n  }\n}\n", "import { randomBytes } from '@libp2p/crypto'\nimport { publicKeyFromProtobuf, publicKeyToProtobuf } from '@libp2p/crypto/keys'\nimport { InvalidMessageError } from '@libp2p/interface'\nimport { peerIdFromMultihash, peerIdFromPublicKey } from '@libp2p/peer-id'\nimport * as Digest from 'multiformats/hashes/digest'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport { fromString as uint8ArrayFromString } from 'uint8arrays/from-string'\nimport { toString as uint8ArrayToString } from 'uint8arrays/to-string'\nimport type { Message, PubSubRPCMessage, PublicKey } from '@libp2p/interface'\n\n/**\n * Generate a random sequence number\n */\nexport function randomSeqno (): bigint {\n  return BigInt(`0x${uint8ArrayToString(randomBytes(8), 'base16')}`)\n}\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport const msgId = (key: PublicKey, seqno: bigint): Uint8Array => {\n  const seqnoBytes = uint8ArrayFromString(seqno.toString(16).padStart(16, '0'), 'base16')\n  const keyBytes = publicKeyToProtobuf(key)\n\n  const msgId = new Uint8Array(keyBytes.byteLength + seqnoBytes.length)\n  msgId.set(keyBytes, 0)\n  msgId.set(seqnoBytes, keyBytes.byteLength)\n\n  return msgId\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport const noSignMsgId = (data: Uint8Array): Uint8Array | Promise<Uint8Array> => {\n  return sha256.encode(data)\n}\n\n/**\n * Check if any member of the first set is also a member\n * of the second set\n */\nexport const anyMatch = (a: Set<number> | number[], b: Set<number> | number[]): boolean => {\n  let bHas\n  if (Array.isArray(b)) {\n    bHas = (val: number) => b.includes(val)\n  } else {\n    bHas = (val: number) => b.has(val)\n  }\n\n  for (const val of a) {\n    if (bHas(val)) {\n      return true\n    }\n  }\n\n  return false\n}\n\n/**\n * Make everything an array\n */\nexport const ensureArray = function <T> (maybeArray: T | T[]): T[] {\n  if (!Array.isArray(maybeArray)) {\n    return [maybeArray]\n  }\n\n  return maybeArray\n}\n\nconst isSigned = async (message: PubSubRPCMessage): Promise<boolean> => {\n  if ((message.sequenceNumber == null) || (message.from == null) || (message.signature == null)) {\n    return false\n  }\n  // if a public key is present in the `from` field, the message should be signed\n  const fromID = peerIdFromMultihash(Digest.decode(message.from))\n  if (fromID.publicKey != null) {\n    return true\n  }\n\n  if (message.key != null) {\n    const signingKey = message.key\n    const signingID = peerIdFromPublicKey(publicKeyFromProtobuf(signingKey))\n\n    return signingID.equals(fromID)\n  }\n\n  return false\n}\n\nexport const toMessage = async (message: PubSubRPCMessage): Promise<Message> => {\n  if (message.from == null) {\n    throw new InvalidMessageError('RPC message was missing from')\n  }\n\n  if (!await isSigned(message)) {\n    return {\n      type: 'unsigned',\n      topic: message.topic ?? '',\n      data: message.data ?? new Uint8Array(0)\n    }\n  }\n\n  const from = peerIdFromMultihash(Digest.decode(message.from))\n  const key = message.key ?? from.publicKey\n\n  if (key == null) {\n    throw new InvalidMessageError('RPC message was missing public key')\n  }\n\n  const msg: Message = {\n    type: 'signed',\n    from,\n    topic: message.topic ?? '',\n    sequenceNumber: bigIntFromBytes(message.sequenceNumber ?? new Uint8Array(0)),\n    data: message.data ?? new Uint8Array(0),\n    signature: message.signature ?? new Uint8Array(0),\n    key: key instanceof Uint8Array ? publicKeyFromProtobuf(key) : key\n  }\n\n  return msg\n}\n\nexport const toRpcMessage = (message: Message): PubSubRPCMessage => {\n  if (message.type === 'signed') {\n    return {\n      from: message.from.toMultihash().bytes,\n      data: message.data,\n      sequenceNumber: bigIntToBytes(message.sequenceNumber),\n      topic: message.topic,\n      signature: message.signature,\n\n      key: message.key ? publicKeyToProtobuf(message.key) : undefined\n    }\n  }\n\n  return {\n    data: message.data,\n    topic: message.topic\n  }\n}\n\nexport const bigIntToBytes = (num: bigint): Uint8Array => {\n  let str = num.toString(16)\n\n  if (str.length % 2 !== 0) {\n    str = `0${str}`\n  }\n\n  return uint8ArrayFromString(str, 'base16')\n}\n\nexport const bigIntFromBytes = (num: Uint8Array): bigint => {\n  return BigInt(`0x${uint8ArrayToString(num, 'base16')}`)\n}\n", "import { msgId } from '@libp2p/pubsub/utils'\nimport { sha256 } from 'multiformats/hashes/sha2'\nimport type { Message } from '../index.js'\n\n/**\n * Generate a message id, based on the `key` and `seqno`\n */\nexport function msgIdFnStrictSign (msg: Message): Uint8Array {\n  if (msg.type !== 'signed') {\n    throw new Error('expected signed message type')\n  }\n  // Should never happen\n  if (msg.sequenceNumber == null) { throw Error('missing seqno field') }\n\n  // TODO: Should use .from here or key?\n  return msgId(msg.from.publicKey ?? msg.key, msg.sequenceNumber)\n}\n\n/**\n * Generate a message id, based on message `data`\n */\nexport async function msgIdFnStrictNoSign (msg: Message): Promise<Uint8Array> {\n  return sha256.encode(msg.data)\n}\n", "import { getNetConfig, isNetworkAddress } from '@libp2p/utils'\nimport type { Multiaddr } from '@multiformats/multiaddr'\n\nexport function multiaddrToIPStr (multiaddr: Multiaddr): string | null {\n  if (isNetworkAddress(multiaddr)) {\n    const config = getNetConfig(multiaddr)\n\n    switch (config.type) {\n      case 'ip4':\n      case 'ip6':\n\n        return config.host\n      default:\n        break\n    }\n  }\n\n  return null\n}\n", "interface SimpleTimeCacheOpts {\n  validityMs: number\n}\n\ninterface CacheValue<T> {\n  value: T\n  validUntilMs: number\n}\n\n/**\n * This is similar to https://github.com/daviddias/time-cache/blob/master/src/index.js\n * for our own need, we don't use lodash throttle to improve performance.\n * This gives 4x - 5x performance gain compared to npm TimeCache\n */\nexport class SimpleTimeCache<T> {\n  private readonly entries = new Map<string | number, CacheValue<T>>()\n  private readonly validityMs: number\n\n  constructor (opts: SimpleTimeCacheOpts) {\n    this.validityMs = opts.validityMs\n\n    // allow negative validityMs so that this does not cache anything, spec test compliance.spec.js\n    // sends duplicate messages and expect peer to receive all. Application likely uses positive validityMs\n  }\n\n  get size (): number {\n    return this.entries.size\n  }\n\n  /** Returns true if there was a key collision and the entry is dropped */\n  put (key: string | number, value: T): boolean {\n    if (this.entries.has(key)) {\n      // Key collisions break insertion order in the entries cache, which break prune logic.\n      // prune relies on each iterated entry to have strictly ascending validUntilMs, else it\n      // won't prune expired entries and SimpleTimeCache will grow unexpectedly.\n      // As of Oct 2022 NodeJS v16, inserting the same key twice with different value does not\n      // change the key position in the iterator stream. A unit test asserts this behaviour.\n      return true\n    }\n\n    this.entries.set(key, { value, validUntilMs: Date.now() + this.validityMs })\n    return false\n  }\n\n  prune (): void {\n    const now = Date.now()\n\n    for (const [k, v] of this.entries.entries()) {\n      if (v.validUntilMs < now) {\n        this.entries.delete(k)\n      } else {\n        // Entries are inserted with strictly ascending validUntilMs.\n        // Stop early to save iterations\n        break\n      }\n    }\n  }\n\n  has (key: string): boolean {\n    return this.entries.has(key)\n  }\n\n  get (key: string | number): T | undefined {\n    const value = this.entries.get(key)\n    return (value != null) && value.validUntilMs >= Date.now() ? value.value : undefined\n  }\n\n  clear (): void {\n    this.entries.clear()\n  }\n}\n", "import { TypedEventEmitter, serviceCapabilities, serviceDependencies } from '@libp2p/interface'\nimport { peerIdFromMultihash, peerIdFromString } from '@libp2p/peer-id'\nimport { encode } from 'it-length-prefixed'\nimport { pipe } from 'it-pipe'\nimport { pushable } from 'it-pushable'\nimport * as Digest from 'multiformats/hashes/digest'\nimport * as constants from './constants.js'\nimport {\n  ACCEPT_FROM_WHITELIST_DURATION_MS,\n  ACCEPT_FROM_WHITELIST_MAX_MESSAGES,\n  ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE,\n  BACKOFF_SLACK\n} from './constants.js'\nimport { StrictNoSign, StrictSign, TopicValidatorResult } from './index.ts'\nimport { defaultDecodeRpcLimits } from './message/decodeRpc.js'\nimport { RPC } from './message/rpc.js'\nimport { MessageCache } from './message-cache.js'\nimport {\n  ChurnReason,\n  getMetrics,\n  IHaveIgnoreReason,\n  InclusionReason,\n\n  ScorePenalty\n\n} from './metrics.js'\nimport {\n  PeerScore,\n\n  createPeerScoreParams,\n  createPeerScoreThresholds\n\n} from './score/index.js'\nimport { computeAllPeersScoreWeights } from './score/scoreMetrics.js'\nimport { InboundStream, OutboundStream } from './stream.js'\nimport { IWantTracer } from './tracer.js'\nimport {\n\n  ValidateError,\n\n  MessageStatus,\n  RejectReason,\n\n  rejectReasonFromAcceptance\n\n} from './types.js'\nimport { buildRawMessage, validateToRawMessage } from './utils/buildRawMessage.js'\nimport { createGossipRpc, ensureControl } from './utils/create-gossip-rpc.js'\nimport { shuffle, messageIdToString } from './utils/index.js'\nimport { msgIdFnStrictNoSign, msgIdFnStrictSign } from './utils/msgIdFn.js'\nimport { multiaddrToIPStr } from './utils/multiaddr.js'\nimport { getPublishConfigFromPeerId } from './utils/publishConfig.js'\nimport { removeFirstNItemsFromSet, removeItemsFromSet } from './utils/set.js'\nimport { SimpleTimeCache } from './utils/time-cache.js'\nimport type { GossipSubComponents, GossipSubEvents, GossipsubMessage, GossipsubOpts, MeshPeer, Message, PublishResult, SubscriptionChangeData, TopicValidatorFn } from './index.ts'\nimport type { DecodeRPCLimits } from './message/decodeRpc.js'\nimport type { MessageCacheRecord } from './message-cache.js'\nimport type { Metrics, ToSendGroupCount } from './metrics.js'\nimport type { PeerScoreParams, PeerScoreThresholds, PeerScoreStatsDump } from './score/index.js'\nimport type { MsgIdFn, PublishConfig, TopicStr, MsgIdStr, PeerIdStr, RejectReasonObj, FastMsgIdFn, DataTransform, MsgIdToStrFn, MessageId, PublishOpts } from './types.js'\nimport type {\n  Connection, Stream, PeerId, Peer,\n  Logger,\n  Topology,\n  TypedEventTarget,\n  MessageStreamDirection\n} from '@libp2p/interface'\nimport type { Multiaddr } from '@multiformats/multiaddr'\nimport type { Uint8ArrayList } from 'uint8arraylist'\n\nenum GossipStatusCode {\n  started,\n  stopped\n}\n\ntype GossipStatus =\n  | {\n    code: GossipStatusCode.started\n    registrarTopologyIds: string[]\n    heartbeatTimeout: ReturnType<typeof setTimeout>\n    hearbeatStartMs: number\n  }\n  | {\n    code: GossipStatusCode.stopped\n  }\n\ninterface GossipOptions extends GossipsubOpts {\n  scoreParams: PeerScoreParams\n  scoreThresholds: PeerScoreThresholds\n}\n\ninterface AcceptFromWhitelistEntry {\n  /** number of messages accepted since recomputing the peer's score */\n  messagesAccepted: number\n  /** have to recompute score after this time */\n  acceptUntil: number\n}\n\ntype ReceivedMessageResult =\n  | { code: MessageStatus.duplicate, msgIdStr: MsgIdStr }\n  | ({ code: MessageStatus.invalid, msgIdStr?: MsgIdStr } & RejectReasonObj)\n  | { code: MessageStatus.valid, messageId: MessageId, msg: Message }\n\nexport class GossipSub extends TypedEventEmitter<GossipSubEvents> implements TypedEventTarget<GossipSubEvents> {\n  /**\n   * The signature policy to follow by default\n   */\n  public readonly globalSignaturePolicy: typeof StrictSign | typeof StrictNoSign\n  public protocols: string[] = [constants.GossipsubIDv12, constants.GossipsubIDv11, constants.GossipsubIDv10]\n\n  private publishConfig: PublishConfig | undefined\n\n  private readonly dataTransform: DataTransform | undefined\n\n  // State\n\n  public readonly peers = new Map<PeerIdStr, PeerId>()\n  public readonly streamsInbound = new Map<PeerIdStr, InboundStream>()\n  public readonly streamsOutbound = new Map<PeerIdStr, OutboundStream>()\n\n  /** Ensures outbound streams are created sequentially */\n  private outboundInflightQueue = pushable<{ peerId: PeerId, connection: Connection }>({ objectMode: true })\n\n  /** Direct peers */\n  public readonly direct = new Set<PeerIdStr>()\n\n  /** Floodsub peers */\n  private readonly floodsubPeers = new Set<PeerIdStr>()\n\n  /** Cache of seen messages */\n  private readonly seenCache: SimpleTimeCache<void>\n\n  /**\n   * Map of peer id and AcceptRequestWhileListEntry\n   */\n  private readonly acceptFromWhitelist = new Map<PeerIdStr, AcceptFromWhitelistEntry>()\n\n  /**\n   * Map of topics to which peers are subscribed to\n   */\n  private readonly topics = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * List of our subscriptions\n   */\n  private readonly subscriptions = new Set<TopicStr>()\n\n  /**\n   * Map of topic meshes\n   * topic => peer id set\n   */\n  public readonly mesh = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of topics to set of peers. These mesh peers are the ones to which we are publishing without a topic membership\n   * topic => peer id set\n   */\n  public readonly fanout = new Map<TopicStr, Set<PeerIdStr>>()\n\n  /**\n   * Map of last publish time for fanout topics\n   * topic => last publish time\n   */\n  private readonly fanoutLastpub = new Map<TopicStr, number>()\n\n  /**\n   * Map of pending messages to gossip\n   * peer id => control messages\n   */\n  public readonly gossip = new Map<PeerIdStr, RPC.ControlIHave[]>()\n\n  /**\n   * Map of control messages\n   * peer id => control message\n   */\n  public readonly control = new Map<PeerIdStr, RPC.ControlMessage>()\n\n  /**\n   * Number of IHAVEs received from peer in the last heartbeat\n   */\n  private readonly peerhave = new Map<PeerIdStr, number>()\n\n  /** Number of messages we have asked from peer in the last heartbeat */\n  private readonly iasked = new Map<PeerIdStr, number>()\n\n  /** Prune backoff map */\n  private readonly backoff = new Map<TopicStr, Map<PeerIdStr, number>>()\n\n  /**\n   * Connection direction cache, marks peers with outbound connections\n   * peer id => direction\n   */\n  private readonly outbound = new Map<PeerIdStr, boolean>()\n  private readonly msgIdFn: MsgIdFn\n\n  /**\n   * A fast message id function used for internal message de-duplication\n   */\n  private readonly fastMsgIdFn: FastMsgIdFn | undefined\n\n  private readonly msgIdToStrFn: MsgIdToStrFn\n\n  /** Maps fast message-id to canonical message-id */\n  private readonly fastMsgIdCache: SimpleTimeCache<MsgIdStr> | undefined\n\n  /**\n   * Short term cache for published message ids. This is used for penalizing peers sending\n   * our own messages back if the messages are anonymous or use a random author.\n   */\n  private readonly publishedMessageIds: SimpleTimeCache<void>\n\n  /**\n   * A message cache that contains the messages for last few heartbeat ticks\n   */\n  private readonly mcache: MessageCache\n\n  /** Peer score tracking */\n  public readonly score: PeerScore\n\n  /**\n   * Custom validator function per topic.\n   * Must return or resolve quickly (< 100ms) to prevent causing penalties for late messages.\n   * If you need to apply validation that may require longer times use `asyncValidation` option and callback the\n   * validation result through `Gossipsub.reportValidationResult`\n   */\n  public readonly topicValidators = new Map<TopicStr, TopicValidatorFn>()\n\n  /**\n   * Make this protected so child class may want to redirect to its own log.\n   */\n  protected readonly log: Logger\n\n  /**\n   * Number of heartbeats since the beginning of time\n   * This allows us to amortize some resource cleanup -- eg: backoff cleanup\n   */\n  private heartbeatTicks = 0\n\n  /**\n   * Tracks IHAVE/IWANT promises broken by peers\n   */\n  readonly gossipTracer: IWantTracer\n\n  /**\n   * Tracks IDONTWANT messages received by peers in the current heartbeat\n   */\n  private readonly idontwantCounts = new Map<PeerIdStr, number>()\n\n  /**\n   * Tracks IDONTWANT messages received by peers and the heartbeat they were received in\n   *\n   * idontwants are stored for `mcacheLength` heartbeats before being pruned,\n   * so this map is bounded by peerCount * idontwantMaxMessages * mcacheLength\n   */\n  private readonly idontwants = new Map<PeerIdStr, Map<MsgIdStr, number>>()\n\n  private readonly components: GossipSubComponents\n\n  private directPeerInitial: ReturnType<typeof setTimeout> | null = null\n\n  public static multicodec: string = constants.GossipsubIDv12\n\n  // Options\n  readonly opts: Required<GossipOptions>\n  private readonly decodeRpcLimits: DecodeRPCLimits\n\n  private readonly metrics: Metrics | null\n  private status: GossipStatus = { code: GossipStatusCode.stopped }\n  private readonly maxInboundStreams?: number\n  private readonly maxOutboundStreams?: number\n  private readonly runOnLimitedConnection?: boolean\n  private readonly allowedTopics: Set<TopicStr> | null\n\n  private heartbeatTimer: {\n    _intervalId: ReturnType<typeof setInterval> | undefined\n    runPeriodically(fn: () => void, period: number): void\n    cancel(): void\n  } | null = null\n\n  constructor (components: GossipSubComponents, options: Partial<GossipsubOpts> = {}) {\n    super()\n\n    const opts = {\n      fallbackToFloodsub: true,\n      floodPublish: true,\n      batchPublish: false,\n      tagMeshPeers: true,\n      doPX: false,\n      directPeers: [],\n      D: constants.GossipsubD,\n      Dlo: constants.GossipsubDlo,\n      Dhi: constants.GossipsubDhi,\n      Dscore: constants.GossipsubDscore,\n      Dout: constants.GossipsubDout,\n      Dlazy: constants.GossipsubDlazy,\n      heartbeatInterval: constants.GossipsubHeartbeatInterval,\n      fanoutTTL: constants.GossipsubFanoutTTL,\n      mcacheLength: constants.GossipsubHistoryLength,\n      mcacheGossip: constants.GossipsubHistoryGossip,\n      seenTTL: constants.GossipsubSeenTTL,\n      gossipsubIWantFollowupMs: constants.GossipsubIWantFollowupTime,\n      prunePeers: constants.GossipsubPrunePeers,\n      pruneBackoff: constants.GossipsubPruneBackoff,\n      unsubcribeBackoff: constants.GossipsubUnsubscribeBackoff,\n      graftFloodThreshold: constants.GossipsubGraftFloodThreshold,\n      opportunisticGraftPeers: constants.GossipsubOpportunisticGraftPeers,\n      opportunisticGraftTicks: constants.GossipsubOpportunisticGraftTicks,\n      directConnectTicks: constants.GossipsubDirectConnectTicks,\n      gossipFactor: constants.GossipsubGossipFactor,\n      idontwantMinDataSize: constants.GossipsubIdontwantMinDataSize,\n      idontwantMaxMessages: constants.GossipsubIdontwantMaxMessages,\n      ...options,\n      scoreParams: createPeerScoreParams(options.scoreParams),\n      scoreThresholds: createPeerScoreThresholds(options.scoreThresholds)\n    }\n\n    this.components = components\n    this.decodeRpcLimits = opts.decodeRpcLimits ?? defaultDecodeRpcLimits\n\n    this.globalSignaturePolicy = opts.globalSignaturePolicy ?? StrictSign\n\n    // Also wants to get notified of peers connected using floodsub\n    if (opts.fallbackToFloodsub) {\n      this.protocols.push(constants.FloodsubID)\n    }\n\n    // From pubsub\n    this.log = components.logger.forComponent(opts.debugName ?? 'libp2p:gossipsub')\n\n    // Gossipsub\n\n    this.opts = opts as Required<GossipOptions>\n    this.direct = new Set(opts.directPeers.map((p) => p.id.toString()))\n    this.seenCache = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n    this.publishedMessageIds = new SimpleTimeCache<void>({ validityMs: opts.seenTTL })\n\n    if (options.msgIdFn != null) {\n      // Use custom function\n      this.msgIdFn = options.msgIdFn\n    } else {\n      switch (this.globalSignaturePolicy) {\n        case StrictSign:\n          this.msgIdFn = msgIdFnStrictSign\n          break\n        case StrictNoSign:\n          this.msgIdFn = msgIdFnStrictNoSign\n          break\n        default:\n          throw new Error(`Invalid globalSignaturePolicy: ${this.globalSignaturePolicy}`)\n      }\n    }\n\n    if (options.fastMsgIdFn != null) {\n      this.fastMsgIdFn = options.fastMsgIdFn\n      this.fastMsgIdCache = new SimpleTimeCache<MsgIdStr>({ validityMs: opts.seenTTL })\n    }\n\n    // By default, gossipsub only provide a browser friendly function to convert Uint8Array message id to string.\n    this.msgIdToStrFn = options.msgIdToStrFn ?? messageIdToString\n\n    this.mcache = options.messageCache ?? new MessageCache(opts.mcacheGossip, opts.mcacheLength, this.msgIdToStrFn)\n\n    if (options.dataTransform != null) {\n      this.dataTransform = options.dataTransform\n    }\n\n    if (options.metricsRegister != null) {\n      if (options.metricsTopicStrToLabel == null) {\n        throw Error('Must set metricsTopicStrToLabel with metrics')\n      }\n\n      // in theory, each topic has its own meshMessageDeliveriesWindow param\n      // however in lodestar, we configure it mostly the same so just pick the max of positive ones\n      // (some topics have meshMessageDeliveriesWindow as 0)\n      const maxMeshMessageDeliveriesWindowMs = Math.max(\n        ...Object.values(opts.scoreParams.topics).map((topicParam) => topicParam.meshMessageDeliveriesWindow),\n        constants.DEFAULT_METRIC_MESH_MESSAGE_DELIVERIES_WINDOWS\n      )\n\n      const metrics = getMetrics(options.metricsRegister, options.metricsTopicStrToLabel, {\n        gossipPromiseExpireSec: this.opts.gossipsubIWantFollowupMs / 1000,\n        behaviourPenaltyThreshold: opts.scoreParams.behaviourPenaltyThreshold,\n        maxMeshMessageDeliveriesWindowSec: maxMeshMessageDeliveriesWindowMs / 1000\n      })\n\n      metrics.mcacheSize.addCollect(() => { this.onScrapeMetrics(metrics) })\n      for (const protocol of this.protocols) {\n        metrics.protocolsEnabled.set({ protocol }, 1)\n      }\n\n      this.metrics = metrics\n    } else {\n      this.metrics = null\n    }\n\n    this.gossipTracer = new IWantTracer(this.opts.gossipsubIWantFollowupMs, this.msgIdToStrFn, this.metrics)\n\n    /**\n     * libp2p\n     */\n    this.score = new PeerScore(this.opts.scoreParams, this.metrics, this.components.logger, {\n      scoreCacheValidityMs: opts.heartbeatInterval\n    })\n\n    this.maxInboundStreams = options.maxInboundStreams\n    this.maxOutboundStreams = options.maxOutboundStreams\n    this.runOnLimitedConnection = options.runOnLimitedConnection\n\n    this.allowedTopics = (opts.allowedTopics != null) ? new Set(opts.allowedTopics) : null\n  }\n\n  readonly [Symbol.toStringTag] = '@chainsafe/libp2p-gossipsub'\n\n  readonly [serviceCapabilities]: string[] = [\n    '@libp2p/pubsub'\n  ]\n\n  readonly [serviceDependencies]: string[] = [\n    '@libp2p/identify'\n  ]\n\n  getPeers (): PeerId[] {\n    return [...this.peers.values()]\n  }\n\n  isStarted (): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  // LIFECYCLE METHODS\n\n  /**\n   * Mounts the gossipsub protocol onto the libp2p node and sends our\n   * our subscriptions to every peer connected\n   */\n  async start (): Promise<void> {\n    // From pubsub\n    if (this.isStarted()) {\n      return\n    }\n\n    this.log('starting')\n\n    this.publishConfig = getPublishConfigFromPeerId(this.globalSignaturePolicy, this.components.peerId, this.components.privateKey)\n\n    // Create the outbound inflight queue\n    // This ensures that outbound stream creation happens sequentially\n    this.outboundInflightQueue = pushable({ objectMode: true })\n    pipe(this.outboundInflightQueue, async (source) => {\n      for await (const { peerId, connection } of source) {\n        await this.createOutboundStream(peerId, connection)\n      }\n    }).catch((e) => { this.log.error('outbound inflight queue error', e) })\n\n    // set direct peer addresses in the address book\n    await Promise.all(\n      this.opts.directPeers.map(async (p) => {\n        await this.components.peerStore.merge(p.id, {\n          multiaddrs: p.addrs\n        })\n      })\n    )\n\n    const registrar = this.components.registrar\n    // Incoming streams\n    // Called after a peer dials us\n    await Promise.all(\n      this.protocols.map(async (protocol) =>\n        registrar.handle(protocol, this.onIncomingStream.bind(this), {\n          maxInboundStreams: this.maxInboundStreams,\n          maxOutboundStreams: this.maxOutboundStreams,\n          runOnLimitedConnection: this.runOnLimitedConnection\n        })\n      )\n    )\n\n    // # How does Gossipsub interact with libp2p? Rough guide from Mar 2022\n    //\n    // ## Setup:\n    // Gossipsub requests libp2p to callback, TBD\n    //\n    // `this.libp2p.handle()` registers a handler for `/meshsub/1.1.0` and other Gossipsub protocols\n    // The handler callback is registered in libp2p Upgrader.protocols map.\n    //\n    // Upgrader receives an inbound connection from some transport and (`Upgrader.upgradeInbound`):\n    // - Adds encryption (NOISE in our case)\n    // - Multiplex stream\n    // - Create a muxer and register that for each new stream call Upgrader.protocols handler\n    //\n    // ## Topology\n    // - new instance of Topology (unlinked to libp2p) with handlers\n    // - registar.register(topology)\n\n    // register protocol with topology\n    // Topology callbacks called on connection manager changes\n    const topology: Topology = {\n      onConnect: this.onPeerConnected.bind(this),\n      onDisconnect: this.onPeerDisconnected.bind(this),\n      notifyOnLimitedConnection: this.runOnLimitedConnection\n    }\n    const registrarTopologyIds = await Promise.all(\n      this.protocols.map(async (protocol) => registrar.register(protocol, topology))\n    )\n\n    // Schedule to start heartbeat after `GossipsubHeartbeatInitialDelay`\n    const heartbeatTimeout = setTimeout(this.runHeartbeat, constants.GossipsubHeartbeatInitialDelay)\n    // Then, run heartbeat every `heartbeatInterval` offset by `GossipsubHeartbeatInitialDelay`\n\n    this.status = {\n      code: GossipStatusCode.started,\n      registrarTopologyIds,\n      heartbeatTimeout,\n      hearbeatStartMs: Date.now() + constants.GossipsubHeartbeatInitialDelay\n    }\n\n    this.score.start()\n    // connect to direct peers\n    this.directPeerInitial = setTimeout(() => {\n      Promise.resolve()\n        .then(async () => {\n          await Promise.all(Array.from(this.direct).map(async (id) => this.connect(id)))\n        })\n        .catch((err) => {\n          this.log(err)\n        })\n    }, constants.GossipsubDirectConnectInitialDelay)\n\n    if (this.opts.tagMeshPeers) {\n      this.addEventListener('gossipsub:graft', this.tagMeshPeer)\n      this.addEventListener('gossipsub:prune', this.untagMeshPeer)\n    }\n\n    this.log('started')\n  }\n\n  /**\n   * Unmounts the gossipsub protocol and shuts down every connection\n   */\n  async stop (): Promise<void> {\n    this.log('stopping')\n    // From pubsub\n\n    if (this.status.code !== GossipStatusCode.started) {\n      return\n    }\n\n    const { registrarTopologyIds } = this.status\n    this.status = { code: GossipStatusCode.stopped }\n\n    if (this.opts.tagMeshPeers) {\n      this.removeEventListener('gossipsub:graft', this.tagMeshPeer)\n      this.removeEventListener('gossipsub:prune', this.untagMeshPeer)\n    }\n\n    // unregister protocol and handlers\n    const registrar = this.components.registrar\n    await Promise.all(this.protocols.map(async (protocol) => registrar.unhandle(protocol)))\n    registrarTopologyIds.forEach((id) => { registrar.unregister(id) })\n\n    this.outboundInflightQueue.end()\n\n    const closePromises = []\n    for (const outboundStream of this.streamsOutbound.values()) {\n      closePromises.push(outboundStream.close())\n    }\n    this.streamsOutbound.clear()\n\n    for (const inboundStream of this.streamsInbound.values()) {\n      closePromises.push(inboundStream.close())\n    }\n    this.streamsInbound.clear()\n\n    await Promise.all(closePromises)\n\n    this.peers.clear()\n    this.subscriptions.clear()\n\n    // Gossipsub\n\n    if (this.heartbeatTimer != null) {\n      this.heartbeatTimer.cancel()\n      this.heartbeatTimer = null\n    }\n\n    this.score.stop()\n\n    this.mesh.clear()\n    this.fanout.clear()\n    this.fanoutLastpub.clear()\n    this.gossip.clear()\n    this.control.clear()\n    this.peerhave.clear()\n    this.iasked.clear()\n    this.backoff.clear()\n    this.outbound.clear()\n    this.gossipTracer.clear()\n    this.seenCache.clear()\n    if (this.fastMsgIdCache != null) { this.fastMsgIdCache.clear() }\n    if (this.directPeerInitial != null) { clearTimeout(this.directPeerInitial) }\n    this.idontwantCounts.clear()\n    this.idontwants.clear()\n\n    this.log('stopped')\n  }\n\n  /** FOR DEBUG ONLY - Dump peer stats for all peers. Data is cloned, safe to mutate */\n  dumpPeerScoreStats (): PeerScoreStatsDump {\n    return this.score.dumpPeerScoreStats()\n  }\n\n  /**\n   * On an inbound stream opened\n   */\n  private onIncomingStream (stream: Stream, connection: Connection): void {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const peerId = connection.remotePeer\n    // add peer to router\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    // create inbound stream\n    this.createInboundStream(peerId, stream)\n    // attempt to create outbound stream\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies an established connection with pubsub protocol\n   */\n  private onPeerConnected (peerId: PeerId, connection: Connection): void {\n    this.metrics?.newConnectionCount.inc({ status: connection.status })\n    // libp2p may emit a closed connection and never issue peer:disconnect event\n    // see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/398\n    if (!this.isStarted() || connection.status !== 'open') {\n      return\n    }\n\n    this.addPeer(peerId, connection.direction, connection.remoteAddr)\n    this.outboundInflightQueue.push({ peerId, connection })\n  }\n\n  /**\n   * Registrar notifies a closing connection with pubsub protocol\n   */\n  private onPeerDisconnected (peerId: PeerId): void {\n    this.log('connection ended %p', peerId)\n    this.removePeer(peerId)\n  }\n\n  private async createOutboundStream (peerId: PeerId, connection: Connection): Promise<void> {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for inbound streams\n    // If an outbound stream already exists, don't create a new stream\n    if (this.streamsOutbound.has(id)) {\n      return\n    }\n\n    try {\n      const stream = new OutboundStream(\n        await connection.newStream(this.protocols, {\n          runOnLimitedConnection: this.runOnLimitedConnection\n        }),\n        (e) => { this.log.error('outbound pipe error', e) },\n        { maxBufferSize: this.opts.maxOutboundBufferSize }\n      )\n\n      this.log('create outbound stream %p', peerId)\n\n      this.streamsOutbound.set(id, stream)\n\n      const protocol = stream.protocol\n      if (protocol === constants.FloodsubID) {\n        this.floodsubPeers.add(id)\n      }\n      this.metrics?.peersPerProtocol.inc({ protocol }, 1)\n\n      // Immediately send own subscriptions via the newly attached stream\n      if (this.subscriptions.size > 0) {\n        this.log('send subscriptions to', id)\n        this.sendSubscriptions(id, Array.from(this.subscriptions), true)\n      }\n    } catch (e) {\n      this.log.error('createOutboundStream error', e)\n    }\n  }\n\n  private createInboundStream (peerId: PeerId, stream: Stream): void {\n    if (!this.isStarted()) {\n      return\n    }\n\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // TODO make this behavior more robust\n    // This behavior is different than for outbound streams\n    // If a peer initiates a new inbound connection\n    // we assume that one is the new canonical inbound stream\n    const priorInboundStream = this.streamsInbound.get(id)\n    if (priorInboundStream !== undefined) {\n      this.log('replacing existing inbound steam %s', id)\n      priorInboundStream.close().catch((err) => { this.log.error(err) })\n    }\n\n    this.log('create inbound stream %s', id)\n\n    const inboundStream = new InboundStream(stream, { maxDataLength: this.opts.maxInboundDataLength })\n    this.streamsInbound.set(id, inboundStream)\n\n    this.pipePeerReadStream(peerId, inboundStream.source).catch((err) => { this.log(err) })\n  }\n\n  /**\n   * Add a peer to the router\n   */\n  private addPeer (peerId: PeerId, direction: MessageStreamDirection, addr: Multiaddr): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      this.peers.set(id, peerId)\n\n      // Add to peer scoring\n      this.score.addPeer(id)\n      const currentIP = multiaddrToIPStr(addr)\n      if (currentIP !== null) {\n        this.score.addIP(id, currentIP)\n      } else {\n        this.log('Added peer has no IP in current address %s %s', id, addr.toString())\n      }\n\n      // track the connection direction. Don't allow to unset outbound\n      if (!this.outbound.has(id)) {\n        this.outbound.set(id, direction === 'outbound')\n      }\n    }\n  }\n\n  /**\n   * Removes a peer from the router\n   */\n  private removePeer (peerId: PeerId): void {\n    const id = peerId.toString()\n\n    if (!this.peers.has(id)) {\n      return\n    }\n\n    // delete peer\n    this.log('delete peer %p', peerId)\n    this.peers.delete(id)\n\n    const outboundStream = this.streamsOutbound.get(id)\n    const inboundStream = this.streamsInbound.get(id)\n\n    if (outboundStream != null) {\n      this.metrics?.peersPerProtocol.inc({ protocol: outboundStream.protocol }, -1)\n    }\n\n    // close streams\n    outboundStream?.close().catch((err) => { this.log.error(err) })\n    inboundStream?.close().catch((err) => { this.log.error(err) })\n\n    // remove streams\n    this.streamsOutbound.delete(id)\n    this.streamsInbound.delete(id)\n\n    // remove peer from topics map\n    for (const peers of this.topics.values()) {\n      peers.delete(id)\n    }\n\n    // Remove this peer from the mesh\n    for (const [topicStr, peers] of this.mesh) {\n      if (peers.delete(id)) {\n        this.metrics?.onRemoveFromMesh(topicStr, ChurnReason.Dc, 1)\n      }\n    }\n\n    // Remove this peer from the fanout\n    for (const peers of this.fanout.values()) {\n      peers.delete(id)\n    }\n\n    // Remove from floodsubPeers\n    this.floodsubPeers.delete(id)\n    // Remove from gossip mapping\n    this.gossip.delete(id)\n    // Remove from control mapping\n    this.control.delete(id)\n    // Remove from backoff mapping\n    this.outbound.delete(id)\n    // Remove from idontwant tracking\n    this.idontwantCounts.delete(id)\n    this.idontwants.delete(id)\n\n    // Remove from peer scoring\n    this.score.removePeer(id)\n\n    this.acceptFromWhitelist.delete(id)\n  }\n\n  // API METHODS\n\n  get started (): boolean {\n    return this.status.code === GossipStatusCode.started\n  }\n\n  /**\n   * Get a the peer-ids in a topic mesh\n   */\n  getMeshPeers (topic: TopicStr): PeerIdStr[] {\n    const peersInTopic = this.mesh.get(topic)\n    return (peersInTopic != null) ? Array.from(peersInTopic) : []\n  }\n\n  /**\n   * Get a list of the peer-ids that are subscribed to one topic.\n   */\n  getSubscribers (topic: TopicStr): PeerId[] {\n    const peersInTopic = this.topics.get(topic)\n    return ((peersInTopic != null) ? Array.from(peersInTopic) : []).map((str) => this.peers.get(str) ?? peerIdFromString(str))\n  }\n\n  /**\n   * Get the list of topics which the peer is subscribed to.\n   */\n  getTopics (): TopicStr[] {\n    return Array.from(this.subscriptions)\n  }\n\n  // TODO: Reviewing Pubsub API\n\n  // MESSAGE METHODS\n\n  /**\n   * Responsible for processing each RPC message received by other peers.\n   */\n  private async pipePeerReadStream (peerId: PeerId, stream: AsyncIterable<Uint8ArrayList>): Promise<void> {\n    try {\n      await pipe(stream, async (source) => {\n        for await (const data of source) {\n          try {\n            // TODO: Check max gossip message size, before decodeRpc()\n            const rpcBytes = data.subarray()\n            // Note: This function may throw, it must be wrapped in a try {} catch {} to prevent closing the stream.\n            // TODO: What should we do if the entire RPC is invalid?\n            const rpc = RPC.decode(rpcBytes, {\n              limits: {\n                subscriptions: this.decodeRpcLimits.maxSubscriptions,\n                messages: this.decodeRpcLimits.maxMessages,\n                control$: {\n                  ihave: this.decodeRpcLimits.maxIhaveMessageIDs,\n                  iwant: this.decodeRpcLimits.maxIwantMessageIDs,\n                  graft: this.decodeRpcLimits.maxControlMessages,\n                  prune: this.decodeRpcLimits.maxControlMessages,\n                  prune$: {\n                    peers: this.decodeRpcLimits.maxPeerInfos\n                  },\n                  idontwant: this.decodeRpcLimits.maxControlMessages,\n                  idontwant$: {\n                    messageIDs: this.decodeRpcLimits.maxIdontwantMessageIDs\n                  }\n                }\n              }\n            })\n\n            this.metrics?.onRpcRecv(rpc, rpcBytes.length)\n\n            // Since processRpc may be overridden entirely in unsafe ways,\n            // the simplest/safest option here is to wrap in a function and capture all errors\n            // to prevent a top-level unhandled exception\n            // This processing of rpc messages should happen without awaiting full validation/execution of prior messages\n            if (this.opts.awaitRpcHandler) {\n              try {\n                await this.handleReceivedRpc(peerId, rpc)\n              } catch (err) {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              }\n            } else {\n              this.handleReceivedRpc(peerId, rpc).catch((err) => {\n                this.metrics?.onRpcRecvError()\n                this.log(err)\n              })\n            }\n          } catch (e) {\n            this.metrics?.onRpcDataError()\n            this.log(e as Error)\n          }\n        }\n      })\n    } catch (err) {\n      this.metrics?.onPeerReadStreamError()\n      this.handlePeerReadStreamError(err as Error, peerId)\n    }\n  }\n\n  /**\n   * Handle error when read stream pipe throws, less of the functional use but more\n   * to for testing purposes to spy on the error handling\n   */\n  private handlePeerReadStreamError (err: Error, peerId: PeerId): void {\n    this.log.error(err)\n    this.onPeerDisconnected(peerId)\n  }\n\n  /**\n   * Handles an rpc request from a peer\n   */\n  public async handleReceivedRpc (from: PeerId, rpc: RPC): Promise<void> {\n    // Check if peer is graylisted in which case we ignore the event\n    if (!this.acceptFrom(from.toString())) {\n      this.log('received message from unacceptable peer %p', from)\n      this.metrics?.rpcRecvNotAccepted.inc()\n      return\n    }\n\n    const subscriptions = (rpc.subscriptions != null) ? rpc.subscriptions.length : 0\n    const messages = (rpc.messages != null) ? rpc.messages.length : 0\n    let ihave = 0\n    let iwant = 0\n    let graft = 0\n    let prune = 0\n    if (rpc.control != null) {\n      if (rpc.control.ihave != null) { ihave = rpc.control.ihave.length }\n      if (rpc.control.iwant != null) { iwant = rpc.control.iwant.length }\n      if (rpc.control.graft != null) { graft = rpc.control.graft.length }\n      if (rpc.control.prune != null) { prune = rpc.control.prune.length }\n    }\n    this.log(\n      `rpc.from ${from.toString()} subscriptions ${subscriptions} messages ${messages} ihave ${ihave} iwant ${iwant} graft ${graft} prune ${prune}`\n    )\n\n    // Handle received subscriptions\n    if ((rpc.subscriptions != null) && rpc.subscriptions.length > 0) {\n      // update peer subscriptions\n\n      const subscriptions: Array<{ topic: TopicStr, subscribe: boolean }> = []\n\n      rpc.subscriptions.forEach((subOpt) => {\n        const topic = subOpt.topic\n        const subscribe = subOpt.subscribe === true\n\n        if (topic != null) {\n          if ((this.allowedTopics != null) && !this.allowedTopics.has(topic)) {\n            // Not allowed: subscription data-structures are not bounded by topic count\n            // TODO: Should apply behaviour penalties?\n            return\n          }\n\n          this.handleReceivedSubscription(from, topic, subscribe)\n\n          subscriptions.push({ topic, subscribe })\n        }\n      })\n\n      this.safeDispatchEvent<SubscriptionChangeData>('subscription-change', {\n        detail: { peerId: from, subscriptions }\n      })\n    }\n\n    // Handle messages\n    // TODO: (up to limit)\n    for (const message of rpc.messages) {\n      if ((this.allowedTopics != null) && !this.allowedTopics.has(message.topic)) {\n        // Not allowed: message cache data-structures are not bounded by topic count\n        // TODO: Should apply behaviour penalties?\n        continue\n      }\n\n      const handleReceivedMessagePromise = this.handleReceivedMessage(from, message)\n        // Should never throw, but handle just in case\n        .catch((err) => {\n          this.metrics?.onMsgRecvError(message.topic)\n          this.log(err)\n        })\n\n      if (this.opts.awaitRpcMessageHandler) {\n        await handleReceivedMessagePromise\n      }\n    }\n\n    // Handle control messages\n    if (rpc.control != null) {\n      await this.handleControlMessage(from.toString(), rpc.control)\n    }\n  }\n\n  /**\n   * Handles a subscription change from a peer\n   */\n  private handleReceivedSubscription (from: PeerId, topic: TopicStr, subscribe: boolean): void {\n    this.log('subscription update from %p topic %s', from, topic)\n\n    let topicSet = this.topics.get(topic)\n    if (topicSet == null) {\n      topicSet = new Set()\n      this.topics.set(topic, topicSet)\n    }\n\n    if (subscribe) {\n      // subscribe peer to new topic\n      topicSet.add(from.toString())\n    } else {\n      // unsubscribe from existing topic\n      topicSet.delete(from.toString())\n    }\n\n    // TODO: rust-libp2p has A LOT more logic here\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async handleReceivedMessage (from: PeerId, rpcMsg: RPC.Message): Promise<void> {\n    this.metrics?.onMsgRecvPreValidation(rpcMsg.topic)\n\n    const validationResult = await this.validateReceivedMessage(from, rpcMsg)\n\n    this.metrics?.onPrevalidationResult(rpcMsg.topic, validationResult.code)\n\n    const validationCode = validationResult.code\n    switch (validationCode) {\n      case MessageStatus.duplicate:\n        // Report the duplicate\n        this.score.duplicateMessage(from.toString(), validationResult.msgIdStr, rpcMsg.topic)\n        // due to the collision of fastMsgIdFn, 2 different messages may end up the same fastMsgId\n        // so we need to also mark the duplicate message as delivered or the promise is not resolved\n        // and peer gets penalized. See https://github.com/ChainSafe/js-libp2p-gossipsub/pull/385\n        this.gossipTracer.deliverMessage(validationResult.msgIdStr, true)\n        this.mcache.observeDuplicate(validationResult.msgIdStr, from.toString())\n        return\n\n      case MessageStatus.invalid:\n        // invalid messages received\n        // metrics.register_invalid_message(&raw_message.topic)\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        if (validationResult.msgIdStr != null) {\n          const msgIdStr = validationResult.msgIdStr\n          this.score.rejectMessage(from.toString(), msgIdStr, rpcMsg.topic, validationResult.reason)\n          this.gossipTracer.rejectMessage(msgIdStr, validationResult.reason)\n        } else {\n          this.score.rejectInvalidMessage(from.toString(), rpcMsg.topic)\n        }\n\n        this.metrics?.onMsgRecvInvalid(rpcMsg.topic, validationResult)\n        return\n\n      case MessageStatus.valid:\n        // Tells score that message arrived (but is maybe not fully validated yet).\n        // Consider the message as delivered for gossip promises.\n        this.score.validateMessage(validationResult.messageId.msgIdStr)\n        this.gossipTracer.deliverMessage(validationResult.messageId.msgIdStr)\n\n        // Add the message to our memcache\n        // if no validation is required, mark the message as validated\n        this.mcache.put(validationResult.messageId, rpcMsg, !this.opts.asyncValidation)\n\n        // Dispatch the message to the user if we are subscribed to the topic\n        if (this.subscriptions.has(rpcMsg.topic)) {\n          const isFromSelf = this.components.peerId.equals(from)\n\n          if (!isFromSelf || this.opts.emitSelf) {\n            super.dispatchEvent(\n              new CustomEvent<GossipsubMessage>('gossipsub:message', {\n                detail: {\n                  propagationSource: from,\n                  msgId: validationResult.messageId.msgIdStr,\n                  msg: validationResult.msg\n                }\n              })\n            )\n            // TODO: Add option to switch between emit per topic or all messages in one\n            super.dispatchEvent(new CustomEvent<Message>('message', { detail: validationResult.msg }))\n          }\n        }\n\n        // Forward the message to mesh peers, if no validation is required\n        // If asyncValidation is ON, expect the app layer to call reportMessageValidationResult(), then forward\n        if (!this.opts.asyncValidation) {\n          // TODO: in rust-libp2p\n          // .forward_msg(&msg_id, raw_message, Some(propagation_source))\n          this.forwardMessage(validationResult.messageId.msgIdStr, rpcMsg, from.toString())\n        }\n        break\n      default:\n        throw new Error(`Invalid validation result: ${validationCode}`)\n    }\n  }\n\n  /**\n   * Handles a newly received message from an RPC.\n   * May forward to all peers in the mesh.\n   */\n  private async validateReceivedMessage (\n    propagationSource: PeerId,\n    rpcMsg: RPC.Message\n  ): Promise<ReceivedMessageResult> {\n    // Fast message ID stuff\n    const fastMsgIdStr = this.fastMsgIdFn?.(rpcMsg)\n    const msgIdCached = fastMsgIdStr !== undefined ? this.fastMsgIdCache?.get(fastMsgIdStr) : undefined\n\n    if (msgIdCached != null) {\n      // This message has been seen previously. Ignore it\n      return { code: MessageStatus.duplicate, msgIdStr: msgIdCached }\n    }\n\n    // Perform basic validation on message and convert to RawGossipsubMessage for fastMsgIdFn()\n    const validationResult = await validateToRawMessage(this.globalSignaturePolicy, rpcMsg)\n\n    if (!validationResult.valid) {\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: validationResult.error }\n    }\n\n    const msg = validationResult.message\n\n    // Try and perform the data transform to the message. If it fails, consider it invalid.\n    try {\n      if (this.dataTransform != null) {\n        msg.data = this.dataTransform.inboundTransform(rpcMsg.topic, msg.data)\n      }\n    } catch (e) {\n      this.log('Invalid message, transform failed', e)\n      return { code: MessageStatus.invalid, reason: RejectReason.Error, error: ValidateError.TransformFailed }\n    }\n\n    // TODO: Check if message is from a blacklisted source or propagation origin\n    // - Reject any message from a blacklisted peer\n    // - Also reject any message that originated from a blacklisted peer\n    // - reject messages claiming to be from ourselves but not locally published\n\n    // Calculate the message id on the transformed data.\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n    const messageId = { msgId, msgIdStr }\n\n    // Add the message to the duplicate caches\n    if (fastMsgIdStr !== undefined && (this.fastMsgIdCache != null)) {\n      const collision = this.fastMsgIdCache.put(fastMsgIdStr, msgIdStr)\n      if (collision) {\n        this.metrics?.fastMsgIdCacheCollision.inc()\n      }\n    }\n\n    if (this.seenCache.has(msgIdStr)) {\n      return { code: MessageStatus.duplicate, msgIdStr }\n    } else {\n      this.seenCache.put(msgIdStr)\n    }\n\n    // possibly send IDONTWANTs to mesh peers\n    if ((rpcMsg.data?.length ?? 0) >= this.opts.idontwantMinDataSize) {\n      this.sendIDontWants(msgId, rpcMsg.topic, propagationSource.toString())\n    }\n\n    // (Optional) Provide custom validation here with dynamic validators per topic\n    // NOTE: This custom topicValidator() must resolve fast (< 100ms) to allow scores\n    // to not penalize peers for long validation times.\n    const topicValidator = this.topicValidators.get(rpcMsg.topic)\n    if (topicValidator != null) {\n      let acceptance: TopicValidatorResult\n      // Use try {} catch {} in case topicValidator() is synchronous\n      try {\n        acceptance = await topicValidator(propagationSource, msg)\n      } catch (e) {\n        const errCode = (e as { code: string }).code\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_IGNORE) { acceptance = TopicValidatorResult.Ignore }\n        if (errCode === constants.ERR_TOPIC_VALIDATOR_REJECT) { acceptance = TopicValidatorResult.Reject } else { acceptance = TopicValidatorResult.Ignore }\n      }\n\n      if (acceptance !== TopicValidatorResult.Accept) {\n        return { code: MessageStatus.invalid, reason: rejectReasonFromAcceptance(acceptance), msgIdStr }\n      }\n    }\n\n    return { code: MessageStatus.valid, messageId, msg }\n  }\n\n  /**\n   * Return score of a peer.\n   */\n  getScore (peerId: PeerIdStr): number {\n    return this.score.score(peerId)\n  }\n\n  /**\n   * Send an rpc object to a peer with subscriptions\n   */\n  private sendSubscriptions (toPeer: PeerIdStr, topics: string[], subscribe: boolean): void {\n    this.sendRpc(toPeer, {\n      subscriptions: topics.map((topic) => ({ topic, subscribe })),\n      messages: []\n    })\n  }\n\n  /**\n   * Handles an rpc control message from a peer\n   */\n  private async handleControlMessage (id: PeerIdStr, controlMsg: RPC.ControlMessage): Promise<void> {\n    if (controlMsg === undefined) {\n      return\n    }\n\n    const iwant = (controlMsg.ihave?.length > 0) ? this.handleIHave(id, controlMsg.ihave) : []\n    const ihave = (controlMsg.iwant?.length > 0) ? this.handleIWant(id, controlMsg.iwant) : []\n    const prune = (controlMsg.graft?.length > 0) ? await this.handleGraft(id, controlMsg.graft) : []\n    ;(controlMsg.prune?.length > 0) && (await this.handlePrune(id, controlMsg.prune))\n    ;(controlMsg.idontwant?.length > 0) && this.handleIdontwant(id, controlMsg.idontwant)\n\n    if ((iwant.length === 0) && (ihave.length === 0) && (prune.length === 0)) {\n      return\n    }\n\n    const sent = this.sendRpc(id, createGossipRpc(ihave, { iwant, prune }))\n    const iwantMessageIds = iwant[0]?.messageIDs\n    if (iwantMessageIds != null) {\n      if (sent) {\n        this.gossipTracer.addPromise(id, iwantMessageIds)\n      } else {\n        this.metrics?.iwantPromiseUntracked.inc(1)\n      }\n    }\n  }\n\n  /**\n   * Whether to accept a message from a peer\n   */\n  public acceptFrom (id: PeerIdStr): boolean {\n    if (this.direct.has(id)) {\n      return true\n    }\n\n    const now = Date.now()\n    const entry = this.acceptFromWhitelist.get(id)\n\n    if ((entry != null) && entry.messagesAccepted < ACCEPT_FROM_WHITELIST_MAX_MESSAGES && entry.acceptUntil >= now) {\n      entry.messagesAccepted += 1\n      return true\n    }\n\n    const score = this.score.score(id)\n    if (score >= ACCEPT_FROM_WHITELIST_THRESHOLD_SCORE) {\n      // peer is unlikely to be able to drop its score to `graylistThreshold`\n      // after 128 messages or 1s\n      this.acceptFromWhitelist.set(id, {\n        messagesAccepted: 0,\n        acceptUntil: now + ACCEPT_FROM_WHITELIST_DURATION_MS\n      })\n    } else {\n      this.acceptFromWhitelist.delete(id)\n    }\n\n    return score >= this.opts.scoreThresholds.graylistThreshold\n  }\n\n  /**\n   * Handles IHAVE messages\n   */\n  private handleIHave (id: PeerIdStr, ihave: RPC.ControlIHave[]): RPC.ControlIWant[] {\n    if (ihave.length === 0) {\n      return []\n    }\n\n    // we ignore IHAVE gossip from any peer whose score is below the gossips threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IHAVE: ignoring peer %s with score below threshold [ score = %d ]', id, score)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.LowScore })\n      return []\n    }\n\n    // IHAVE flood protection\n    const peerhave = (this.peerhave.get(id) ?? 0) + 1\n    this.peerhave.set(id, peerhave)\n    if (peerhave > constants.GossipsubMaxIHaveMessages) {\n      this.log(\n        'IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring',\n        id,\n        peerhave\n      )\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIhave })\n      return []\n    }\n\n    const iasked = this.iasked.get(id) ?? 0\n    if (iasked >= constants.GossipsubMaxIHaveLength) {\n      this.log('IHAVE: peer %s has already advertised too many messages (%d); ignoring', id, iasked)\n      this.metrics?.ihaveRcvIgnored.inc({ reason: IHaveIgnoreReason.MaxIasked })\n      return []\n    }\n\n    // string msgId => msgId\n    const iwant = new Map<MsgIdStr, Uint8Array>()\n\n    ihave.forEach(({ topicID, messageIDs }) => {\n      if (topicID == null || (messageIDs == null) || !this.mesh.has(topicID)) {\n        return\n      }\n\n      let idonthave = 0\n\n      messageIDs.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        if (!this.seenCache.has(msgIdStr)) {\n          iwant.set(msgIdStr, msgId)\n          idonthave++\n        }\n      })\n\n      this.metrics?.onIhaveRcv(topicID, messageIDs.length, idonthave)\n    })\n\n    if (iwant.size === 0) {\n      return []\n    }\n\n    let iask = iwant.size\n    if (iask + iasked > constants.GossipsubMaxIHaveLength) {\n      iask = constants.GossipsubMaxIHaveLength - iasked\n    }\n\n    this.log('IHAVE: Asking for %d out of %d messages from %s', iask, iwant.size, id)\n\n    let iwantList = Array.from(iwant.values())\n    // ask in random order\n    shuffle(iwantList)\n\n    // truncate to the messages we are actually asking for and update the iasked counter\n    iwantList = iwantList.slice(0, iask)\n    this.iasked.set(id, iasked + iask)\n\n    // do not add gossipTracer promise here until a successful sendRpc()\n\n    return [\n      {\n        messageIDs: iwantList\n      }\n    ]\n  }\n\n  /**\n   * Handles IWANT messages\n   * Returns messages to send back to peer\n   */\n  private handleIWant (id: PeerIdStr, iwant: RPC.ControlIWant[]): RPC.Message[] {\n    if (iwant.length === 0) {\n      return []\n    }\n\n    // we don't respond to IWANT requests from any per whose score is below the gossip threshold\n    const score = this.score.score(id)\n    if (score < this.opts.scoreThresholds.gossipThreshold) {\n      this.log('IWANT: ignoring peer %s with score below threshold [score = %d]', id, score)\n      return []\n    }\n\n    const ihave = new Map<MsgIdStr, RPC.Message>()\n    const iwantByTopic = new Map<TopicStr, number>()\n    let iwantDonthave = 0\n\n    iwant.forEach(({ messageIDs }) => {\n      messageIDs?.forEach((msgId) => {\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        const entry = this.mcache.getWithIWantCount(msgIdStr, id)\n        if (entry == null) {\n          iwantDonthave++\n          return\n        }\n\n        iwantByTopic.set(entry.msg.topic, 1 + (iwantByTopic.get(entry.msg.topic) ?? 0))\n\n        if (entry.count > constants.GossipsubGossipRetransmission) {\n          this.log('IWANT: Peer %s has asked for message %s too many times: ignoring request', id, msgId)\n          return\n        }\n\n        ihave.set(msgIdStr, entry.msg)\n      })\n    })\n\n    this.metrics?.onIwantRcv(iwantByTopic, iwantDonthave)\n\n    if (ihave.size === 0) {\n      this.log('IWANT: Could not provide any wanted messages to %s', id)\n      return []\n    }\n\n    this.log('IWANT: Sending %d messages to %s', ihave.size, id)\n\n    return Array.from(ihave.values())\n  }\n\n  /**\n   * Handles Graft messages\n   */\n  private async handleGraft (id: PeerIdStr, graft: RPC.ControlGraft[]): Promise<RPC.ControlPrune[]> {\n    const prune: TopicStr[] = []\n    const score = this.score.score(id)\n    const now = Date.now()\n    let doPX = this.opts.doPX\n\n    graft.forEach(({ topicID }) => {\n      if (topicID == null) {\n        return\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (peersInMesh == null) {\n        // don't do PX when there is an unknown topic to avoid leaking our peers\n        doPX = false\n        // spam hardening: ignore GRAFTs for unknown topics\n        return\n      }\n\n      // check if peer is already in the mesh; if so do nothing\n      if (peersInMesh.has(id)) {\n        return\n      }\n\n      const backoffExpiry = this.backoff.get(topicID)?.get(id)\n\n      // This if/else chain contains the various cases of valid (and semi-valid) GRAFTs\n      // Most of these cases result in a PRUNE immediately being sent in response\n\n      // we don't GRAFT to/from direct peers; complain loudly if this happens\n      if (this.direct.has(id)) {\n        this.log('GRAFT: ignoring request from direct peer %s', id)\n        // this is possibly a bug from a non-reciprical configuration; send a PRUNE\n        prune.push(topicID)\n        // but don't px\n        doPX = false\n\n        // make sure we are not backing off that peer\n      } else if (typeof backoffExpiry === 'number' && now < backoffExpiry) {\n        this.log('GRAFT: ignoring backed off peer %s', id)\n        // add behavioral penalty\n        this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        // no PX\n        doPX = false\n        // check the flood cutoff -- is the GRAFT coming too fast?\n        const floodCutoff = backoffExpiry + this.opts.graftFloodThreshold - this.opts.pruneBackoff\n        if (now < floodCutoff) {\n          // extra penalty\n          this.score.addPenalty(id, 1, ScorePenalty.GraftBackoff)\n        }\n        // refresh the backoff\n        this.addBackoff(id, topicID)\n        prune.push(topicID)\n\n        // check the score\n      } else if (score < 0) {\n        // we don't GRAFT peers with negative score\n        this.log('GRAFT: ignoring peer %s with negative score: score=%d, topic=%s', id, score, topicID)\n        // we do send them PRUNE however, because it's a matter of protocol correctness\n        prune.push(topicID)\n        // but we won't PX to them\n        doPX = false\n        // add/refresh backoff so that we don't reGRAFT too early even if the score decays\n        this.addBackoff(id, topicID)\n\n        // check the number of mesh peers; if it is at (or over) Dhi, we only accept grafts\n        // from peers with outbound connections; this is a defensive check to restrict potential\n        // mesh takeover attacks combined with love bombing\n      } else if (peersInMesh.size >= this.opts.Dhi && !(this.outbound.get(id) ?? false)) {\n        prune.push(topicID)\n        this.addBackoff(id, topicID)\n\n        // valid graft\n      } else {\n        this.log('GRAFT: Add mesh link from %s in %s', id, topicID)\n        this.score.graft(id, topicID)\n        peersInMesh.add(id)\n\n        this.metrics?.onAddToMesh(topicID, InclusionReason.Subscribed, 1)\n      }\n\n      this.safeDispatchEvent<MeshPeer>('gossipsub:graft', { detail: { peerId: id, topic: topicID, direction: 'inbound' } })\n    })\n\n    if (prune.length === 0) {\n      return []\n    }\n\n    const onUnsubscribe = false\n    return Promise.all(prune.map(async (topic) => this.makePrune(id, topic, doPX, onUnsubscribe)))\n  }\n\n  /**\n   * Handles Prune messages\n   */\n  private async handlePrune (id: PeerIdStr, prune: RPC.ControlPrune[]): Promise<void> {\n    const score = this.score.score(id)\n\n    for (const { topicID, backoff, peers } of prune) {\n      if (topicID == null) {\n        continue\n      }\n\n      const peersInMesh = this.mesh.get(topicID)\n      if (peersInMesh == null) {\n        return\n      }\n\n      this.log('PRUNE: Remove mesh link to %s in %s', id, topicID)\n      this.score.prune(id, topicID)\n      if (peersInMesh.has(id)) {\n        peersInMesh.delete(id)\n        this.metrics?.onRemoveFromMesh(topicID, ChurnReason.Prune, 1)\n      }\n\n      // is there a backoff specified by the peer? if so obey it\n      if (typeof backoff === 'number' && backoff > 0) {\n        this.doAddBackoff(id, topicID, backoff * 1000)\n      } else {\n        this.addBackoff(id, topicID)\n      }\n\n      // PX\n      if ((peers != null) && (peers.length > 0)) {\n        // we ignore PX from peers with insufficient scores\n        if (score < this.opts.scoreThresholds.acceptPXThreshold) {\n          this.log(\n            'PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]',\n            id,\n            score,\n            topicID\n          )\n        } else {\n          await this.pxConnect(peers)\n        }\n      }\n\n      this.safeDispatchEvent<MeshPeer>('gossipsub:prune', { detail: { peerId: id, topic: topicID, direction: 'inbound' } })\n    }\n  }\n\n  private handleIdontwant (id: PeerIdStr, idontwant: RPC.ControlIDontWant[]): void {\n    let idontwantCount = this.idontwantCounts.get(id) ?? 0\n    // return early if we have already received too many IDONTWANT messages from the peer\n    if (idontwantCount >= this.opts.idontwantMaxMessages) {\n      return\n    }\n    const startIdontwantCount = idontwantCount\n\n    let idontwants = this.idontwants.get(id)\n    if (idontwants == null) {\n      idontwants = new Map()\n      this.idontwants.set(id, idontwants)\n    }\n    let idonthave = 0\n    // eslint-disable-next-line no-labels\n    out: for (const { messageIDs } of idontwant) {\n      for (const msgId of messageIDs) {\n        if (idontwantCount >= this.opts.idontwantMaxMessages) {\n          // eslint-disable-next-line no-labels\n          break out\n        }\n        idontwantCount++\n\n        const msgIdStr = this.msgIdToStrFn(msgId)\n        idontwants.set(msgIdStr, this.heartbeatTicks)\n        if (!this.mcache.msgs.has(msgIdStr)) { idonthave++ }\n      }\n    }\n    this.idontwantCounts.set(id, idontwantCount)\n    const total = idontwantCount - startIdontwantCount\n    this.metrics?.onIdontwantRcv(total, idonthave)\n  }\n\n  /**\n   * Add standard backoff log for a peer in a topic\n   */\n  private addBackoff (id: PeerIdStr, topic: TopicStr): void {\n    this.doAddBackoff(id, topic, this.opts.pruneBackoff)\n  }\n\n  /**\n   * Add backoff expiry interval for a peer in a topic\n   *\n   * @param id\n   * @param topic\n   * @param intervalMs - backoff duration in milliseconds\n   */\n  private doAddBackoff (id: PeerIdStr, topic: TopicStr, intervalMs: number): void {\n    let backoff = this.backoff.get(topic)\n    if (backoff == null) {\n      backoff = new Map()\n      this.backoff.set(topic, backoff)\n    }\n    const expire = Date.now() + intervalMs\n    const existingExpire = backoff.get(id) ?? 0\n    if (existingExpire < expire) {\n      backoff.set(id, expire)\n    }\n  }\n\n  /**\n   * Apply penalties from broken IHAVE/IWANT promises\n   */\n  private applyIwantPenalties (): void {\n    this.gossipTracer.getBrokenPromises().forEach((count, p) => {\n      this.log(\"peer %s didn't follow up in %d IWANT requests; adding penalty\", p, count)\n      this.score.addPenalty(p, count, ScorePenalty.BrokenPromise)\n    })\n  }\n\n  /**\n   * Clear expired backoff expiries\n   */\n  private clearBackoff (): void {\n    // we only clear once every GossipsubPruneBackoffTicks ticks to avoid iterating over the maps too much\n    if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {\n      return\n    }\n\n    const now = Date.now()\n    this.backoff.forEach((backoff, topic) => {\n      backoff.forEach((expire, id) => {\n        // add some slack time to the expiration, see https://github.com/libp2p/specs/pull/289\n        if (expire + BACKOFF_SLACK * this.opts.heartbeatInterval < now) {\n          backoff.delete(id)\n        }\n      })\n      if (backoff.size === 0) {\n        this.backoff.delete(topic)\n      }\n    })\n  }\n\n  /**\n   * Maybe reconnect to direct peers\n   */\n  private async directConnect (): Promise<void> {\n    const toconnect: string[] = []\n    this.direct.forEach((id) => {\n      if (!this.streamsOutbound.has(id)) {\n        toconnect.push(id)\n      }\n    })\n\n    await Promise.all(toconnect.map(async (id) => this.connect(id)))\n  }\n\n  /**\n   * Maybe attempt connection given signed peer records\n   */\n  private async pxConnect (peers: RPC.PeerInfo[]): Promise<void> {\n    if (peers.length > this.opts.prunePeers) {\n      shuffle(peers)\n      peers = peers.slice(0, this.opts.prunePeers)\n    }\n    const toconnect: string[] = []\n\n    await Promise.all(\n      peers.map(async (pi) => {\n        if (pi.peerID == null) {\n          return\n        }\n\n        const peer = peerIdFromMultihash(Digest.decode(pi.peerID))\n        const p = peer.toString()\n\n        if (this.peers.has(p)) {\n          return\n        }\n\n        if (pi.signedPeerRecord == null) {\n          toconnect.push(p)\n          return\n        }\n\n        // The peer sent us a signed record\n        // This is not a record from the peer who sent the record, but another peer who is connected with it\n        // Ensure that it is valid\n        try {\n          if (!(await this.components.peerStore.consumePeerRecord(pi.signedPeerRecord, {\n            expectedPeer: peer\n          }))) {\n            this.log('bogus peer record obtained through px: could not add peer record to address book')\n            return\n          }\n          toconnect.push(p)\n        } catch (e) {\n          this.log('bogus peer record obtained through px: invalid signature or not a peer record')\n        }\n      })\n    )\n\n    if (toconnect.length === 0) {\n      return\n    }\n\n    await Promise.all(toconnect.map(async (id) => this.connect(id)))\n  }\n\n  /**\n   * Connect to a peer using the gossipsub protocol\n   */\n  private async connect (id: PeerIdStr): Promise<void> {\n    this.log('Initiating connection with %s', id)\n    const peerId = peerIdFromString(id)\n    const connection = await this.components.connectionManager.openConnection(peerId)\n    for (const protocol of this.protocols) {\n      for (const topology of this.components.registrar.getTopologies(protocol)) {\n        topology.onConnect?.(peerId, connection)\n      }\n    }\n  }\n\n  /**\n   * Subscribes to a topic\n   */\n  subscribe (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub has not started')\n    }\n\n    if (!this.subscriptions.has(topic)) {\n      this.subscriptions.add(topic)\n\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], true)\n      }\n    }\n\n    this.join(topic)\n  }\n\n  /**\n   * Unsubscribe to a topic\n   */\n  unsubscribe (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Pubsub is not started')\n    }\n\n    const wasSubscribed = this.subscriptions.delete(topic)\n\n    this.log('unsubscribe from %s - am subscribed %s', topic, wasSubscribed)\n\n    if (wasSubscribed) {\n      for (const peerId of this.peers.keys()) {\n        this.sendSubscriptions(peerId, [topic], false)\n      }\n    }\n\n    this.leave(topic)\n  }\n\n  /**\n   * Join topic\n   */\n  private join (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    // if we are already in the mesh, return\n    if (this.mesh.has(topic)) {\n      return\n    }\n\n    this.log('JOIN %s', topic)\n    this.metrics?.onJoin(topic)\n\n    const toAdd = new Set<PeerIdStr>()\n    const backoff = this.backoff.get(topic)\n\n    // check if we have mesh_n peers in fanout[topic] and add them to the mesh if we do,\n    // removing the fanout entry.\n    const fanoutPeers = this.fanout.get(topic)\n    if (fanoutPeers != null) {\n      // Remove fanout entry and the last published time\n      this.fanout.delete(topic)\n      this.fanoutLastpub.delete(topic)\n\n      // remove explicit peers, peers with negative scores, and backoffed peers\n      fanoutPeers.forEach((id) => {\n        if (!this.direct.has(id) && this.score.score(id) >= 0 && backoff?.has(id) !== true) {\n          toAdd.add(id)\n        }\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Fanout, toAdd.size)\n    }\n\n    // check if we need to get more peers, which we randomly select\n    if (toAdd.size < this.opts.D) {\n      const fanoutCount = toAdd.size\n      const newPeers = this.getRandomGossipPeers(\n        topic,\n        this.opts.D,\n        (id: PeerIdStr): boolean =>\n          // filter direct peers and peers with negative score\n          !toAdd.has(id) && !this.direct.has(id) && this.score.score(id) >= 0 && backoff?.has(id) !== true\n      )\n\n      newPeers.forEach((peer) => {\n        toAdd.add(peer)\n      })\n\n      this.metrics?.onAddToMesh(topic, InclusionReason.Random, toAdd.size - fanoutCount)\n    }\n\n    this.mesh.set(topic, toAdd)\n\n    toAdd.forEach((id) => {\n      this.log('JOIN: Add mesh link to %s in %s', id, topic)\n      this.sendGraft(id, topic)\n\n      // rust-libp2p\n      // - peer_score.graft()\n      // - Self::control_pool_add()\n      // - peer_added_to_mesh()\n    })\n  }\n\n  /**\n   * Leave topic\n   */\n  private leave (topic: TopicStr): void {\n    if (this.status.code !== GossipStatusCode.started) {\n      throw new Error('Gossipsub has not started')\n    }\n\n    this.log('LEAVE %s', topic)\n    this.metrics?.onLeave(topic)\n\n    // Send PRUNE to mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if (meshPeers != null) {\n      Promise.all(\n        Array.from(meshPeers).map(async (id) => {\n          this.log('LEAVE: Remove mesh link to %s in %s', id, topic)\n          await this.sendPrune(id, topic)\n        })\n      ).catch((err) => {\n        this.log('Error sending prunes to mesh peers', err)\n      })\n      this.mesh.delete(topic)\n    }\n  }\n\n  private selectPeersToForward (topic: TopicStr, propagationSource?: PeerIdStr, excludePeers?: Set<PeerIdStr>): Set<string> {\n    const tosend = new Set<PeerIdStr>()\n\n    // Add explicit peers\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic != null) {\n      this.direct.forEach((peer) => {\n        if (peersInTopic.has(peer) && propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {\n          tosend.add(peer)\n        }\n      })\n\n      // As of Mar 2022, spec + golang-libp2p include this while rust-libp2p does not\n      // rust-libp2p: https://github.com/libp2p/rust-libp2p/blob/6cc3b4ec52c922bfcf562a29b5805c3150e37c75/protocols/gossipsub/src/behaviour.rs#L2693\n      // spec: https://github.com/libp2p/specs/blob/10712c55ab309086a52eec7d25f294df4fa96528/pubsub/gossipsub/gossipsub-v1.0.md?plain=1#L361\n      this.floodsubPeers.forEach((peer) => {\n        if (\n          peersInTopic.has(peer) &&\n          propagationSource !== peer &&\n          !(excludePeers?.has(peer) ?? false) &&\n          this.score.score(peer) >= this.opts.scoreThresholds.publishThreshold\n        ) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    // add mesh peers\n    const meshPeers = this.mesh.get(topic)\n    if ((meshPeers != null) && meshPeers.size > 0) {\n      meshPeers.forEach((peer) => {\n        if (propagationSource !== peer && !(excludePeers?.has(peer) ?? false)) {\n          tosend.add(peer)\n        }\n      })\n    }\n\n    return tosend\n  }\n\n  private selectPeersToPublish (topic: TopicStr): {\n    tosend: Set<PeerIdStr>\n    tosendCount: ToSendGroupCount\n  } {\n    const tosend = new Set<PeerIdStr>()\n    const tosendCount: ToSendGroupCount = {\n      direct: 0,\n      floodsub: 0,\n      mesh: 0,\n      fanout: 0\n    }\n\n    const peersInTopic = this.topics.get(topic)\n    if (peersInTopic != null) {\n      // flood-publish behavior\n      // send to direct peers and _all_ peers meeting the publishThreshold\n      if (this.opts.floodPublish) {\n        peersInTopic.forEach((id) => {\n          if (this.direct.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          } else if (this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n      } else {\n        // non-flood-publish behavior\n        // send to direct peers, subscribed floodsub peers\n        // and some mesh peers above publishThreshold\n\n        // direct peers (if subscribed)\n        this.direct.forEach((id) => {\n          if (peersInTopic.has(id)) {\n            tosend.add(id)\n            tosendCount.direct++\n          }\n        })\n\n        // floodsub peers\n        // Note: if there are no floodsub peers, we save a loop through peersInTopic Map\n        this.floodsubPeers.forEach((id) => {\n          if (peersInTopic.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold) {\n            tosend.add(id)\n            tosendCount.floodsub++\n          }\n        })\n\n        // Gossipsub peers handling\n        const meshPeers = this.mesh.get(topic)\n        if ((meshPeers != null) && meshPeers.size > 0) {\n          meshPeers.forEach((peer) => {\n            tosend.add(peer)\n            tosendCount.mesh++\n          })\n\n          // We want to publish to at least `D` peers.\n          // If there are insufficient peers in the mesh, publish to other topic peers\n          if (meshPeers.size < this.opts.D) {\n            // pick additional topic peers above the publishThreshold\n            const topicPeers = this.getRandomGossipPeers(topic, this.opts.D - meshPeers.size, (id) => {\n              return !meshPeers.has(id) && !this.direct.has(id) && !this.floodsubPeers.has(id) && this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            topicPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.mesh++\n            })\n          }\n        } else {\n          // We are not in the mesh for topic, use fanout peers\n\n          const fanoutPeers = this.fanout.get(topic)\n          if ((fanoutPeers != null) && fanoutPeers.size > 0) {\n            fanoutPeers.forEach((peer) => {\n              tosend.add(peer)\n              tosendCount.fanout++\n            })\n          } else {\n            // We have no fanout peers, select mesh_n of them and add them to the fanout\n\n            // If we are not in the fanout, then pick peers in topic above the publishThreshold\n            const newFanoutPeers = this.getRandomGossipPeers(topic, this.opts.D, (id) => {\n              return this.score.score(id) >= this.opts.scoreThresholds.publishThreshold\n            })\n\n            // eslint-disable-next-line max-depth\n            if (newFanoutPeers.size > 0) {\n              this.fanout.set(topic, newFanoutPeers)\n\n              newFanoutPeers.forEach((peer) => {\n                tosend.add(peer)\n                tosendCount.fanout++\n              })\n            }\n          }\n\n          // We are publishing to fanout peers - update the time we published\n          this.fanoutLastpub.set(topic, Date.now())\n        }\n      }\n    }\n\n    return { tosend, tosendCount }\n  }\n\n  /**\n   * Forwards a message from our peers.\n   *\n   * For messages published by us (the app layer), this class uses `publish`\n   */\n  private forwardMessage (\n    msgIdStr: string,\n    rawMsg: RPC.Message,\n    propagationSource?: PeerIdStr,\n    excludePeers?: Set<PeerIdStr>\n  ): void {\n    // message is fully validated inform peer_score\n    if (propagationSource != null) {\n      this.score.deliverMessage(propagationSource, msgIdStr, rawMsg.topic)\n    }\n\n    const tosend = this.selectPeersToForward(rawMsg.topic, propagationSource, excludePeers)\n\n    // Note: Don't throw if tosend is empty, we can have a mesh with a single peer\n\n    // forward the message to peers\n    tosend.forEach((id) => {\n      // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n      this.sendRpc(id, createGossipRpc([rawMsg]))\n    })\n\n    this.metrics?.onForwardMsg(rawMsg.topic, tosend.size)\n  }\n\n  /**\n   * App layer publishes a message to peers, return number of peers this message is published to\n   * Note: `async` due to crypto only if `StrictSign`, otherwise it's a sync fn.\n   *\n   * For messages not from us, this class uses `forwardMessage`.\n   */\n  async publish (topic: TopicStr, data: Uint8Array, opts?: PublishOpts): Promise<PublishResult> {\n    const startMs = Date.now()\n    const transformedData = (this.dataTransform != null) ? this.dataTransform.outboundTransform(topic, data) : data\n\n    if (this.publishConfig == null) {\n      throw Error('PublishError.Uninitialized')\n    }\n\n    // Prepare raw message with user's publishConfig\n    const { raw: rawMsg, msg } = await buildRawMessage(this.publishConfig, topic, data, transformedData)\n\n    // calculate the message id from the un-transformed data\n    const msgId = await this.msgIdFn(msg)\n    const msgIdStr = this.msgIdToStrFn(msgId)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const ignoreDuplicatePublishError = opts?.ignoreDuplicatePublishError ?? this.opts.ignoreDuplicatePublishError\n\n    if (this.seenCache.has(msgIdStr)) {\n      // This message has already been seen. We don't re-publish messages that have already\n      // been published on the network.\n      if (ignoreDuplicatePublishError) {\n        this.metrics?.onPublishDuplicateMsg(topic)\n        return { recipients: [] }\n      }\n      throw Error('PublishError.Duplicate')\n    }\n\n    const { tosend, tosendCount } = this.selectPeersToPublish(topic)\n    const willSendToSelf = this.opts.emitSelf && this.subscriptions.has(topic)\n\n    // Current publish opt takes precedence global opts, while preserving false value\n    const allowPublishToZeroTopicPeers = opts?.allowPublishToZeroTopicPeers ?? this.opts.allowPublishToZeroTopicPeers\n\n    if (tosend.size === 0 && !allowPublishToZeroTopicPeers && !willSendToSelf) {\n      throw Error('PublishError.NoPeersSubscribedToTopic')\n    }\n\n    // If the message isn't a duplicate and we have sent it to some peers add it to the\n    // duplicate cache and memcache.\n    this.seenCache.put(msgIdStr)\n    // all published messages are valid\n    this.mcache.put({ msgId, msgIdStr }, rawMsg, true)\n    // Consider the message as delivered for gossip promises.\n    this.gossipTracer.deliverMessage(msgIdStr)\n\n    // If the message is anonymous or has a random author add it to the published message ids cache.\n    this.publishedMessageIds.put(msgIdStr)\n\n    const batchPublish = opts?.batchPublish ?? this.opts.batchPublish\n    const rpc = createGossipRpc([rawMsg])\n    if (batchPublish) {\n      this.sendRpcInBatch(tosend, rpc)\n    } else {\n      // Send to set of peers aggregated from direct, mesh, fanout\n      for (const id of tosend) {\n        // sendRpc may mutate RPC message on piggyback, create a new message for each peer\n        const sent = this.sendRpc(id, rpc)\n\n        // did not actually send the message\n        if (!sent) {\n          tosend.delete(id)\n        }\n      }\n    }\n\n    const durationMs = Date.now() - startMs\n    this.metrics?.onPublishMsg(\n      topic,\n      tosendCount,\n      tosend.size,\n      rawMsg.data != null ? rawMsg.data.length : 0,\n      durationMs\n    )\n\n    // Dispatch the message to the user if we are subscribed to the topic\n    if (willSendToSelf) {\n      tosend.add(this.components.peerId.toString())\n\n      super.dispatchEvent(\n        new CustomEvent<GossipsubMessage>('gossipsub:message', {\n          detail: {\n            propagationSource: this.components.peerId,\n            msgId: msgIdStr,\n            msg\n          }\n        })\n      )\n      // TODO: Add option to switch between emit per topic or all messages in one\n      super.dispatchEvent(new CustomEvent<Message>('message', { detail: msg }))\n    }\n\n    return {\n      recipients: Array.from(tosend.values()).map((str) => this.peers.get(str) ?? peerIdFromString(str))\n    }\n  }\n\n  /**\n   * Send the same data in batch to tosend list without considering cached control messages\n   * This is not only faster but also avoid allocating memory for each peer\n   * see https://github.com/ChainSafe/js-libp2p-gossipsub/issues/344\n   */\n  private sendRpcInBatch (tosend: Set<PeerIdStr>, rpc: RPC): void {\n    const rpcBytes = RPC.encode(rpc)\n    const prefixedData = encode.single(rpcBytes)\n    for (const id of tosend) {\n      const outboundStream = this.streamsOutbound.get(id)\n      if (outboundStream == null) {\n        this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n        tosend.delete(id)\n        continue\n      }\n      try {\n        outboundStream.pushPrefixed(prefixedData)\n      } catch (e) {\n        tosend.delete(id)\n        this.log.error(`Cannot send rpc to ${id}`, e)\n      }\n\n      this.metrics?.onRpcSent(rpc, rpcBytes.length)\n    }\n  }\n\n  /**\n   * This function should be called when `asyncValidation` is `true` after\n   * the message got validated by the caller. Messages are stored in the `mcache` and\n   * validation is expected to be fast enough that the messages should still exist in the cache.\n   * There are three possible validation outcomes and the outcome is given in acceptance.\n   *\n   * If acceptance = `MessageAcceptance.Accept` the message will get propagated to the\n   * network. The `propagation_source` parameter indicates who the message was received by and\n   * will not be forwarded back to that peer.\n   *\n   * If acceptance = `MessageAcceptance.Reject` the message will be deleted from the memcache\n   * and the P\u2084 penalty will be applied to the `propagationSource`.\n   *\n   * If acceptance = `MessageAcceptance.Ignore` the message will be deleted from the memcache\n   * but no P\u2084 penalty will be applied.\n   *\n   * This function will return true if the message was found in the cache and false if was not\n   * in the cache anymore.\n   *\n   * This should only be called once per message.\n   */\n  reportMessageValidationResult (msgId: MsgIdStr, propagationSource: PeerIdStr, acceptance: TopicValidatorResult): void {\n    let cacheEntry: MessageCacheRecord | null\n\n    if (acceptance === TopicValidatorResult.Accept) {\n      cacheEntry = this.mcache.validate(msgId)\n\n      if (cacheEntry != null) {\n        const { message: rawMsg, originatingPeers } = cacheEntry\n        // message is fully validated inform peer_score\n        this.score.deliverMessage(propagationSource, msgId, rawMsg.topic)\n\n        this.forwardMessage(msgId, cacheEntry.message, propagationSource, originatingPeers)\n      }\n      // else, Message not in cache. Ignoring forwarding\n    } else {\n      // Not valid\n      cacheEntry = this.mcache.remove(msgId)\n\n      if (cacheEntry != null) {\n        const rejectReason = rejectReasonFromAcceptance(acceptance)\n        const { message: rawMsg, originatingPeers } = cacheEntry\n\n        // Tell peer_score about reject\n        // Reject the original source, and any duplicates we've seen from other peers.\n        this.score.rejectMessage(propagationSource, msgId, rawMsg.topic, rejectReason)\n        for (const peer of originatingPeers) {\n          this.score.rejectMessage(peer, msgId, rawMsg.topic, rejectReason)\n        }\n      }\n      // else, Message not in cache. Ignoring forwarding\n    }\n\n    const firstSeenTimestampMs = this.score.messageFirstSeenTimestampMs(msgId)\n    this.metrics?.onReportValidation(cacheEntry, acceptance, firstSeenTimestampMs)\n  }\n\n  /**\n   * Sends a GRAFT message to a peer\n   */\n  private sendGraft (id: PeerIdStr, topic: string): void {\n    const graft = [\n      {\n        topicID: topic\n      }\n    ]\n    const out = createGossipRpc([], { graft })\n    this.sendRpc(id, out)\n  }\n\n  /**\n   * Sends a PRUNE message to a peer\n   */\n  private async sendPrune (id: PeerIdStr, topic: string): Promise<void> {\n    // this is only called from leave() function\n    const onUnsubscribe = true\n    const prune = [await this.makePrune(id, topic, this.opts.doPX, onUnsubscribe)]\n    const out = createGossipRpc([], { prune })\n    this.sendRpc(id, out)\n  }\n\n  private sendIDontWants (msgId: Uint8Array, topic: string, source: PeerIdStr): void {\n    const ids = this.mesh.get(topic)\n    if (ids == null) {\n      return\n    }\n\n    // don't send IDONTWANT to:\n    // - the source\n    // - peers that don't support v1.2\n    const tosend = new Set(ids)\n    tosend.delete(source)\n    for (const id of tosend) {\n      if (this.streamsOutbound.get(id)?.protocol !== constants.GossipsubIDv12) {\n        tosend.delete(id)\n      }\n    }\n\n    const idontwantRpc = createGossipRpc([], { idontwant: [{ messageIDs: [msgId] }] })\n    this.sendRpcInBatch(tosend, idontwantRpc)\n  }\n\n  /**\n   * Send an rpc object to a peer\n   */\n  private sendRpc (id: PeerIdStr, rpc: RPC): boolean {\n    const outboundStream = this.streamsOutbound.get(id)\n    if (outboundStream == null) {\n      this.log(`Cannot send RPC to ${id} as there is no open stream to it available`)\n      return false\n    }\n\n    // piggyback control message retries\n    const ctrl = this.control.get(id)\n    if (ctrl != null) {\n      this.piggybackControl(id, rpc, ctrl)\n      this.control.delete(id)\n    }\n\n    // piggyback gossip\n    const ihave = this.gossip.get(id)\n    if (ihave != null) {\n      this.piggybackGossip(id, rpc, ihave)\n      this.gossip.delete(id)\n    }\n\n    const rpcBytes = RPC.encode(rpc)\n    try {\n      outboundStream.push(rpcBytes)\n    } catch (e) {\n      this.log.error(`Cannot send rpc to ${id}`, e)\n\n      // if the peer had control messages or gossip, re-attach\n      if (ctrl != null) {\n        this.control.set(id, ctrl)\n      }\n      if (ihave != null) {\n        this.gossip.set(id, ihave)\n      }\n\n      return false\n    }\n\n    this.metrics?.onRpcSent(rpc, rpcBytes.length)\n\n    if (rpc.control?.graft != null) {\n      for (const topic of rpc.control?.graft) {\n        if (topic.topicID != null) {\n          this.safeDispatchEvent<MeshPeer>('gossipsub:graft', { detail: { peerId: id, topic: topic.topicID, direction: 'outbound' } })\n        }\n      }\n    }\n    if (rpc.control?.prune != null) {\n      for (const topic of rpc.control?.prune) {\n        if (topic.topicID != null) {\n          this.safeDispatchEvent<MeshPeer>('gossipsub:prune', { detail: { peerId: id, topic: topic.topicID, direction: 'outbound' } })\n        }\n      }\n    }\n\n    return true\n  }\n\n  /** Mutates `outRpc` adding graft and prune control messages */\n  public piggybackControl (id: PeerIdStr, outRpc: RPC, ctrl: RPC.ControlMessage): void {\n    const rpc = ensureControl(outRpc)\n    for (const graft of ctrl.graft) {\n      if (graft.topicID != null && (this.mesh.get(graft.topicID)?.has(id) ?? false)) {\n        rpc.control.graft.push(graft)\n      }\n    }\n\n    for (const prune of ctrl.prune) {\n      if (prune.topicID != null && !(this.mesh.get(prune.topicID)?.has(id) ?? false)) {\n        rpc.control.prune.push(prune)\n      }\n    }\n  }\n\n  /** Mutates `outRpc` adding ihave control messages */\n  private piggybackGossip (id: PeerIdStr, outRpc: RPC, ihave: RPC.ControlIHave[]): void {\n    const rpc = ensureControl(outRpc)\n    rpc.control.ihave = ihave\n  }\n\n  /**\n   * Send graft and prune messages\n   *\n   * @param tograft - peer id => topic[]\n   * @param toprune - peer id => topic[]\n   */\n  private async sendGraftPrune (\n    tograft: Map<string, string[]>,\n    toprune: Map<string, string[]>,\n    noPX: Map<string, boolean>\n  ): Promise<void> {\n    const doPX = this.opts.doPX\n    const onUnsubscribe = false\n    for (const [id, topics] of tograft) {\n      const graft = topics.map((topicID) => ({ topicID }))\n      let prune: RPC.ControlPrune[] = []\n      // If a peer also has prunes, process them now\n      const pruning = toprune.get(id)\n      if (pruning != null) {\n        prune = await Promise.all(\n          pruning.map(\n            async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n          )\n        )\n        toprune.delete(id)\n      }\n\n      this.sendRpc(id, createGossipRpc([], { graft, prune }))\n    }\n    for (const [id, topics] of toprune) {\n      const prune = await Promise.all(\n        topics.map(\n          async (topicID) => this.makePrune(id, topicID, doPX && !(noPX.get(id) ?? false), onUnsubscribe)\n        )\n      )\n      this.sendRpc(id, createGossipRpc([], { prune }))\n    }\n  }\n\n  /**\n   * Emits gossip - Send IHAVE messages to a random set of gossip peers\n   */\n  private emitGossip (peersToGossipByTopic: Map<string, Set<PeerIdStr>>): void {\n    const gossipIDsByTopic = this.mcache.getGossipIDs(new Set(peersToGossipByTopic.keys()))\n    for (const [topic, peersToGossip] of peersToGossipByTopic) {\n      this.doEmitGossip(topic, peersToGossip, gossipIDsByTopic.get(topic) ?? [])\n    }\n  }\n\n  /**\n   * Send gossip messages to GossipFactor peers above threshold with a minimum of D_lazy\n   * Peers are randomly selected from the heartbeat which exclude mesh + fanout peers\n   * We also exclude direct peers, as there is no reason to emit gossip to them\n   *\n   * @param topic\n   * @param candidateToGossip - peers to gossip\n   * @param messageIDs - message ids to gossip\n   */\n  private doEmitGossip (topic: string, candidateToGossip: Set<PeerIdStr>, messageIDs: Uint8Array[]): void {\n    if (messageIDs.length === 0) {\n      return\n    }\n\n    // shuffle to emit in random order\n    shuffle(messageIDs)\n\n    // if we are emitting more than GossipsubMaxIHaveLength ids, truncate the list\n    if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n      // we do the truncation (with shuffling) per peer below\n      this.log('too many messages for gossip; will truncate IHAVE list (%d messages)', messageIDs.length)\n    }\n\n    if (candidateToGossip.size === 0) { return }\n    let target = this.opts.Dlazy\n    const gossipFactor = this.opts.gossipFactor\n    const factor = gossipFactor * candidateToGossip.size\n    let peersToGossip: Set<PeerIdStr> | PeerIdStr[] = candidateToGossip\n    if (factor > target) {\n      target = factor\n    }\n    if (target > peersToGossip.size) {\n      target = peersToGossip.size\n    } else {\n      // only shuffle if needed\n      peersToGossip = shuffle(Array.from(peersToGossip)).slice(0, target)\n    }\n\n    // Emit the IHAVE gossip to the selected peers up to the target\n    peersToGossip.forEach((id) => {\n      let peerMessageIDs = messageIDs\n      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {\n        // shuffle and slice message IDs per peer so that we emit a different set for each peer\n        // we have enough reduncancy in the system that this will significantly increase the message\n        // coverage when we do truncate\n        peerMessageIDs = shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength)\n      }\n      this.pushGossip(id, {\n        topicID: topic,\n        messageIDs: peerMessageIDs\n      })\n    })\n  }\n\n  /**\n   * Flush gossip and control messages\n   */\n  private flush (): void {\n    // send gossip first, which will also piggyback control\n    for (const [peer, ihave] of this.gossip.entries()) {\n      this.gossip.delete(peer)\n      this.sendRpc(peer, createGossipRpc([], { ihave }))\n    }\n    // send the remaining control messages\n    for (const [peer, control] of this.control.entries()) {\n      this.control.delete(peer)\n      const out = createGossipRpc([], { graft: control.graft, prune: control.prune })\n      this.sendRpc(peer, out)\n    }\n  }\n\n  /**\n   * Adds new IHAVE messages to pending gossip\n   */\n  private pushGossip (id: PeerIdStr, controlIHaveMsgs: RPC.ControlIHave): void {\n    this.log('Add gossip to %s', id)\n    const gossip = this.gossip.get(id) ?? []\n    this.gossip.set(id, gossip.concat(controlIHaveMsgs))\n  }\n\n  /**\n   * Make a PRUNE control message for a peer in a topic\n   */\n  private async makePrune (\n    id: PeerIdStr,\n    topic: string,\n    doPX: boolean,\n    onUnsubscribe: boolean\n  ): Promise<RPC.ControlPrune> {\n    this.score.prune(id, topic)\n    if (this.streamsOutbound.get(id)?.protocol === constants.GossipsubIDv10) {\n      // Gossipsub v1.0 -- no backoff, the peer won't be able to parse it anyway\n      return {\n        topicID: topic,\n        peers: []\n      }\n    }\n    // backoff is measured in seconds\n    // GossipsubPruneBackoff and GossipsubUnsubscribeBackoff are measured in milliseconds\n    // The protobuf has it as a uint64\n    const backoffMs = onUnsubscribe ? this.opts.unsubcribeBackoff : this.opts.pruneBackoff\n    const backoff = backoffMs / 1000\n    this.doAddBackoff(id, topic, backoffMs)\n\n    if (!doPX) {\n      return {\n        topicID: topic,\n        peers: [],\n        backoff\n      }\n    }\n\n    // select peers for Peer eXchange\n    const peers = this.getRandomGossipPeers(topic, this.opts.prunePeers, (xid) => {\n      return xid !== id && this.score.score(xid) >= 0\n    })\n    const px = await Promise.all(\n      Array.from(peers).map(async (peerId) => {\n        // see if we have a signed record to send back; if we don't, just send\n        // the peer ID and let the pruned peer find them in the DHT -- we can't trust\n        // unsigned address records through PX anyways\n        // Finding signed records in the DHT is not supported at the time of writing in js-libp2p\n        const id = this.peers.get(peerId) ?? peerIdFromString(peerId)\n        let peerInfo: Peer | undefined\n\n        try {\n          peerInfo = await this.components.peerStore.get(id)\n        } catch (err: any) {\n          if (err.name !== 'NotFoundError') {\n            throw err\n          }\n        }\n\n        return {\n          peerID: id.toMultihash().bytes,\n          signedPeerRecord: peerInfo?.peerRecordEnvelope\n        }\n      })\n    )\n    return {\n      topicID: topic,\n      peers: px,\n      backoff\n    }\n  }\n\n  private readonly runHeartbeat = (): void => {\n    const timer = this.metrics?.heartbeatDuration.startTimer()\n\n    this.heartbeat()\n      .catch((err) => {\n        this.log('Error running heartbeat', err)\n      })\n      .finally(() => {\n        if (timer != null) {\n          timer()\n        }\n\n        // Schedule the next run if still in started status\n        if (this.status.code === GossipStatusCode.started) {\n          // Clear previous timeout before overwriting `status.heartbeatTimeout`, it should be completed tho.\n          clearTimeout(this.status.heartbeatTimeout)\n\n          // NodeJS setInterval function is innexact, calls drift by a few miliseconds on each call.\n          // To run the heartbeat precisely setTimeout() must be used recomputing the delay on every loop.\n          let msToNextHeartbeat =\n            this.opts.heartbeatInterval - ((Date.now() - this.status.hearbeatStartMs) % this.opts.heartbeatInterval)\n\n          // If too close to next heartbeat, skip one\n          if (msToNextHeartbeat < this.opts.heartbeatInterval * 0.25) {\n            msToNextHeartbeat += this.opts.heartbeatInterval\n            this.metrics?.heartbeatSkipped.inc()\n          }\n\n          this.status.heartbeatTimeout = setTimeout(this.runHeartbeat, msToNextHeartbeat)\n        }\n      })\n  }\n\n  /**\n   * Maintains the mesh and fanout maps in gossipsub.\n   */\n  public async heartbeat (): Promise<void> {\n    const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.opts\n\n    this.heartbeatTicks++\n\n    // cache scores throught the heartbeat\n    const scores = new Map<string, number>()\n    const getScore = (id: string): number => {\n      let s = scores.get(id)\n      if (s === undefined) {\n        s = this.score.score(id)\n        scores.set(id, s)\n      }\n      return s\n    }\n\n    // peer id => topic[]\n    const tograft = new Map<string, string[]>()\n    // peer id => topic[]\n    const toprune = new Map<string, string[]>()\n    // peer id => don't px\n    const noPX = new Map<string, boolean>()\n\n    // clean up expired backoffs\n    this.clearBackoff()\n\n    // clean up peerhave/iasked counters\n    this.peerhave.clear()\n    this.metrics?.cacheSize.set({ cache: 'iasked' }, this.iasked.size)\n    this.iasked.clear()\n\n    // apply IWANT request penalties\n    this.applyIwantPenalties()\n\n    // clean up IDONTWANT counters\n    this.idontwantCounts.clear()\n\n    // clean up old tracked IDONTWANTs\n    for (const idontwants of this.idontwants.values()) {\n      for (const [msgId, heartbeatTick] of idontwants) {\n        if (this.heartbeatTicks - heartbeatTick >= this.opts.mcacheLength) {\n          idontwants.delete(msgId)\n        }\n      }\n    }\n\n    // ensure direct peers are connected\n    if (this.heartbeatTicks % this.opts.directConnectTicks === 0) {\n      // we only do this every few ticks to allow pending connections to complete and account for restarts/downtime\n      await this.directConnect()\n    }\n\n    // EXTRA: Prune caches\n    this.fastMsgIdCache?.prune()\n    this.seenCache.prune()\n    this.gossipTracer.prune()\n    this.publishedMessageIds.prune()\n\n    /**\n     * Instead of calling getRandomGossipPeers multiple times to:\n     * + get more mesh peers\n     * + more outbound peers\n     * + oppportunistic grafting\n     * + emitGossip\n     *\n     * We want to loop through the topic peers only a single time and prepare gossip peers for all topics to improve the performance\n     */\n\n    const peersToGossipByTopic = new Map<string, Set<PeerIdStr>>()\n    // maintain the mesh for topics we have joined\n    // eslint-disable-next-line complexity\n    this.mesh.forEach((peers, topic) => {\n      const peersInTopic = this.topics.get(topic)\n      const candidateMeshPeers = new Set<PeerIdStr>()\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic != null) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        const backoff = this.backoff.get(topic)\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            (peerStreams != null) &&\n            this.protocols.includes(peerStreams.protocol) &&\n            !peers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (backoff?.has(id) !== true && score >= 0) { candidateMeshPeers.add(id) }\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) { peersToGossip.add(id) }\n          }\n        }\n      }\n\n      // prune/graft helper functions (defined per topic)\n      const prunePeer = (id: PeerIdStr, reason: ChurnReason): void => {\n        this.log('HEARTBEAT: Remove mesh link to %s in %s', id, topic)\n        // no need to update peer score here as we do it in makePrune\n        // add prune backoff record\n        this.addBackoff(id, topic)\n        // remove peer from mesh\n        peers.delete(id)\n        // after pruning a peer from mesh, we want to gossip topic to it if its score meet the gossip threshold\n        if (getScore(id) >= this.opts.scoreThresholds.gossipThreshold) { peersToGossip.add(id) }\n        this.metrics?.onRemoveFromMesh(topic, reason, 1)\n        // add to toprune\n        const topics = toprune.get(id)\n        if (topics == null) {\n          toprune.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      const graftPeer = (id: PeerIdStr, reason: InclusionReason): void => {\n        this.log('HEARTBEAT: Add mesh link to %s in %s', id, topic)\n        // update peer score\n        this.score.graft(id, topic)\n        // add peer to mesh\n        peers.add(id)\n        // when we add a new mesh peer, we don't want to gossip messages to it\n        peersToGossip.delete(id)\n        this.metrics?.onAddToMesh(topic, reason, 1)\n        // add to tograft\n        const topics = tograft.get(id)\n        if (topics == null) {\n          tograft.set(id, [topic])\n        } else {\n          topics.push(topic)\n        }\n      }\n\n      // drop all peers with negative score, without PX\n      peers.forEach((id) => {\n        const score = getScore(id)\n\n        // Record the score\n\n        if (score < 0) {\n          this.log('HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s', id, score, topic)\n          prunePeer(id, ChurnReason.BadScore)\n          noPX.set(id, true)\n        }\n      })\n\n      // do we have enough peers?\n      if (peers.size < Dlo) {\n        const ineed = D - peers.size\n        // slice up to first `ineed` items and remove them from candidateMeshPeers\n        // same to `const newMeshPeers = candidateMeshPeers.slice(0, ineed)`\n        const newMeshPeers = removeFirstNItemsFromSet(candidateMeshPeers, ineed)\n\n        newMeshPeers.forEach((p) => {\n          graftPeer(p, InclusionReason.NotEnough)\n        })\n      }\n\n      // do we have to many peers?\n      if (peers.size > Dhi) {\n        let peersArray = Array.from(peers)\n        // sort by score\n        peersArray.sort((a, b) => getScore(b) - getScore(a))\n        // We keep the first D_score peers by score and the remaining up to D randomly\n        // under the constraint that we keep D_out peers in the mesh (if we have that many)\n        peersArray = peersArray.slice(0, Dscore).concat(shuffle(peersArray.slice(Dscore)))\n\n        // count the outbound peers we are keeping\n        let outbound = 0\n        peersArray.slice(0, D).forEach((p) => {\n          if (this.outbound.get(p) ?? false) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, bubble up some outbound peers from the random selection\n        if (outbound < Dout) {\n          const rotate = (i: number): void => {\n            // rotate the peersArray to the right and put the ith peer in the front\n            const p = peersArray[i]\n            for (let j = i; j > 0; j--) {\n              peersArray[j] = peersArray[j - 1]\n            }\n            peersArray[0] = p\n          }\n\n          // first bubble up all outbound peers already in the selection to the front\n          if (outbound > 0) {\n            let ihave = outbound\n            for (let i = 1; i < D && ihave > 0; i++) {\n              // eslint-disable-next-line max-depth\n              if (this.outbound.get(peersArray[i]) ?? false) {\n                rotate(i)\n                ihave--\n              }\n            }\n          }\n\n          // now bubble up enough outbound peers outside the selection to the front\n          let ineed = D - outbound\n          for (let i = D; i < peersArray.length && ineed > 0; i++) {\n            if (this.outbound.get(peersArray[i]) ?? false) {\n              rotate(i)\n              ineed--\n            }\n          }\n        }\n\n        // prune the excess peers\n        peersArray.slice(D).forEach((p) => {\n          prunePeer(p, ChurnReason.Excess)\n        })\n      }\n\n      // do we have enough outbound peers?\n      if (peers.size >= Dlo) {\n        // count the outbound peers we have\n        let outbound = 0\n        peers.forEach((p) => {\n          if (this.outbound.get(p) ?? false) {\n            outbound++\n          }\n        })\n\n        // if it's less than D_out, select some peers with outbound connections and graft them\n        if (outbound < Dout) {\n          const ineed = Dout - outbound\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => this.outbound.get(id) === true)\n\n          newMeshPeers.forEach((p) => {\n            graftPeer(p, InclusionReason.Outbound)\n          })\n        }\n      }\n\n      // should we try to improve the mesh with opportunistic grafting?\n      if (this.heartbeatTicks % this.opts.opportunisticGraftTicks === 0 && peers.size > 1) {\n        // Opportunistic grafting works as follows: we check the median score of peers in the\n        // mesh; if this score is below the opportunisticGraftThreshold, we select a few peers at\n        // random with score over the median.\n        // The intention is to (slowly) improve an underperforming mesh by introducing good\n        // scoring peers that may have been gossiping at us. This allows us to get out of sticky\n        // situations where we are stuck with poor peers and also recover from churn of good peers.\n\n        // now compute the median peer score in the mesh\n        const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b))\n        const medianIndex = Math.floor(peers.size / 2)\n        const medianScore = getScore(peersList[medianIndex])\n\n        // if the median score is below the threshold, select a better peer (if any) and GRAFT\n        if (medianScore < this.opts.scoreThresholds.opportunisticGraftThreshold) {\n          const ineed = this.opts.opportunisticGraftPeers\n          const newMeshPeers = removeItemsFromSet(candidateMeshPeers, ineed, (id) => getScore(id) > medianScore)\n          for (const id of newMeshPeers) {\n            this.log('HEARTBEAT: Opportunistically graft peer %s on topic %s', id, topic)\n            graftPeer(id, InclusionReason.Opportunistic)\n          }\n        }\n      }\n    })\n\n    // expire fanout for topics we haven't published to in a while\n    const now = Date.now()\n    this.fanoutLastpub.forEach((lastpb, topic) => {\n      if (lastpb + fanoutTTL < now) {\n        this.fanout.delete(topic)\n        this.fanoutLastpub.delete(topic)\n      }\n    })\n\n    // maintain our fanout for topics we are publishing but we have not joined\n    this.fanout.forEach((fanoutPeers, topic) => {\n      // checks whether our peers are still in the topic and have a score above the publish threshold\n      const topicPeers = this.topics.get(topic)\n      fanoutPeers.forEach((id) => {\n        if (!(topicPeers?.has(id) ?? false) || getScore(id) < this.opts.scoreThresholds.publishThreshold) {\n          fanoutPeers.delete(id)\n        }\n      })\n\n      const peersInTopic = this.topics.get(topic)\n      const candidateFanoutPeers = []\n      // the fanout map contains topics to which we are not subscribed.\n      const peersToGossip = new Set<PeerIdStr>()\n      peersToGossipByTopic.set(topic, peersToGossip)\n\n      if (peersInTopic != null) {\n        const shuffledPeers = shuffle(Array.from(peersInTopic))\n        for (const id of shuffledPeers) {\n          const peerStreams = this.streamsOutbound.get(id)\n          if (\n            (peerStreams != null) &&\n            this.protocols.includes(peerStreams.protocol) &&\n            !fanoutPeers.has(id) &&\n            !this.direct.has(id)\n          ) {\n            const score = getScore(id)\n            if (score >= this.opts.scoreThresholds.publishThreshold) { candidateFanoutPeers.push(id) }\n            // instead of having to find gossip peers after heartbeat which require another loop\n            // we prepare peers to gossip in a topic within heartbeat to improve performance\n            if (score >= this.opts.scoreThresholds.gossipThreshold) { peersToGossip.add(id) }\n          }\n        }\n      }\n\n      // do we need more peers?\n      if (fanoutPeers.size < D) {\n        const ineed = D - fanoutPeers.size\n        candidateFanoutPeers.slice(0, ineed).forEach((id) => {\n          fanoutPeers.add(id)\n          peersToGossip?.delete(id)\n        })\n      }\n    })\n\n    this.emitGossip(peersToGossipByTopic)\n\n    // send coalesced GRAFT/PRUNE messages (will piggyback gossip)\n    await this.sendGraftPrune(tograft, toprune, noPX)\n\n    // flush pending gossip that wasn't piggybacked above\n    this.flush()\n\n    // advance the message history window\n    this.mcache.shift()\n\n    this.dispatchEvent(new CustomEvent('gossipsub:heartbeat'))\n  }\n\n  /**\n   * Given a topic, returns up to count peers subscribed to that topic\n   * that pass an optional filter function\n   *\n   * @param topic\n   * @param count\n   * @param filter - a function to filter acceptable peers\n   */\n  private getRandomGossipPeers (\n    topic: string,\n    count: number,\n    filter: (id: string) => boolean = () => true\n  ): Set<string> {\n    const peersInTopic = this.topics.get(topic)\n\n    if (peersInTopic == null) {\n      return new Set()\n    }\n\n    // Adds all peers using our protocol\n    // that also pass the filter function\n    let peers: string[] = []\n    peersInTopic.forEach((id) => {\n      const peerStreams = this.streamsOutbound.get(id)\n      if (peerStreams == null) {\n        return\n      }\n      if (this.protocols.includes(peerStreams.protocol) && filter(id)) {\n        peers.push(id)\n      }\n    })\n\n    // Pseudo-randomly shuffles peers\n    peers = shuffle(peers)\n    if (count > 0 && peers.length > count) {\n      peers = peers.slice(0, count)\n    }\n\n    return new Set(peers)\n  }\n\n  private onScrapeMetrics (metrics: Metrics): void {\n    /* Data structure sizes */\n    metrics.mcacheSize.set(this.mcache.size)\n    metrics.mcacheNotValidatedCount.set(this.mcache.notValidatedCount)\n    // Arbitrary size\n    metrics.cacheSize.set({ cache: 'direct' }, this.direct.size)\n    metrics.cacheSize.set({ cache: 'seenCache' }, this.seenCache.size)\n    metrics.cacheSize.set({ cache: 'fastMsgIdCache' }, this.fastMsgIdCache?.size ?? 0)\n    metrics.cacheSize.set({ cache: 'publishedMessageIds' }, this.publishedMessageIds.size)\n    metrics.cacheSize.set({ cache: 'mcache' }, this.mcache.size)\n    metrics.cacheSize.set({ cache: 'score' }, this.score.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.promises' }, this.gossipTracer.size)\n    metrics.cacheSize.set({ cache: 'gossipTracer.requests' }, this.gossipTracer.requestMsByMsgSize)\n    // Bounded by topic\n    metrics.cacheSize.set({ cache: 'topics' }, this.topics.size)\n    metrics.cacheSize.set({ cache: 'subscriptions' }, this.subscriptions.size)\n    metrics.cacheSize.set({ cache: 'mesh' }, this.mesh.size)\n    metrics.cacheSize.set({ cache: 'fanout' }, this.fanout.size)\n    // Bounded by peer\n    metrics.cacheSize.set({ cache: 'peers' }, this.peers.size)\n    metrics.cacheSize.set({ cache: 'streamsOutbound' }, this.streamsOutbound.size)\n    metrics.cacheSize.set({ cache: 'streamsInbound' }, this.streamsInbound.size)\n    metrics.cacheSize.set({ cache: 'acceptFromWhitelist' }, this.acceptFromWhitelist.size)\n    metrics.cacheSize.set({ cache: 'gossip' }, this.gossip.size)\n    metrics.cacheSize.set({ cache: 'control' }, this.control.size)\n    metrics.cacheSize.set({ cache: 'peerhave' }, this.peerhave.size)\n    metrics.cacheSize.set({ cache: 'outbound' }, this.outbound.size)\n\n    // 2D nested data structure\n    let backoffSize = 0\n    const now = Date.now()\n    metrics.connectedPeersBackoffSec.reset()\n    for (const backoff of this.backoff.values()) {\n      backoffSize += backoff.size\n      for (const [peer, expiredMs] of backoff.entries()) {\n        if (this.peers.has(peer)) {\n          metrics.connectedPeersBackoffSec.observe(Math.max(0, expiredMs - now) / 1000)\n        }\n      }\n    }\n    metrics.cacheSize.set({ cache: 'backoff' }, backoffSize)\n\n    let idontwantsCount = 0\n    for (const idontwant of this.idontwants.values()) {\n      idontwantsCount += idontwant.size\n    }\n    metrics.cacheSize.set({ cache: 'idontwants' }, idontwantsCount)\n\n    // Peer counts\n\n    for (const [topicStr, peers] of this.topics) {\n      metrics.topicPeersCount.set({ topicStr }, peers.size)\n    }\n\n    for (const [topicStr, peers] of this.mesh) {\n      metrics.meshPeerCounts.set({ topicStr }, peers.size)\n    }\n\n    // Peer scores\n\n    const scores: number[] = []\n    const scoreByPeer = new Map<PeerIdStr, number>()\n    metrics.behaviourPenalty.reset()\n\n    for (const peerIdStr of this.peers.keys()) {\n      const score = this.score.score(peerIdStr)\n      scores.push(score)\n      scoreByPeer.set(peerIdStr, score)\n      metrics.behaviourPenalty.observe(this.score.peerStats.get(peerIdStr)?.behaviourPenalty ?? 0)\n    }\n\n    metrics.registerScores(scores, this.opts.scoreThresholds)\n\n    // Breakdown score per mesh topicLabel\n\n    metrics.registerScorePerMesh(this.mesh, scoreByPeer)\n\n    // Breakdown on each score weight\n\n    const sw = computeAllPeersScoreWeights(\n      this.peers.keys(),\n      this.score.peerStats,\n      this.score.params,\n      this.score.peerIPs,\n      metrics.topicStrToLabel\n    )\n\n    metrics.registerScoreWeights(sw)\n  }\n\n  private readonly tagMeshPeer = (evt: CustomEvent<MeshPeer>): void => {\n    const { peerId, topic } = evt.detail\n    this.components.peerStore.merge(this.peers.get(peerId) ?? peerIdFromString(peerId), {\n      tags: {\n        [topic]: {\n          value: 100\n        }\n      }\n    }).catch((err) => { this.log.error('Error tagging peer %s with topic %s', peerId, topic, err) })\n  }\n\n  private readonly untagMeshPeer = (evt: CustomEvent<MeshPeer>): void => {\n    const { peerId, topic } = evt.detail\n    this.components.peerStore.merge(this.peers.get(peerId) ?? peerIdFromString(peerId), {\n      tags: {\n        [topic]: undefined\n      }\n    }).catch((err) => { this.log.error('Error untagging peer %s with topic %s', peerId, topic, err) })\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_denque", "__commonJSMin", "exports", "module", "Denque", "array", "options", "index", "i", "len", "item", "head", "tail", "size", "k", "count", "removed", "del_count", "temp", "arg_len", "arguments_index", "leng", "length", "capacity", "fullCopy", "src", "dest", "newList", "num", "log2", "nextPow2", "index_exports", "__export", "StrictNoSign", "StrictSign", "TopicValidatorResult", "gossipsub", "multicodec", "FloodsubID", "GossipsubIDv10", "GossipsubIDv11", "GossipsubIDv12", "ERR_TOPIC_VALIDATOR_REJECT", "ERR_TOPIC_VALIDATOR_IGNORE", "InvalidParametersError", "message", "InvalidPublicKeyError", "InvalidCIDError", "message", "InvalidMultihashError", "UnsupportedKeyTypeError", "message", "peerIdSymbol", "TypedEventEmitter", "#listeners", "type", "listeners", "listener", "options", "list", "callback", "event", "result", "once", "detail", "serviceCapabilities", "serviceDependencies", "base58_exports", "__export", "base58btc", "base58flickr", "empty", "equals", "aa", "bb", "ii", "coerce", "o", "fromString", "str", "toString", "b", "base", "ALPHABET", "name", "BASE_MAP", "j", "i", "x", "xc", "BASE", "LEADER", "FACTOR", "iFACTOR", "encode", "source", "zeroes", "length", "pbegin", "pend", "size", "b58", "carry", "it1", "it2", "str", "decodeUnsafe", "psz", "b256", "it3", "it4", "vch", "decode", "string", "buffer", "src", "_brrp__multiformats_scope_baseX", "base_x_default", "Encoder", "name", "prefix", "baseEncode", "bytes", "Decoder", "baseDecode", "prefixCodePoint", "text", "decoder", "or", "ComposedDecoder", "decoders", "input", "left", "right", "Codec", "from", "encode", "decode", "baseX", "alphabet", "base_x_default", "coerce", "string", "alphabetIdx", "bitsPerChar", "end", "out", "bits", "buffer", "written", "i", "value", "data", "pad", "mask", "createAlphabetIdx", "rfc4648", "base58btc", "baseX", "base58flickr", "base32_exports", "__export", "base32", "base32hex", "base32hexpad", "base32hexpadupper", "base32hexupper", "base32pad", "base32padupper", "base32upper", "base32z", "base32", "rfc4648", "base32upper", "base32pad", "base32padupper", "base32hex", "base32hexupper", "base32hexpad", "base32hexpadupper", "base32z", "base36_exports", "__export", "base36", "base36upper", "base36", "baseX", "base36upper", "encode_1", "encode", "MSB", "REST", "MSBALL", "INT", "num", "out", "offset", "oldOffset", "decode", "read", "MSB$1", "REST$1", "buf", "res", "shift", "counter", "b", "l", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "N8", "N9", "length", "value", "varint", "_brrp_varint", "varint_default", "decode", "data", "offset", "varint_default", "encodeTo", "int", "target", "encodingLength", "create", "code", "digest", "size", "sizeOffset", "encodingLength", "digestOffset", "bytes", "encodeTo", "Digest", "decode", "multihash", "coerce", "equals", "a", "b", "data", "format", "link", "base", "bytes", "version", "toStringV0", "baseCache", "base58btc", "toStringV1", "base32", "cache", "baseCache", "cid", "CID", "_CID", "version", "code", "multihash", "bytes", "DAG_PB_CODE", "SHA_256_CODE", "digest", "create", "other", "self", "unknown", "equals", "base", "format", "input", "value", "encodeCID", "cidSymbol", "decode", "remainder", "specs", "prefixSize", "multihashBytes", "coerce", "digestBytes", "Digest", "initialBytes", "offset", "next", "i", "length", "codec", "multihashCode", "digestSize", "size", "multihashSize", "source", "prefix", "parseCIDtoBytes", "decoder", "base58btc", "base32", "base36", "toStringV0", "toStringV1", "codeOffset", "encodingLength", "hashOffset", "encodeTo", "identity_exports", "__export", "identity", "code", "name", "encode", "coerce", "digest", "input", "options", "create", "identity", "equals", "a", "b", "i", "alloc", "size", "allocUnsafe", "concat", "arrays", "length", "acc", "curr", "output", "allocUnsafe", "offset", "arr", "symbol", "findBufAndOffset", "bufs", "index", "offset", "buf", "bufEnd", "isUint8ArrayList", "value", "Uint8ArrayList", "_Uint8ArrayList", "data", "length", "res", "i", "bytes", "beginInclusive", "endExclusive", "concat", "list", "bufStart", "sliceStartInBuf", "sliceEndsInBuf", "start", "search", "needle", "M", "radix", "rightmostPositions", "c", "j", "right", "lastIndex", "lastPatIndex", "skip", "char", "byteOffset", "allocUnsafe", "littleEndian", "alloc", "other", "equals", "acc", "curr", "base10_exports", "__export", "base10", "base10", "baseX", "base16_exports", "__export", "base16", "base16upper", "base16", "rfc4648", "base16upper", "base2_exports", "__export", "base2", "base2", "rfc4648", "base256emoji_exports", "__export", "base256emoji", "alphabet", "alphabetBytesToChars", "p", "c", "i", "alphabetCharsToBytes", "codePoint", "encode", "data", "decode", "str", "byts", "char", "byt", "base256emoji", "from", "base64_exports", "__export", "base64", "base64pad", "base64url", "base64urlpad", "base64", "rfc4648", "base64pad", "base64url", "base64urlpad", "base8_exports", "__export", "base8", "base8", "rfc4648", "identity_exports", "__export", "identity", "identity", "from", "buf", "toString", "str", "fromString", "textEncoder", "textDecoder", "sha2_browser_exports", "__export", "sha256", "sha512", "DEFAULT_MIN_DIGEST_LENGTH", "from", "name", "code", "encode", "minDigestLength", "maxDigestLength", "Hasher", "input", "options", "result", "createDigest", "digest", "truncate", "create", "sha", "name", "data", "sha256", "from", "sha512", "bases", "identity_exports", "base2_exports", "base8_exports", "base10_exports", "base16_exports", "base32_exports", "base36_exports", "base58_exports", "base64_exports", "base256emoji_exports", "hashes", "sha2_browser_exports", "createCodec", "name", "prefix", "encode", "decode", "string", "buf", "str", "ascii", "i", "allocUnsafe", "BASES", "bases", "bases_default", "fromString", "string", "encoding", "base", "bases_default", "toString", "array", "encoding", "base", "bases_default", "TAG_MASK", "LONG_LENGTH_MASK", "LONG_LENGTH_BYTES_MASK", "decoders", "readSequence", "readInteger", "readBitString", "readOctetString", "readNull", "readObjectIdentifier", "decodeDer", "buf", "context", "tag", "readLength", "length", "count", "str", "entries", "result", "start", "end", "vals", "i", "finalOffset", "byte", "val1", "val2", "oid", "num", "val", "unusedBits", "bytes", "encodeNumber", "value", "number", "array", "Uint8ArrayList", "encodeLength", "encodeInteger", "contents", "mask", "encodeBitString", "encodeSequence", "values", "tag", "output", "Uint8ArrayList", "buf", "encodeLength", "hashAndVerify", "key", "sig", "msg", "options", "publicKey", "result", "OID_256", "OID_384", "OID_521", "P_256_KEY_JWK", "P_384_KEY_JWK", "P_521_KEY_JWK", "P_256_KEY_LENGTH", "P_384_KEY_LENGTH", "P_521_KEY_LENGTH", "unmarshalECDSAPublicKey", "bytes", "message", "decodeDer", "pkiMessageToECDSAPublicKey", "coordinates", "offset", "x", "y", "P_256_KEY_LENGTH", "toString", "ECDSAPublicKey", "P_256_KEY_JWK", "P_384_KEY_LENGTH", "P_384_KEY_JWK", "P_521_KEY_LENGTH", "P_521_KEY_JWK", "InvalidParametersError", "publicKeyToPKIMessage", "publicKey", "encodeSequence", "encodeInteger", "getOID", "encodeBitString", "Uint8ArrayList", "fromString", "curve", "OID_256", "OID_384", "OID_521", "InvalidParametersError", "ECDSAPublicKey", "jwk", "publicKeyToPKIMessage", "identity", "publicKeyToProtobuf", "CID", "base58btc", "key", "equals", "data", "sig", "options", "hashAndVerify", "isBytes", "a", "anumber", "n", "title", "prefix", "abytes", "value", "length", "bytes", "len", "needsLen", "ofLen", "got", "ahash", "h", "aexists", "instance", "checkFinished", "aoutput", "out", "min", "clean", "arrays", "i", "createView", "arr", "rotr", "word", "shift", "hasHexBuiltin", "hexes", "_", "i", "bytesToHex", "bytes", "abytes", "hex", "asciis", "asciiToBase16", "ch", "hexToBytes", "hl", "al", "array", "ai", "hi", "n1", "n2", "char", "concatBytes", "arrays", "sum", "i", "a", "abytes", "res", "pad", "createHasher", "hashCons", "info", "hashC", "msg", "opts", "tmp", "randomBytes", "bytesLength", "cr", "oidNist", "suffix", "Chi", "a", "b", "c", "Maj", "HashMD", "blockLen", "outputLen", "padOffset", "isLE", "createView", "data", "aexists", "abytes", "view", "buffer", "len", "pos", "take", "dataView", "out", "aoutput", "clean", "i", "oview", "outLen", "state", "res", "to", "length", "finished", "destroyed", "SHA256_IV", "SHA512_IV", "U32_MASK64", "_32n", "fromBig", "n", "le", "split", "lst", "len", "Ah", "Al", "h", "l", "shrSH", "h", "_l", "s", "shrSL", "l", "rotrSH", "rotrSL", "rotrBH", "rotrBL", "add", "Ah", "Al", "Bh", "Bl", "l", "add3L", "Cl", "add3H", "low", "Ch", "add4L", "Dl", "add4H", "Dh", "add5L", "El", "add5H", "Eh", "SHA256_K", "SHA256_W", "SHA2_32B", "HashMD", "outputLen", "A", "B", "C", "D", "E", "F", "G", "H", "view", "offset", "i", "W15", "W2", "s0", "rotr", "s1", "sigma1", "T1", "Chi", "T2", "Maj", "clean", "_SHA256", "SHA256_IV", "K512", "split", "n", "SHA512_Kh", "SHA512_Kl", "SHA512_W_H", "SHA512_W_L", "SHA2_64B", "HashMD", "outputLen", "Ah", "Al", "Bh", "Bl", "Ch", "Cl", "Dh", "Dl", "Eh", "El", "Fh", "Fl", "Gh", "Gl", "Hh", "Hl", "view", "offset", "i", "W15h", "W15l", "s0h", "rotrSH", "shrSH", "s0l", "rotrSL", "shrSL", "W2h", "W2l", "s1h", "rotrBH", "s1l", "rotrBL", "SUMl", "add4L", "SUMh", "add4H", "sigma1h", "sigma1l", "CHIh", "CHIl", "T1ll", "add5L", "T1h", "add5H", "T1l", "sigma0h", "sigma0l", "MAJh", "MAJl", "add", "All", "add3L", "add3H", "clean", "_SHA512", "SHA512_IV", "sha256", "createHasher", "_SHA256", "oidNist", "sha512", "createHasher", "_SHA512", "oidNist", "_0n", "_1n", "abool", "value", "title", "prefix", "abignumber", "n", "isPosBig", "anumber", "numberToHexUnpadded", "num", "hex", "abignumber", "hexToNumber", "_0n", "bytesToNumberBE", "bytes", "bytesToHex", "bytesToNumberLE", "copyBytes", "abytes", "numberToBytesBE", "n", "len", "anumber", "res", "hexToBytes", "numberToBytesLE", "copyBytes", "bytes", "isPosBig", "n", "_0n", "inRange", "min", "max", "aInRange", "title", "bitLen", "len", "_1n", "bitMask", "n", "_1n", "createHmacDrbg", "hashLen", "qByteLen", "hmacFn", "anumber", "u8n", "len", "NULL", "byte0", "byte1", "_maxDrbgIters", "v", "k", "i", "reset", "h", "msgs", "concatBytes", "reseed", "seed", "gen", "out", "sl", "pred", "res", "validateObject", "object", "fields", "optFields", "checkField", "fieldName", "expectedType", "isOpt", "val", "current", "iter", "f", "memoized", "fn", "map", "arg", "args", "val", "computed", "_0n", "_1n", "_2n", "_3n", "_4n", "_5n", "_7n", "_8n", "_9n", "_16n", "mod", "a", "b", "result", "pow2", "x", "power", "modulo", "res", "_0n", "invert", "number", "a", "mod", "b", "y", "_1n", "u", "v", "q", "r", "m", "n", "assertIsSquare", "Fp", "root", "sqrt3mod4", "p1div4", "_4n", "sqrt5mod8", "p5div8", "_5n", "_8n", "n2", "_2n", "nv", "i", "sqrt9mod16", "P", "Fp_", "Field", "tn", "tonelliShanks", "c1", "c2", "c3", "c4", "_7n", "_16n", "tv1", "tv2", "tv3", "tv4", "e1", "e2", "e3", "_3n", "Q", "S", "Z", "_Fp", "FpLegendre", "cc", "Q1div2", "M", "c", "t", "R", "t_tmp", "exponent", "FpSqrt", "_9n", "isNegativeLE", "num", "FIELD_FIELDS", "validateField", "field", "initial", "opts", "map", "val", "validateObject", "FpPow", "p", "d", "FpInvertBatch", "nums", "passZero", "inverted", "multipliedAcc", "acc", "invertedAcc", "FpLegendre", "Fp", "n", "p1mod2", "_1n", "_2n", "powered", "yes", "zero", "no", "nLength", "n", "nBitLength", "anumber", "_nBitLength", "nByteLength", "_Field", "_0n", "_1n", "ORDER", "opts", "_nbitLength", "num", "mod", "lhs", "rhs", "power", "FpPow", "invert", "FpSqrt", "numberToBytesLE", "numberToBytesBE", "bytes", "skipValidation", "abytes", "allowedLengths", "BYTES", "isLE", "modFromBytes", "padded", "scalar", "bytesToNumberLE", "bytesToNumberBE", "lst", "FpInvertBatch", "a", "b", "condition", "Field", "getFieldBytesLength", "fieldOrder", "bitLength", "getMinHashLength", "length", "mapHashToField", "key", "isLE", "abytes", "len", "fieldLen", "minLen", "num", "bytesToNumberLE", "bytesToNumberBE", "reduced", "mod", "_1n", "numberToBytesLE", "numberToBytesBE", "_0n", "_1n", "negateCt", "condition", "item", "neg", "normalizeZ", "c", "points", "invertedZs", "FpInvertBatch", "p", "i", "validateW", "W", "bits", "calcWOpts", "scalarBits", "windows", "windowSize", "maxNumber", "mask", "bitMask", "shiftBy", "calcOffsets", "n", "window", "wOpts", "wbits", "nextN", "offsetStart", "offset", "isZero", "isNeg", "isNegF", "pointPrecomputes", "pointWindowSizes", "getW", "P", "assert0", "n", "_0n", "wNAF", "Point", "bits", "elm", "p", "d", "_1n", "point", "W", "windows", "windowSize", "calcWOpts", "points", "base", "window", "i", "precomputes", "f", "wo", "nextN", "offset", "isZero", "isNeg", "isNegF", "offsetF", "calcOffsets", "negateCt", "acc", "item", "transform", "comp", "scalar", "prev", "validateW", "mulEndoUnsafe", "k1", "k2", "p1", "p2", "createField", "order", "field", "isLE", "validateField", "Field", "createCurveFields", "type", "CURVE", "curveOpts", "FpFnLE", "p", "val", "_0n", "Fp", "Fn", "params", "createKeygen", "randomSecretKey", "getPublicKey", "seed", "secretKey", "_0n", "_1n", "_2n", "_8n", "isEdValidXY", "Fp", "CURVE", "x", "y", "x2", "y2", "left", "right", "edwards", "params", "extraOpts", "validated", "createCurveFields", "Fn", "cofactor", "validateObject", "MASK", "modP", "n", "uvRatio", "u", "v", "acoord", "title", "banZero", "min", "aInRange", "aedpoint", "other", "Point", "toAffineMemo", "memoized", "p", "iz", "X", "Y", "Z", "is0", "zz", "assertValidMemo", "a", "d", "T", "X2", "Y2", "Z2", "Z4", "aX2", "XY", "ZT", "bytes", "zip215", "len", "copyBytes", "abytes", "abool", "normed", "lastByte", "bytesToNumberLE", "max", "isValid", "isXOdd", "isLastByteOdd", "hex", "hexToBytes", "windowSize", "isLazy", "wnaf", "X1", "Y1", "Z1", "X1Z2", "X2Z1", "Y1Z2", "Y2Z1", "A", "B", "C", "D", "x1y1", "E", "G", "F", "H", "X3", "Y3", "T3", "Z3", "T1", "T2", "scalar", "f", "normalizeZ", "acc", "invertedZ", "bytesToHex", "wNAF", "eddsa", "Point", "cHash", "eddsaOpts", "validateObject", "prehash", "BASE", "Fp", "Fn", "randomBytes", "adjustScalarBytes", "bytes", "domain", "data", "ctx", "phflag", "abool", "modN_LE", "hash", "bytesToNumberLE", "getPrivateScalar", "key", "len", "lengths", "abytes", "hashed", "head", "prefix", "scalar", "getExtendedPublicKey", "secretKey", "point", "pointBytes", "getPublicKey", "hashDomainToScalar", "context", "msgs", "msg", "concatBytes", "sign", "options", "r", "R", "k", "s", "rs", "verifyOpts", "verify", "sig", "publicKey", "zip215", "mid", "A", "SB", "_size", "randomSecretKey", "seed", "isValidSecretKey", "isBytes", "isValidPublicKey", "utils", "y", "size", "is25519", "u", "_1n", "createKeygen", "_1n", "_2n", "_5n", "_8n", "ed25519_CURVE_p", "ed25519_CURVE", "ed25519_pow_2_252_3", "x", "_10n", "_20n", "_40n", "_80n", "P", "b2", "b4", "pow2", "_2n", "b5", "_1n", "b10", "b20", "b40", "b80", "b160", "b240", "b250", "adjustScalarBytes", "bytes", "ED25519_SQRT_M1", "uvRatio", "u", "v", "v3", "mod", "v7", "pow", "vx2", "root1", "root2", "useRoot1", "useRoot2", "noRoot", "isNegativeLE", "ed25519_Point", "edwards", "ed", "opts", "eddsa", "ed25519_Point", "sha512", "adjustScalarBytes", "ed25519", "VerificationError", "message", "WebCryptoMissingError", "webcrypto_browser_default", "win", "nativeCrypto", "WebCryptoMissingError", "webcrypto_default", "webcrypto_browser_default", "PUBLIC_KEY_BYTE_LENGTH", "ed25519Supported", "webCryptoEd25519SupportedPromise", "webcrypto_default", "hashAndVerifyWebCrypto", "publicKey", "sig", "msg", "key", "webcrypto_default", "hashAndVerifyNoble", "ed25519", "hashAndVerify", "ed25519Supported", "webCryptoEd25519SupportedPromise", "isPromise", "thing", "Ed25519PublicKey", "key", "ensureEd25519Key", "PUBLIC_KEY_BYTE_LENGTH", "identity", "publicKeyToProtobuf", "CID", "base58btc", "equals", "data", "sig", "options", "result", "hashAndVerify", "isPromise", "res", "unmarshalEd25519PublicKey", "bytes", "ensureEd25519Key", "PUBLIC_KEY_BYTE_LENGTH", "Ed25519PublicKey", "ensureEd25519Key", "key", "length", "InvalidParametersError", "N1", "N2", "N3", "N4", "N5", "N6", "N7", "MSB", "REST", "encodingLength", "value", "encodeUint8Array", "buf", "offset", "encodeUint8ArrayList", "decodeUint8Array", "b", "res", "decodeUint8ArrayList", "encode", "allocUnsafe", "decode", "f32", "f8b", "writeFloatLE", "val", "buf", "pos", "readFloatLE", "buf", "pos", "f8b", "f32", "f64", "d8b", "writeDoubleLE", "val", "buf", "pos", "readDoubleLE", "buf", "pos", "d8b", "f64", "MAX_SAFE_NUMBER_INTEGER", "MIN_SAFE_NUMBER_INTEGER", "LongBits", "_LongBits", "lo", "hi", "unsigned", "mask", "part0", "part1", "part2", "value", "zero", "negative", "TWO_32", "sign", "length", "string", "len", "c", "i", "read", "buffer", "start", "end", "parts", "chunk", "t", "write", "offset", "c1", "c2", "indexOutOfRange", "reader", "writeLength", "readFixed32End", "buf", "end", "Uint8ArrayReader", "buffer", "value", "readFloatLE", "readDoubleLE", "length", "start", "bytes", "read", "wireType", "bits", "LongBits", "i", "lo", "hi", "decodeUint8Array", "encodingLength", "createReader", "decodeMessage", "buf", "codec", "opts", "reader", "createReader", "pool", "size", "SIZE", "MAX", "slab", "offset", "allocUnsafe", "buf", "Op", "fn", "len", "val", "noop", "State", "writer", "bufferPool", "pool", "alloc", "size", "allocUnsafe", "Uint8ArrayWriter", "value", "VarintOp", "writeVarint64", "LongBits", "bits", "encodeUint8Array", "encodingLength", "writeByte", "writeFixed32", "writeFloatLE", "writeDoubleLE", "writeBytes", "length", "write", "head", "tail", "buf", "pos", "writeVarint32", "writeBytesBuffer", "writeStringBuffer", "fromString", "createWriter", "encodeMessage", "message", "codec", "w", "createWriter", "CODEC_TYPES", "createCodec", "name", "type", "encode", "decode", "enumeration", "v", "findValue", "val", "encode", "writer", "enumValue", "decode", "reader", "createCodec", "CODEC_TYPES", "message", "encode", "decode", "createCodec", "CODEC_TYPES", "MaxLengthError", "KeyType", "__KeyTypeValues", "enumeration", "PublicKey", "_codec", "message", "obj", "w", "opts", "reader", "length", "end", "tag", "encodeMessage", "buf", "decodeMessage", "PrivateKey", "randomBytes", "length", "InvalidParametersError", "utils_exports", "__export", "MAX_RSA_KEY_SIZE", "generateRSAKeyPair", "jwkToJWKKeyPair", "jwkToPkcs1", "jwkToPkix", "jwkToRSAPrivateKey", "pkcs1MessageToJwk", "pkcs1MessageToRSAPrivateKey", "pkcs1ToJwk", "pkcs1ToRSAPrivateKey", "pkixMessageToJwk", "pkixMessageToRSAPublicKey", "pkixToJwk", "pkixToRSAPublicKey", "RSAPublicKey", "jwk", "digest", "utils_exports", "CID", "base58btc", "key", "equals", "data", "sig", "options", "hashAndVerify", "RSAPrivateKey", "publicKey", "message", "hashAndSign", "MAX_RSA_KEY_SIZE", "SHA2_256_CODE", "MAX_RSA_JWK_SIZE", "RSA_ALGORITHM_IDENTIFIER", "pkcs1ToJwk", "bytes", "message", "decodeDer", "pkcs1MessageToJwk", "toString", "jwkToPkcs1", "jwk", "InvalidParametersError", "encodeSequence", "encodeInteger", "fromString", "pkixToJwk", "pkixMessageToJwk", "keys", "jwkToPkix", "encodeBitString", "pkcs1ToRSAPrivateKey", "pkcs1MessageToRSAPrivateKey", "jwkToRSAPrivateKey", "pkixToRSAPublicKey", "digest", "InvalidPublicKeyError", "pkixMessageToRSAPublicKey", "hash", "sha256", "PublicKey", "KeyType", "create", "RSAPublicKey", "rsaKeySize", "jwkToJWKKeyPair", "RSAPrivateKey", "generateRSAKeyPair", "bits", "generateRSAKey", "key", "generateRSAKey", "bits", "options", "pair", "webcrypto_default", "keys", "exportKey", "hashAndSign", "key", "msg", "options", "privateKey", "webcrypto_default", "sig", "hashAndVerify", "publicKey", "result", "exportKey", "pair", "InvalidParametersError", "rsaKeySize", "jwk", "fromString", "_HMAC", "hash", "key", "ahash", "abytes", "blockLen", "pad", "clean", "buf", "aexists", "out", "to", "oHash", "iHash", "finished", "destroyed", "outputLen", "hmac", "message", "divNearest", "num", "den", "_2n", "_splitEndoScalar", "k", "basis", "n", "a1", "b1", "a2", "b2", "c1", "c2", "k1", "k2", "k1neg", "_0n", "k2neg", "MAX_NUM", "bitMask", "bitLen", "_1n", "validateSigFormat", "format", "validateSigOpts", "opts", "def", "optsn", "optName", "abool", "DERErr", "m", "DER", "tag", "data", "E", "dataLen", "len", "numberToHexUnpadded", "lenLen", "pos", "first", "isLong", "length", "lengthBytes", "b", "v", "hex", "bytesToNumberBE", "bytes", "int", "tlv", "abytes", "seqBytes", "seqLeftBytes", "rBytes", "rLeftBytes", "sBytes", "sLeftBytes", "sig", "rs", "ss", "seq", "_3n", "_4n", "weierstrass", "params", "extraOpts", "validated", "createCurveFields", "Fp", "Fn", "CURVE", "cofactor", "CURVE_ORDER", "validateObject", "endo", "lengths", "getWLengths", "assertCompressionIsSupported", "pointToBytes", "_c", "point", "isCompressed", "y", "bx", "hasEvenY", "concatBytes", "pprefix", "pointFromBytes", "comp", "uncomp", "head", "tail", "x", "y2", "weierstrassEquation", "sqrtError", "err", "evenY", "L", "isValidXY", "encodePoint", "decodePoint", "x2", "x3", "left", "right", "_4a3", "_27b2", "acoord", "title", "banZero", "aprjpoint", "other", "Point", "splitEndoScalarN", "toAffineMemo", "memoized", "p", "iz", "X", "Y", "Z", "is0", "zz", "assertValidMemo", "finishEndo", "endoBeta", "k1p", "k2p", "negateCt", "P", "hexToBytes", "windowSize", "isLazy", "wnaf", "X1", "Y1", "Z1", "X2", "Y2", "Z2", "U1", "U2", "a", "b3", "X3", "Y3", "Z3", "t0", "t1", "t2", "t3", "t4", "t5", "scalar", "fake", "mul", "normalizeZ", "k1f", "k2f", "f", "sc", "p1", "p2", "mulEndoUnsafe", "invertedZ", "isTorsionFree", "clearCofactor", "bytesToHex", "bits", "wNAF", "getWLengths", "Fp", "Fn", "ecdh", "Point", "ecdhOpts", "randomBytes_", "randomBytes", "lengths", "getMinHashLength", "isValidSecretKey", "secretKey", "num", "isValidPublicKey", "publicKey", "isCompressed", "comp", "publicKeyUncompressed", "l", "randomSecretKey", "seed", "mapHashToField", "abytes", "getPublicKey", "isProbPub", "item", "isBytes", "getSharedSecret", "secretKeyA", "publicKeyB", "s", "utils", "keygen", "createKeygen", "ecdsa", "hash", "ecdsaOpts", "ahash", "validateObject", "hmac", "key", "msg", "CURVE_ORDER", "fnBits", "defaultSigOpts", "hasLargeCofactor", "_2n", "isBiggerThanHalfOrder", "number", "HALF", "_1n", "validateRS", "title", "assertSmallCofactor", "validateSigLength", "bytes", "format", "validateSigFormat", "size", "sizer", "Signature", "r", "recovery", "recid", "DER", "L", "hex", "hexToBytes", "messageHash", "radj", "x", "R", "concatBytes", "pprefix", "ir", "h", "bits2int_modN", "u1", "u2", "Q", "rb", "sb", "bytesToHex", "bits2int", "bytesToNumberBE", "delta", "ORDER_MASK", "bitMask", "int2octets", "aInRange", "_0n", "validateMsgAndHash", "message", "prehash", "prepSig", "opts", "lowS", "extraEntropy", "validateSigOpts", "h1int", "d", "seedArgs", "e", "m", "k2sig", "kBytes", "k", "ik", "q", "normS", "sign", "createHmacDrbg", "verify", "signature", "end", "sig", "P", "is", "recoverPublicKey", "secp256k1_CURVE", "secp256k1_ENDO", "_2n", "sqrtMod", "y", "P", "secp256k1_CURVE", "_3n", "_6n", "_11n", "_22n", "_23n", "_44n", "_88n", "b2", "b3", "b6", "pow2", "b9", "b11", "b22", "b44", "b88", "b176", "b220", "b223", "t1", "t2", "root", "Fpk1", "Field", "Pointk1", "weierstrass", "secp256k1_ENDO", "secp256k1", "ecdsa", "sha256", "hashAndVerify", "key", "sig", "msg", "options", "p", "sha256", "isPromise", "digest", "secp256k1", "err", "VerificationError", "Secp256k1PublicKey", "key", "validateSecp256k1PublicKey", "compressSecp256k1PublicKey", "identity", "publicKeyToProtobuf", "CID", "base58btc", "equals", "data", "sig", "options", "hashAndVerify", "unmarshalSecp256k1PublicKey", "bytes", "Secp256k1PublicKey", "compressSecp256k1PublicKey", "key", "secp256k1", "validateSecp256k1PublicKey", "key", "secp256k1", "err", "InvalidPublicKeyError", "publicKeyFromProtobuf", "buf", "digest", "Type", "Data", "PublicKey", "data", "KeyType", "pkixToRSAPublicKey", "unmarshalEd25519PublicKey", "unmarshalSecp256k1PublicKey", "unmarshalECDSAPublicKey", "UnsupportedKeyTypeError", "publicKeyFromMultihash", "digest", "Type", "Data", "PublicKey", "data", "KeyType", "unmarshalEd25519PublicKey", "unmarshalSecp256k1PublicKey", "unmarshalECDSAPublicKey", "UnsupportedKeyTypeError", "publicKeyToProtobuf", "key", "inspect", "LIBP2P_KEY_CODE", "PeerIdImpl", "init", "peerIdSymbol", "base58btc", "CID", "id", "equals", "RSAPeerId", "Ed25519PeerId", "Secp256k1PeerId", "TRANSPORT_IPFS_GATEWAY_HTTP_CODE", "URLPeerId", "url", "identity", "fromString", "other", "toString", "LIBP2P_KEY_CODE", "TRANSPORT_IPFS_GATEWAY_HTTP_CODE", "peerIdFromString", "str", "decoder", "multihash", "decode", "base58btc", "peerIdFromCID", "CID", "InvalidParametersError", "peerIdFromMultihash", "peerIdFromMultihash", "multihash", "isSha256Multihash", "RSAPeerId", "isIdentityMultihash", "publicKey", "publicKeyFromMultihash", "Ed25519PeerId", "Secp256k1PeerId", "url", "toString", "URLPeerId", "InvalidMultihashError", "peerIdFromCID", "cid", "LIBP2P_KEY_CODE", "TRANSPORT_IPFS_GATEWAY_HTTP_CODE", "InvalidCIDError", "identity", "sha256", "InvalidMessageLengthError", "InvalidDataLengthError", "InvalidDataLengthLengthError", "UnexpectedEOFError", "isAsyncIterable", "thing", "validateMaxDataLength", "chunk", "maxDataLength", "InvalidDataLengthError", "defaultEncoder", "length", "lengthLength", "encodingLength", "lengthBuf", "allocUnsafe", "encode", "source", "options", "encodeLength", "maybeYield", "isAsyncIterable", "Uint8ArrayList", "ReadMode", "defaultDecoder", "buf", "length", "decode", "encodingLength", "source", "options", "buffer", "Uint8ArrayList", "mode", "dataLength", "lengthDecoder", "maxLengthLength", "maxDataLength", "maybeYield", "InvalidMessageLengthError", "InvalidDataLengthError", "dataLengthLength", "err", "InvalidDataLengthLengthError", "data", "isAsyncIterable", "UnexpectedEOFError", "reader", "byteLength", "varByteSource", "done", "value", "l", "pDefer", "deferred", "resolve", "reject", "FixedFIFO", "hwm", "data", "last", "FIFO", "options", "obj", "val", "prev", "next", "AbortError", "message", "code", "pushable", "options", "_pushable", "buffer", "next", "_pushable", "getNext", "options", "onEnd", "buffer", "FIFO", "pushable", "onNext", "ended", "drain", "pDefer", "waitNext", "resolve", "reject", "next", "err", "bufferNext", "bufferError", "push", "value", "end", "_return", "_throw", "signal", "cancel", "listener", "AbortError", "opts", "AbortError", "message", "code", "name", "raceSignal", "promise", "signal", "opts", "listener", "error", "resolve", "reject", "QueuelessPushable", "pDefer", "nextResult", "err", "result", "value", "options", "raceSignal", "queuelessPushable", "isAsyncIterable", "thing", "addAllToPushable", "sources", "output", "signal", "source", "item", "err", "mergeSources", "controller", "queuelessPushable", "mergeSyncSources", "syncSources", "merge", "src_default", "pipe", "first", "rest", "isDuplex", "duplex", "isIterable", "isAsyncIterable", "source", "fns", "i", "duplexPipelineFn", "rawPipe", "res", "obj", "p", "stream", "pushable", "err", "sourceWrap", "src_default", "defaultDecodeRpcLimits", "RPC", "SubOpts", "_codec", "message", "obj", "w", "opts", "reader", "length", "end", "tag", "encodeMessage", "buf", "decodeMessage", "Message", "ControlMessage", "value", "MaxLengthError", "ControlIHave", "ControlIWant", "ControlGraft", "ControlPrune", "PeerInfo", "ControlIDontWant", "MessageCache", "gossip", "historyCapacity", "msgIdToStrFn", "i", "messageId", "msg", "validated", "msgIdStr", "msgId", "fromPeerIdStr", "entry", "p", "count", "topics", "msgIdsByTopic", "msgIds", "message", "originatingPeers", "cacheEntry", "SignaturePolicy", "PublishConfigType", "RejectReason", "ValidateError", "MessageStatus", "rejectReasonFromAcceptance", "acceptance", "TopicValidatorResult", "MessageSource", "InclusionReason", "ChurnReason", "ScorePenalty", "IHaveIgnoreReason", "ScoreThreshold", "getMetrics", "register", "topicStrToLabel", "opts", "topicStr", "reason", "count", "topic", "messageRecord", "acceptance", "firstSeenTimestampMs", "TopicValidatorResult", "penalty", "ihave", "idonthave", "iwantByTopic", "iwantDonthave", "iwant", "idontwant", "idontwantDonthave", "tosendCount", "tosendGroupCount", "dataLen", "ms", "status", "MessageStatus", "error", "RejectReason", "deliveryDelayMs", "isLateDelivery", "rpc", "rpcBytes", "graft", "prune", "scores", "scoreThresholds", "graylist", "publish", "gossip", "mesh", "score", "sw", "wsTopic", "scoreByPeer", "peersPerTopicLabel", "peers", "topicLabel", "peersInMesh", "p", "meshScores", "peer", "InvalidPeerScoreParamsError", "message", "defaultPeerScoreParams", "defaultTopicScoreParams", "createPeerScoreParams", "p", "topics", "topic", "topicScoreParams", "createTopicScoreParams", "validatePeerScoreParams", "params", "validateTopicScoreParams", "e", "InvalidPeerScoreParamsError", "defaultPeerScoreThresholds", "createPeerScoreThresholds", "p", "removeItemsFromSet", "superSet", "ineed", "cond", "subset", "id", "removeFirstNItemsFromSet", "MapDef", "getDefault", "key", "value", "computeScore", "peer", "pstats", "params", "peerIPs", "score", "topic", "tstats", "topicParams", "topicScore", "p1", "p2", "deficit", "p3", "p3b", "p4", "p5", "ip", "peersInIP", "numPeersInIP", "surplus", "p6", "excess", "p7", "import_denque", "DeliveryRecordStatus", "MessageDeliveries", "Denque", "msgIdStr", "drec", "entry", "now", "head", "PeerScore", "MapDef", "MessageDeliveries", "params", "metrics", "componentLogger", "opts", "validatePeerScoreParams", "computeScore", "peer", "stats", "msgIdStr", "drec", "now", "decayToZero", "pstats", "id", "topic", "tstats", "tparams", "cacheEntry", "score", "cacheUntil", "penalty", "penaltyLabel", "ip", "peersWithIP", "threshold", "deficit", "from", "DeliveryRecordStatus", "p", "reason", "RejectReason", "cap", "validatedTime", "deliveryDelayMs", "isLateDelivery", "ipsToRemove", "ipToRemove", "peerSet", "topicStats", "computeScoreWeights", "peer", "pstats", "params", "peerIPs", "topicStrToLabel", "score", "byTopic", "topic", "tstats", "topicLabel", "topicParams", "topicScores", "p1w", "p2w", "p3w", "p3bw", "p4w", "p1", "p2", "deficit", "p3", "p3b", "p4", "capF", "ws", "p5w", "p6w", "p7w", "p5", "ip", "peersInIP", "numPeersInIP", "surplus", "p6", "p7", "computeAllPeersScoreWeights", "peerIdStrs", "peerStats", "sw", "peerIdStr", "swPeer", "swPeerTopic", "swTopic", "getNetConfig", "ma", "components", "config", "index", "InvalidParametersError", "isNetworkAddress", "ma", "getNetConfig", "TimeoutError", "message", "AbortError", "getDOMException", "errorMessage", "getAbortedReason", "signal", "reason", "pTimeout", "promise", "options", "milliseconds", "fallback", "customTimers", "timer", "abortHandler", "cancelablePromise", "resolve", "reject", "timeoutError", "error", "normalizeEmitter", "emitter", "addListener", "removeListener", "pEventMultiple", "event", "options", "cancel", "returnValue", "resolve", "reject", "events", "items", "onItem", "arguments_", "value", "error", "rejectHandler", "rejectionEvent", "timeout", "pTimeout", "pEvent", "arrayPromise", "promise", "array", "isMessageStream", "obj", "messageStreamToDuplex", "stream", "source", "pushable", "onError", "onMessage", "evt", "onRemoteCloseWrite", "onClose", "toGenerator", "gen", "done", "value", "pEvent", "pipe", "input", "sources", "OutboundStream", "rawStream", "errCallback", "opts", "evt", "data", "encode", "options", "err", "InboundStream", "pipe", "source", "decode", "IWantTracer", "gossipsubIWantFollowupMs", "msgIdToStrFn", "metrics", "from", "msgIds", "ix", "msgId", "msgIdStr", "expireByPeer", "now", "result", "brokenPromises", "expire", "p", "isDuplicate", "reason", "RejectReason", "maxMs", "count", "k", "v", "requestMs", "SignPrefix", "fromString", "buildRawMessage", "publishConfig", "topic", "originalData", "transformedData", "PublishConfigType", "rpcMsg", "randomBytes", "bytes", "concat", "RPC", "msg", "toString", "publicKeyFromProtobuf", "validateToRawMessage", "signaturePolicy", "StrictNoSign", "ValidateError", "StrictSign", "fromPeerId", "peerIdFromMultihash", "decode", "publicKey", "rpcMsgPreSign", "createGossipRpc", "messages", "control", "ensureControl", "rpc", "shuffle", "arr", "randInt", "i", "j", "tmp", "messageIdToString", "msgId", "toString", "getPublishConfigFromPeerId", "signaturePolicy", "peerId", "privateKey", "StrictSign", "PublishConfigType", "publicKeyToProtobuf", "StrictNoSign", "msgId", "key", "seqno", "seqnoBytes", "fromString", "keyBytes", "publicKeyToProtobuf", "msgIdFnStrictSign", "msg", "msgId", "msgIdFnStrictNoSign", "sha256", "multiaddrToIPStr", "multiaddr", "isNetworkAddress", "config", "getNetConfig", "SimpleTimeCache", "opts", "key", "value", "now", "k", "v", "GossipStatusCode", "GossipSub", "TypedEventEmitter", "GossipsubIDv12", "GossipsubIDv11", "GossipsubIDv10", "pushable", "components", "options", "opts", "createPeerScoreParams", "createPeerScoreThresholds", "defaultDecodeRpcLimits", "StrictSign", "FloodsubID", "p", "SimpleTimeCache", "msgIdFnStrictSign", "StrictNoSign", "msgIdFnStrictNoSign", "messageIdToString", "MessageCache", "maxMeshMessageDeliveriesWindowMs", "topicParam", "metrics", "getMetrics", "protocol", "IWantTracer", "PeerScore", "serviceCapabilities", "serviceDependencies", "getPublishConfigFromPeerId", "pipe", "source", "peerId", "connection", "e", "registrar", "topology", "registrarTopologyIds", "heartbeatTimeout", "id", "err", "closePromises", "outboundStream", "inboundStream", "stream", "OutboundStream", "priorInboundStream", "InboundStream", "direction", "addr", "currentIP", "multiaddrToIPStr", "peers", "topicStr", "ChurnReason", "topic", "peersInTopic", "str", "peerIdFromString", "data", "rpcBytes", "rpc", "RPC", "from", "subscriptions", "messages", "ihave", "iwant", "graft", "prune", "subOpt", "subscribe", "message", "handleReceivedMessagePromise", "topicSet", "rpcMsg", "validationResult", "validationCode", "MessageStatus", "msgIdStr", "propagationSource", "fastMsgIdStr", "msgIdCached", "validateToRawMessage", "RejectReason", "msg", "ValidateError", "msgId", "messageId", "topicValidator", "acceptance", "errCode", "ERR_TOPIC_VALIDATOR_IGNORE", "TopicValidatorResult", "ERR_TOPIC_VALIDATOR_REJECT", "rejectReasonFromAcceptance", "toPeer", "topics", "controlMsg", "sent", "createGossipRpc", "iwantMessageIds", "now", "entry", "score", "IHaveIgnoreReason", "peerhave", "iasked", "topicID", "messageIDs", "idonthave", "iask", "iwantList", "shuffle", "iwantByTopic", "iwantDonthave", "doPX", "peersInMesh", "backoffExpiry", "ScorePenalty", "floodCutoff", "InclusionReason", "onUnsubscribe", "backoff", "idontwant", "idontwantCount", "startIdontwantCount", "idontwants", "out", "total", "intervalMs", "expire", "count", "toconnect", "pi", "peer", "peerIdFromMultihash", "decode", "wasSubscribed", "toAdd", "fanoutPeers", "fanoutCount", "meshPeers", "excludePeers", "tosend", "tosendCount", "newFanoutPeers", "rawMsg", "startMs", "transformedData", "buildRawMessage", "ignoreDuplicatePublishError", "willSendToSelf", "allowPublishToZeroTopicPeers", "batchPublish", "durationMs", "prefixedData", "encode", "cacheEntry", "originatingPeers", "rejectReason", "firstSeenTimestampMs", "ids", "idontwantRpc", "ctrl", "outRpc", "ensureControl", "tograft", "toprune", "noPX", "pruning", "peersToGossipByTopic", "gossipIDsByTopic", "peersToGossip", "candidateToGossip", "target", "factor", "peerMessageIDs", "control", "controlIHaveMsgs", "gossip", "backoffMs", "xid", "px", "peerInfo", "timer", "msToNextHeartbeat", "D", "Dlo", "Dhi", "Dscore", "Dout", "fanoutTTL", "scores", "getScore", "s", "heartbeatTick", "candidateMeshPeers", "shuffledPeers", "peerStreams", "prunePeer", "reason", "graftPeer", "ineed", "removeFirstNItemsFromSet", "peersArray", "a", "b", "outbound", "rotate", "i", "j", "removeItemsFromSet", "peersList", "medianIndex", "medianScore", "newMeshPeers", "lastpb", "topicPeers", "candidateFanoutPeers", "filter", "backoffSize", "expiredMs", "idontwantsCount", "scoreByPeer", "peerIdStr", "sw", "computeAllPeersScoreWeights", "evt", "StrictSign", "StrictNoSign", "TopicValidatorResult", "multicodec", "GossipsubIDv12", "gossipsub", "init", "components", "GossipSub"]
}
