import { AbstractStreamMuxer } from '@libp2p/utils';
import { webtransportBiDiStreamToStream } from './stream.js';
const PROTOCOL = '/webtransport';
class WebTransportStreamMuxer extends AbstractStreamMuxer {
    webTransport;
    streamIDCounter;
    reader;
    constructor(webTransport, maConn) {
        super(maConn, {
            protocol: PROTOCOL,
            name: 'muxer'
        });
        this.webTransport = webTransport;
        this.streamIDCounter = 0;
        this.reader = this.webTransport.incomingBidirectionalStreams.getReader();
        Promise.resolve()
            .then(async () => {
            //! TODO unclear how to add backpressure here?
            while (true) {
                const { done, value } = await this.reader.read();
                if (done || value == null) {
                    break;
                }
                this.onRemoteStream(webtransportBiDiStreamToStream(value, String(this.streamIDCounter++), 'inbound', this.log, this.streamOptions));
            }
        })
            .catch(err => {
            this.log.error('could not create a new stream - %e', err);
        });
    }
    async onCreateStream(options) {
        const wtStream = await this.webTransport.createBidirectionalStream();
        options?.signal?.throwIfAborted();
        return webtransportBiDiStreamToStream(wtStream, String(this.streamIDCounter++), 'outbound', this.log, options);
    }
    onData() {
    }
    sendReset() {
        this.webTransport.close();
    }
}
export function webtransportMuxer(webTransport) {
    return {
        protocol: PROTOCOL,
        createStreamMuxer(maConn) {
            return new WebTransportStreamMuxer(webTransport, maConn);
        }
    };
}
//# sourceMappingURL=muxer.js.map